<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thinkings and Works</title>
  
  <subtitle>A HA IOer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://leceue.github.io./"/>
  <updated>2019-11-13T05:29:18.078Z</updated>
  <id>http://leceue.github.io./</id>
  
  <author>
    <name>Mr_Leceue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tarjan初步-强联通分量</title>
    <link href="http://leceue.github.io./2019/11/13/strongly-connected/"/>
    <id>http://leceue.github.io./2019/11/13/strongly-connected/</id>
    <published>2019-11-13T02:00:37.000Z</published>
    <updated>2019-11-13T05:29:18.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    发现我又咕咕了一篇早就应该写的博客,唉,真是的;</p><p>​    强联通分量常用于缩点,重建图去跑其他算法;</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>​    强联通分量存在于有向图,简单的概念即有向图中一个块中的点可以彼此到达,这个块被称为分量,而两点彼此能到到达称为强联通,那么强联通分量的概念就出来了;</p><p>​    同样用的时间戳(dfn)与返祖标记(low)这个概念,如果不知道,请看本博客中的点双边双;</p><a id="more"></a><p>​    与点双相同的是当一个点dfn=low时,那么其栈中的点到这个点,即这个搜索子树就是就是一个强联通分量;</p><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>​    有一定基础,或者已经理解了话可以跳过该过程,这里不再给出严谨证明;</p><p> <img src="/images/0`7]J}2U(`1" alt="alt">SUJ[B`RCUTE.png) </p><p><img src="/images/1573611715606.png" alt="alt"></p><p><img src="/images/1573611747760.png" alt="alt"></p><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>​    <a href="https://www.luogu.org/problem/P2341" target="_blank" rel="noopener">P2341 [HAOI2006]受欢迎的牛</a></p><p>模版题;</p><blockquote><p>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶</p><p>牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜</p><p>欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你</p><p>算出有多少头奶牛可以当明星。</p></blockquote><p>​    如果没有环,那么就是一个没有出度的点,如果有强联通分量,那么只要统计每个强联通分量的出度即可;</p><p>​    答案就是那个出度为0强联通分量中点的个数,记住特判一下有多个出度为0的强联通分量,这样答案会是0;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d 10000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[<span class="number">20007</span>],cent,low[<span class="number">20007</span>],dfn[<span class="number">20007</span>],t,stackk[<span class="number">20007</span>];</span><br><span class="line"><span class="keyword">int</span> top,temp,col[<span class="number">20007</span>],vis[<span class="number">20007</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> out[<span class="number">10007</span>],tot[<span class="number">10007</span>],fu[<span class="number">10007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">low[x]=dfn[x]=++t;vis[x]=<span class="number">1</span>;</span><br><span class="line">stackk[++top]=x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y);</span><br><span class="line">low[x]=min(low[x],low[y]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y])&#123;</span><br><span class="line">low[x]=min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">temp=stackk[top--];</span><br><span class="line">vis[temp]=<span class="number">0</span>;</span><br><span class="line">col[temp]=cnt;</span><br><span class="line">tot[cnt]++;</span><br><span class="line">&#125;<span class="keyword">while</span>(temp!=x);<span class="comment">//注意特判条件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">add(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j;j=edge[j].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[j].to;</span><br><span class="line"><span class="keyword">if</span>(col[y]!=col[i])&#123;</span><br><span class="line">fu[col[i]]++;<span class="comment">//统计出度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!fu[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;<span class="built_in">printf</span>(<span class="string">"0"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">flag=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,tot[flag]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>​    <a href="https://www.luogu.org/problem/P2746" target="_blank" rel="noopener">P2746 校园网</a></p><blockquote><p>求一个有向图入度为0的点的个数,和连多少条边能使图互相连通;</p></blockquote><p>​    <del>我怎么又放了一道模版题</del></p><p>​    缩点一下,求出入度为0的点即可,下一问,我们可以将入度为0的点和出度为0的点两两配对,如果不够,将多出来的随便接在一个上面即可(因为已经匹配完的是一个强联通分量)</p><h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[<span class="number">1007</span>],cent,dfn[<span class="number">1007</span>],low[<span class="number">1007</span>],t,cnt;</span><br><span class="line"><span class="keyword">int</span> stackk[<span class="number">1007</span>],top,col[<span class="number">1007</span>],tot[<span class="number">1007</span>],vis[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> ans1,ans2,out[<span class="number">1007</span>],in[<span class="number">1007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[<span class="number">10000007</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x]=low[x]=++t;vis[x]=<span class="number">1</span>;</span><br><span class="line">stackk[++top]=x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y);</span><br><span class="line">low[x]=min(low[x],low[y]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y])&#123;</span><br><span class="line">low[x]=min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">cnt++;<span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">z=stackk[top--];</span><br><span class="line">col[z]=cnt;</span><br><span class="line">vis[z]=<span class="number">0</span>;</span><br><span class="line">tot[cnt]++;</span><br><span class="line">&#125;<span class="keyword">while</span>(z!=x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,s;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line"><span class="keyword">while</span>(s) add(i,s),<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(col[y]==col[x]) <span class="keyword">continue</span>;</span><br><span class="line">out[col[x]]++;in[col[y]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!out[i]) ans2++;</span><br><span class="line"><span class="keyword">if</span>(!in[i]) ans1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"1\n0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,ans1,max(ans1,ans2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p><a href="https://www.luogu.org/problem/P3627" target="_blank" rel="noopener">P3627 抢掠计划</a></p><blockquote><p>Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。</p><p>Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心 出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆 祝他的胜利。</p><p>使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希 望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可 以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机 里面就不会再有钱了。</p></blockquote><p>​    Tarjan+SPFA(Dij);</p><p>​    我们可以发现题目中给了我们提示;</p><blockquote><p>他可以经过同一路口或道路任意多次;</p></blockquote><p>​    那么就是强联通分量缩点,一个强联通分量中的钱是可以全部拿走的,直接在缩点的图SPFA就行了;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],dfn[maxn],low[maxn],val[maxn],stk[maxn],col[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn],cent,a[maxn],s,op[maxn],tot,cnt,top,p,dis[maxn],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,from,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],u,v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x]=low[x]=++tot;vis[x]=<span class="number">1</span>;</span><br><span class="line">stk[++top]=x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y);</span><br><span class="line">low[x]=min(low[x],low[y]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y]) low[x]=min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">cnt++;<span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">temp=stk[top--];</span><br><span class="line">vis[temp]=<span class="number">0</span>;</span><br><span class="line">col[temp]=cnt;</span><br><span class="line">val[cnt]+=a[temp];</span><br><span class="line">&#125;<span class="keyword">while</span>(temp!=x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">dis[s]=val[s];vis[s]=<span class="number">1</span>;q.push(s);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.front();q.pop();vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(dis[y]&lt;dis[x]+val[y])&#123;</span><br><span class="line">dis[y]=dis[x]+val[y];</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) q.push(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("cin.in","r",stdin);</span></span><br><span class="line">scan(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++) scan(u,v),add(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">int</span> lim=cent;cent=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(col[x]!=col[y]) add(col[x],col[y]);</span><br><span class="line">&#125;</span><br><span class="line">scan(s,p);dis[col[s]]=val[col[s]];</span><br><span class="line">spfa(col[s]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++) scan(op[i]),ans=max(ans,dis[col[op[i]]]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h4><p>​    <a href="https://www.luogu.org/problem/P3119" target="_blank" rel="noopener">P3119 草鉴定</a></p><blockquote><p>约翰有n块草场，编号1到n，这些草场由若干条单行道相连。奶牛贝西是美味牧草的鉴赏家，她想到达尽可能多的草场去品尝牧草。</p><p>贝西总是从1号草场出发，最后回到1号草场。她想经过尽可能多的草场，贝西在通一个草场只吃一次草，所以一个草场可以经过多次。因为草场是单行道连接，这给贝西的品鉴工作带来了很大的不便，贝西想偷偷逆向行走一次，但最多只能有一次逆行。问，贝西最多能吃到多少个草场的牧草。</p></blockquote><p>​    显然一个强联通分量中的点可以互相到达,缩点即可;</p><p>​    之后我们可以枚举逆行的边,求逆行边的两个点到1号草场所在强联通分量的路即可,其路的权值即所经过强联通分量的全权值和;</p><p>​    如何求最长路?正向建边反向建边跑SPFA最长路即可;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],cent,dfn[maxn],low[maxn],stk[maxn],cnt,ans;</span><br><span class="line"><span class="keyword">int</span> col[maxn],tot,k,vis[maxn],num[maxn],dis1[maxn],dis2[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to,from;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan &gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tops,<span class="keyword">typename</span>... Tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(tops &amp;x,Tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],v,u&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x]=++cnt,low[x]=cnt;</span><br><span class="line">stk[++k]=x;vis[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y);</span><br><span class="line">low[x]=min(low[x],low[y]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y]) low[x]=min(low[x],dfn[y]);<span class="comment">//是vis[y]而不是vis[x] </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">tot++;<span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">z=stk[k--];</span><br><span class="line">col[z]=tot;</span><br><span class="line">vis[z]=<span class="number">0</span>;</span><br><span class="line">num[tot]++;</span><br><span class="line">&#125;<span class="keyword">while</span>(z!=x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">vis[col[<span class="number">1</span>]]=<span class="number">1</span>;dis1[col[<span class="number">1</span>]]=num[col[<span class="number">1</span>]];</span><br><span class="line">q.push(col[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(dis1[y]&lt;dis1[x]+num[y])&#123;</span><br><span class="line">dis1[y]=dis1[x]+num[y];</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) q.push(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">vis[col[<span class="number">1</span>]]=<span class="number">1</span>;dis2[col[<span class="number">1</span>]]=num[col[<span class="number">1</span>]];</span><br><span class="line">q.push(col[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(dis2[y]&lt;dis2[x]+num[y])&#123;</span><br><span class="line">dis2[y]=dis2[x]+num[y];</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) q.push(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("cout.out","w",stdout);</span></span><br><span class="line">scan(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)</span><br><span class="line">scan(u,v),add(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(!col[i]) Tarjan(i);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);cent=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(col[x]!=col[y]) add(col[x],col[y]);</span><br><span class="line">&#125;</span><br><span class="line">spfa1();<span class="keyword">int</span> ol=cent;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);cent=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ol;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line">add(y,x);</span><br><span class="line">&#125;</span><br><span class="line">spfa2();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ol;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(dis1[x]&amp;&amp;dis2[y]) ans=max(ans,dis1[x]+dis2[y]);</span><br><span class="line"><span class="keyword">if</span>(dis1[y]&amp;&amp;dis2[x]) ans=max(ans,dis1[y]+dis2[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans-num[col[<span class="number">1</span>]]);</span><br><span class="line"><span class="comment">//for(int i=1;i&lt;=tot;i++) cout&lt;&lt;dis1[i]&lt;&lt;" "&lt;&lt;dis2[i]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h4><p>​    <a href="https://www.luogu.org/problem/P2515" target="_blank" rel="noopener">P2515 [HAOI2010]软件安装</a></p><p>​    Tarjan+树形背包;</p><p>​    每次缩点,重新建图,然后跑个树形DP(蓝书上有);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 107</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],val[maxn],cost[maxn],low[maxn],dfn[maxn],sz[maxn];</span><br><span class="line"><span class="keyword">int</span> col[maxn],cent,stk[maxn],tot,top,cnt,vis[maxn],w[maxn],in[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn&lt;&lt;<span class="number">3</span>],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,from,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],u,v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">dfn[x]=low[x]=++tot;vis[x]=<span class="number">1</span>;</span><br><span class="line">stk[++top]=x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">Tarjan(y);</span><br><span class="line">low[x]=min(low[y],low[x]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y]) low[x]=min(low[x],dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">cnt++;<span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">temp=stk[top--];</span><br><span class="line">vis[temp]=<span class="number">0</span>;</span><br><span class="line">col[temp]=cnt;</span><br><span class="line">sz[cnt]+=cost[temp];</span><br><span class="line">w[cnt]+=val[temp];</span><br><span class="line">&#125;<span class="keyword">while</span>(temp!=x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">for</span>(<span class="keyword">int</span> t=m;t&gt;=sz[x];t--) f[x][t]=w[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">dfs(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=m-sz[x];t&gt;=<span class="number">0</span>;t--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=t;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">f[x][t+sz[x]]=max(f[x][t+sz[x]],f[x][t+sz[x]-j]+f[y][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scan(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(cost[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(val[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++) &#123;</span><br><span class="line">scan(x);</span><br><span class="line"><span class="keyword">if</span>(x) add(x,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line"><span class="keyword">int</span> lim=cent;cent=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(col[x]!=col[y]) add(col[x],col[y]),in[col[y]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) add(<span class="number">0</span>,i);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) ans=max(ans,f[<span class="number">0</span>][i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 10</span></span><br><span class="line"><span class="comment">5 5 6</span></span><br><span class="line"><span class="comment">2 3 4</span></span><br><span class="line"><span class="comment">0 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="TO-BE-CONTINUE"><a href="#TO-BE-CONTINUE" class="headerlink" title="TO BE CONTINUE"></a>TO BE CONTINUE</h5>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;​    发现我又咕咕了一篇早就应该写的博客,唉,真是的;&lt;/p&gt;&lt;p&gt;​    强联通分量常用于缩点,重建图去跑其他算法;&lt;/p&gt;&lt;h2 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h2&gt;&lt;p&gt;​    强联通分量存在于有向图,简单的概念即有向图中一个块中的点可以彼此到达,这个块被称为分量,而两点彼此能到到达称为强联通,那么强联通分量的概念就出来了;&lt;/p&gt;&lt;p&gt;​    同样用的时间戳(dfn)与返祖标记(low)这个概念,如果不知道,请看本博客中的点双边双;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="图论" scheme="http://leceue.github.io./tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>单调队列</title>
    <link href="http://leceue.github.io./2019/11/11/DP-queue/"/>
    <id>http://leceue.github.io./2019/11/11/DP-queue/</id>
    <published>2019-11-11T13:26:57.000Z</published>
    <updated>2019-11-12T07:30:00.097Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    单调队列并不是太难的东西,不应其应用到的题目困难而觉得单调队列困难.</p><p>​    我第一次遇见单调队列时是在学图论时,遇到了Island这道题(见基环树专题),当时的我对单调队列一无所知,而对其优化更是懵,所以当时就懵着将题解半抄半写地打了出来,但还是不懂.现在来看,单论单调队列,它是不难的,难的是与其他算法的结合;</p><a id="more"></a><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h4 id="限制与应用"><a href="#限制与应用" class="headerlink" title="限制与应用"></a>限制与应用</h4><p>​    对于单调队列,有两个操作,入队和出队;</p><p>​    有两个限制,队首元素满足区间条件,队列中数满足单调;</p><p>​    应用限制,转移DP时应满足区间取max-min操作,即让单调有其发挥作用的空间;</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​    推荐这道<a href="https://www.luogu.org/problem/P2698" target="_blank" rel="noopener">例题</a>理解一下单调队列思想;</p><blockquote><p>老板需要你帮忙浇花。给出N滴水的坐标，y表示水滴的高度，x表示它下落到x轴的位置。</p><p>每滴水以每秒1个单位长度的速度下落。你需要把花盆放在x轴上的某个位置，使得从被花盆接着的第1滴水开始，到被花盆接着的最后1滴水结束，之间的时间差至少为D。</p><p>我们认为，只要水滴落到x轴上，与花盆的边沿对齐，就认为被接住。给出N滴水的坐标和D的大小，请算出最小的花盆的宽度W。</p></blockquote><p>​    我们首先考虑到答案是具有单调性的,宽度W满足条件,那么大于W的也会满足条件,那么我们可以二分答案;</p><p>​    二分答案后,我们可以得到一个区间,我们想要的即所有区间中是否存在 $max-min&gt;=D$ ;</p><p>​    这里就引入了单调队列,单调队列的队首表示区间 $i-mid-1$ ~ $i$ 最大值或者最小值,其限制条件即 $q[l]&gt;=i-mid-1$ ,不满足条件时弹出.</p><p>​    入队时,比较队尾元素和要加入元素值,比较方式是 “比我小的人还比我强,那我就要退役了” ,即未来会更新到我们要加入值,存在时间肯定比队尾元素长,而队尾元素又比要加入的值小,那么队尾元素的贡献就可以被要加入的值代替,故直接弹出;</p><p>​    那么这里我们限制一下区间,求出区间最大值与最小值,更新最大差值即可;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,d,lim,q[maxn],f[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,x=<span class="number">1</span>,y=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> maxx=<span class="number">-1</span>,minx=inf;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;a[q[l]].x&lt;=a[i].x-mid<span class="number">-1</span>) l++;<span class="comment">//限制区间弹出,注意区间大小为mid+1 </span></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;a[q[r]].y&lt;=a[i].y) r--;<span class="comment">//根据原则弹出 </span></span><br><span class="line">q[++r]=i;maxx=max(a[q[l]].y,maxx);<span class="comment">//更新,下面是一样的 </span></span><br><span class="line"><span class="keyword">while</span>(x&lt;=y&amp;&amp;a[f[x]].x&lt;=a[i].x-mid<span class="number">-1</span>) x++;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=y&amp;&amp;a[f[y]].y&gt;=a[i].y) y--;</span><br><span class="line">f[++y]=i;minx=min(a[f[x]].y,minx);</span><br><span class="line">ans=max(maxx-minx,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans&gt;=d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scan(n),scan(d);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i].x),scan(a[i].y),lim=max(a[i].x,lim);</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);<span class="comment">//排序 </span></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=lim;</span><br><span class="line"><span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!check(l)) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    另一道<a href="https://www.luogu.org/problem/P2564" target="_blank" rel="noopener">例题</a> ,主要是依靠单调队列原则进行;</p><blockquote><p>求一段最短的区间,其区间中包含了所有类型的颜色;</p></blockquote><p>​    根据题目中区间的信息,我们可以隐约地想到单调队列,但是并没有单调性.</p><p>​    考虑队首弹出条件,当一个颜色在一个区间多次出现时,有贡献的只会是一个,那么当队首颜色重复时,其贡献已经被之后的颜色代替,也就没用了,那么既可以弹出;</p><p>​    队尾弹出就不再需要了,我们直接更新满足条件的区间即可;</p><p>​    那么思路即,对每种颜色计数,当队首元素颜色个数&gt;=2时,将其弹出;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,num;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">1000007</span>],ans=<span class="number">2147483647</span>,vis[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id,sp;</span><br><span class="line">&#125;a[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.sp&lt;b.sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>,to;k&lt;=m;k++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;to);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=to;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[++cnt].sp),a[cnt].id=k;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[a[i].id]) vis[a[i].id]++;</span><br><span class="line"><span class="keyword">if</span>(!vis[a[i].id]) vis[a[i].id]++,num++;</span><br><span class="line"><span class="keyword">while</span>(vis[a[q[l]].id]&gt;<span class="number">1</span>) vis[a[q[l]].id]--,l++;<span class="comment">//超过一个,弹出</span></span><br><span class="line">q[++r]=i;</span><br><span class="line"><span class="keyword">if</span>(num==m) ans=min(ans,a[q[r]].sp-a[q[l]].sp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>​    二维单调队列,在一个固定矩形中,求其中最大值和最小值.</p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>​    <a href="https://www.luogu.org/problem/P2216" target="_blank" rel="noopener"> [HAOI2007]理想的正方形 </a></p><blockquote><p>在一个 $a<em>b$ 的矩形中,求一个最大值与最小值差值最小的 $n</em>n$ 的正方形,输出其差值;</p></blockquote><p>​    首先求出横向一维区间最大值,之后在原有横向区间最大值中求纵向一维区间最大值,这里由于用到了横向一维的值,使其变成了二维,那么思路就很显然了,注意区间大小和边界限制;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,n,maps[<span class="number">1007</span>][<span class="number">1007</span>],work1[<span class="number">1007</span>][<span class="number">1007</span>],qmax[<span class="number">1007</span>],qmin[<span class="number">1007</span>],ans1[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">100007</span>],work2[<span class="number">1007</span>][<span class="number">1007</span>],ans2[<span class="number">1007</span>][<span class="number">1007</span>],ans=<span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maps[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=a;x++)&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,k=n;</span><br><span class="line"><span class="built_in">memset</span>(qmax,<span class="number">0</span>,<span class="keyword">sizeof</span>(qmax));</span><br><span class="line"><span class="built_in">memset</span>(qmin,<span class="number">0</span>,<span class="keyword">sizeof</span> qmin);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmax[l]) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;maps[x][qmax[r]]&lt;=maps[x][i]) r--;</span><br><span class="line">qmax[++r]=i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n) work1[x][i-k+<span class="number">1</span>]=maps[x][qmax[l]];</span><br><span class="line">&#125;</span><br><span class="line">l=<span class="number">1</span>,r=<span class="number">0</span>,k=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmin[l]) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;maps[x][qmin[r]]&gt;=maps[x][i]) r--;</span><br><span class="line">qmin[++r]=i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n) work2[x][i-k+<span class="number">1</span>]=maps[x][qmin[l]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//横向区间最大最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=b;x++)&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,k=n;</span><br><span class="line"><span class="built_in">memset</span>(qmax,<span class="number">0</span>,<span class="keyword">sizeof</span>(qmax));</span><br><span class="line"><span class="built_in">memset</span>(qmin,<span class="number">0</span>,<span class="keyword">sizeof</span> qmin);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmax[l]) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;work1[qmax[r]][x]&lt;=work1[i][x]) r--;</span><br><span class="line">qmax[++r]=i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n) ans1[i-k+<span class="number">1</span>][x]=work1[qmax[l]][x];</span><br><span class="line">&#125;</span><br><span class="line">l=<span class="number">1</span>,r=<span class="number">0</span>,k=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmin[l]) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;work2[qmin[r]][x]&gt;=work2[i][x]) r--;</span><br><span class="line">qmin[++r]=i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=n) ans2[i-k+<span class="number">1</span>][x]=work2[qmin[l]][x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//纵向区间最大最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b-n+<span class="number">1</span>;j++)</span><br><span class="line">ans=min(ans,ans1[i][j]-ans2[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>​    <a href="https://www.luogu.org/problem/P2219" target="_blank" rel="noopener"> [HAOI2007]修筑绿化带 </a>,</p><blockquote><p>如果把公园看成一个 $M <em> N$ 的矩形，那么花坛可以看成一个 $C</em>D$ 的矩形，绿化带和花坛一起可以看成一个 $A*B$ 的矩形。</p><p>如果将花园中的每一块土地的“肥沃度”定义为该块土地上每一个小块肥沃度之和，那么， </p><p>绿化带的肥沃度= $A<em>B$ 块的肥沃度 $- C</em>D$块的肥沃度 </p><p>为了使得绿化带的生长得旺盛，我们希望绿化带的肥沃度最大。</p></blockquote><p>​    <del>震惊!某HA省竟在同一年考了两道相同算法的题</del> </p><p>​    这道题看起来是求最大区间值和,但是如果我们先用二维前缀和预处理出 $C<em>D$ 矩形的权值和,然后再限制在 $A</em>B$ 的矩形中,即上面那道题,有些不同的是,花坛不能触碰边界,注意边界的划分.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m,n,c,d,a,b,maps[<span class="number">1007</span>][<span class="number">1007</span>],num[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> qmin[<span class="number">1007</span>],mms[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> work2[<span class="number">1007</span>][<span class="number">1007</span>],ans2[<span class="number">1007</span>][<span class="number">1007</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;m,&amp;n,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maps[i][j]);</span><br><span class="line">num[i][j]=maps[i][j]+num[i<span class="number">-1</span>][j]+num[i][j<span class="number">-1</span>]-num[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=c;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=d;j&lt;=n;j++)&#123;</span><br><span class="line">maps[i-c+<span class="number">1</span>][j-d+<span class="number">1</span>]=num[i][j]-num[i-c][j]-num[i][j-d]+num[i-c][j-d];</span><br><span class="line"><span class="keyword">if</span>(i&gt;=a&amp;&amp;j&gt;=b) mms[i-a+<span class="number">1</span>][j-b+<span class="number">1</span>]=num[i][j]-num[i-a][j]-num[i][j-b]+num[i-a][j-b];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m<span class="number">-1</span>;x++)&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,k=b-d<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(qmin,<span class="number">0</span>,<span class="keyword">sizeof</span> qmin);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmin[l]) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;maps[x][qmin[r]]&gt;=maps[x][i]) r--;</span><br><span class="line">qmin[++r]=i;</span><br><span class="line"><span class="keyword">if</span>(i-k+<span class="number">1</span>&gt;=<span class="number">0</span>) work2[x][i-k+<span class="number">1</span>]=maps[x][qmin[l]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n<span class="number">-1</span>;x++)&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,k=a-c<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(qmin,<span class="number">0</span>,<span class="keyword">sizeof</span> qmin);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmin[l]) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;work2[qmin[r]][x]&gt;=work2[i][x]) r--;</span><br><span class="line">qmin[++r]=i;</span><br><span class="line"><span class="keyword">if</span>(i-k+<span class="number">1</span>&gt;<span class="number">0</span>) ans2[i-k+<span class="number">1</span>][x]=work2[qmin[l]][x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m-a+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-b+<span class="number">1</span>;j++)&#123;</span><br><span class="line">ans=max(ans,mms[i][j]-ans2[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DP与单调队列"><a href="#DP与单调队列" class="headerlink" title="DP与单调队列"></a>DP与单调队列</h3><p>​    <a href="https://www.luogu.org/problem/P2569" target="_blank" rel="noopener"> [SCOI2010]股票交易 </a>;</p><blockquote><p>通过一段时间的观察，$\text{lxhgww}$  预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$ ，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i &gt; BP_i$ ），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。</p><p>另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\text{MaxP}$。</p><p>在第 $1$ 天之前，$\text{lxhgww}$  手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？</p></blockquote><p>​    首先推出DP式子,设 $f[i][j]$ 为第 $i$ 天手持 $j$ 个股票是的最大收入,那么分类转移;</p><p>​    CASE1: 没有买股票, $f[i][j]=f[i-1][j]$ </p><p>​    CASE2: 买了股票,但是有 $W$ 天的限制,所以转移应为 $f[i][j]=max(f[i-w-1][j-k] - k*AP_i ,f[i][j])$ ;</p><p>​    CASE3:  卖了股票, $f[i][j]=max(f[i-w-1][j+k]+k*BP_i , f[i][j])$ ;</p><p>​    那么 $k$ 的枚举我们可以用单调队列优化掉,时间复杂度 $O(tm)$ .</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,m,w,f[<span class="number">2007</span>][<span class="number">2007</span>],q[<span class="number">2007</span>],ans=-INT_MAX;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;m,&amp;w);</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">128</span>,<span class="keyword">sizeof</span>(f));<span class="comment">//初始化最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,ap,bp,as,bs;i&lt;=t;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;ap,&amp;bp,&amp;as,&amp;bs);</span><br><span class="line"><span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span> q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=as;j++) f[i][j]=-ap*j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j]);</span><br><span class="line"><span class="keyword">if</span>(i&lt;=w) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;j-as) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;f[i-w<span class="number">-1</span>][q[r]]+q[r]*ap&lt;=f[i-w<span class="number">-1</span>][j]+j*ap) r--;</span><br><span class="line">q[++r]=j;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=r) f[i][j]=max(f[i][j],f[i-w<span class="number">-1</span>][q[l]]+q[l]*ap-j*ap);</span><br><span class="line">&#125;<span class="comment">//买的时候从比自己股票少的转移,正序枚举 </span></span><br><span class="line"><span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span> q);</span><br><span class="line">l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;j+bs) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;f[i-w<span class="number">-1</span>][q[r]]+q[r]*bp&lt;=f[i-w<span class="number">-1</span>][j]+j*bp) r--;</span><br><span class="line">q[++r]=j;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=r) f[i][j]=max(f[i][j],f[i<span class="number">-1</span>-w][q[l]]+q[l]*bp-j*bp);</span><br><span class="line">&#125;<span class="comment">//卖的时候从比自己股票多的转移,倒序枚举 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,f[t][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    单调队列可以有效处理区间最大最小值信息,这在DP方程转移过程中有重要意义,但在应用时应注意其应用范围,而不是盲目的套;</p><p>​    应用时要注意细节问题,区间范围应卡好,出队时注意判断范围;</p><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><p>​    <a href="https://www.luogu.org/problem/P2254" target="_blank" rel="noopener">P2254 [NOI2005]瑰丽华尔兹</a> ;</p><h5 id="TO-BE-CONTINUE"><a href="#TO-BE-CONTINUE" class="headerlink" title="TO BE CONTINUE"></a>TO BE CONTINUE</h5>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;​    单调队列并不是太难的东西,不应其应用到的题目困难而觉得单调队列困难.&lt;/p&gt;&lt;p&gt;​    我第一次遇见单调队列时是在学图论时,遇到了Island这道题(见基环树专题),当时的我对单调队列一无所知,而对其优化更是懵,所以当时就懵着将题解半抄半写地打了出来,但还是不懂.现在来看,单论单调队列,它是不难的,难的是与其他算法的结合;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DP" scheme="http://leceue.github.io./tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>D-DP</title>
    <link href="http://leceue.github.io./2019/11/10/D-DP/"/>
    <id>http://leceue.github.io./2019/11/10/D-DP/</id>
    <published>2019-11-10T13:44:55.000Z</published>
    <updated>2019-11-10T23:42:36.718Z</updated>
    
    <content type="html"><![CDATA[<h4 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h4><p>​    树链剖分,最大权独立集(即没有上司的舞会(树上DP)),矩阵乘法;</p><h2 id="D-DP"><a href="#D-DP" class="headerlink" title="D-DP"></a>D-DP</h2><h3 id="模版简述"><a href="#模版简述" class="headerlink" title="模版简述"></a>模版简述</h3><p>​    <a href="https://www.luogu.org/problem/P4719" target="_blank" rel="noopener">模板</a> </p><p>​    关于动态DP,其实是关于一类动态修改点权的问题,但是很难去处理;</p><p>​    我们平常的DP经常是离线DP,而当在线时,就会出现事故;</p><p>​    D-DP是关于求最大权独立集的,支持动态修改点值,其思想即DP的通项递推式改为矩阵乘的形式进行递推,而树上问题就可以使用树链剖分提前处理出区间矩阵乘;</p><a id="more"></a><p>​    大家肯定都会 $O(nm)$ 做法,即暴力修改点值进行DP.</p><p>​    求最大权独立集的DP式子为 $f[x][1]=\sum f[y][0] , f[x][0]=\sum max(f[y][1],f[y][0])$ ,如果我们将其改成矩阵乘的形式,就变成了下面这样;</p><script type="math/tex; mode=display">[^{f[y][0]}_{f[y][1]}] * [^{0,0}_{v[x],-inf}]=[^{f[x][0]}_{f[x][1]}]</script><p>​    这个式子并不完整,这只是从一个点的矩阵乘,这个式子只是类似于矩阵乘,我们可以重新定义一下矩阵乘的定义,即将加法改为 $max$ ,将乘法改为加法,那么就可以通项递推了;</p><p>​    但是这个式子只限于从一个点递推过来,那么其他点怎么办?</p><p>​    没有办法…但是这是一个思路,这个式子用线段树维护,可以让我们可以快速处理出链上信息.</p><p>​    既然在树上,我们不如将重链看成这个链,而将链上的轻儿子的信息提前处理出来,在重链上的点的信息通过进行矩阵速推.</p><script type="math/tex; mode=display">[^{f[y][0]}_{f[y][1]}]*[^{f'[x][0],f'[x][0]}_{f'[x][1],-inf}]=[^{f[x][0]}_{f[x][1]}]</script><p>​    (注: $f’[x][0]$ 是点 $x$ 只处理轻儿子和自己信息时的值)</p><p>​    那么如何修改?</p><p>​    同一条重链上点的修改对于这条链上的点是没有影响的,因为重链每个点只保存其轻儿子的信息,有影响的是对于这条链 $top$ 的父亲节点,那么我们的思路就出来了,修改点时,修改链 $top$ 父亲的矩阵信息即可;</p><p>​    总结一下思路: 首先将DP式子化为通项矩阵乘的形式,先处理出每个节点轻儿子的信息,在树上用树链剖分维护链上矩阵乘信息,修改时,每次修改链首父亲的矩阵值,修改至树根重链.修改细节即修改点信息,之后从链尾到链首矩阵乘,与之前的值作差修改.最后求答案时直接处理链上信息即可;</p><h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(p) p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(p) p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],son[maxn],top[maxn],bot[maxn],fl[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn],id[maxn],cent,tot,a[maxn],sz[maxn],f[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">ll g[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> matrix x) <span class="keyword">const</span>&#123;</span><br><span class="line">matrix ans;</span><br><span class="line">ans.g[<span class="number">0</span>][<span class="number">0</span>]=max(g[<span class="number">0</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">0</span>],g[<span class="number">0</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">ans.g[<span class="number">0</span>][<span class="number">1</span>]=max(g[<span class="number">0</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">1</span>],g[<span class="number">0</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">ans.g[<span class="number">1</span>][<span class="number">0</span>]=max(g[<span class="number">1</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">0</span>],g[<span class="number">1</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">ans.g[<span class="number">1</span>][<span class="number">1</span>]=max(g[<span class="number">1</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">1</span>],g[<span class="number">1</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="comment">//矩阵乘 </span></span><br><span class="line">&#125;tr[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">matrix ori[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树链剖分预处理 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">sz[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">fa[y]=x,dfs1(y);</span><br><span class="line">sz[x]+=sz[y];</span><br><span class="line"><span class="keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">id[x]=++tot,fl[tot]=x;top[x]=tp;</span><br><span class="line"><span class="keyword">if</span>(son[x]) dfs2(son[x],tp),bot[x]=bot[son[x]];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> bot[x]=x,<span class="keyword">void</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y,y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树上DP </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>]=<span class="number">0</span>;f[x][<span class="number">1</span>]=a[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs3(y);</span><br><span class="line">f[x][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">f[x][<span class="number">1</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tr[p]=tr[le(p)]*tr[re(p)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树时每个点只保存自己和轻儿子的信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tr[p].g[<span class="number">0</span>][<span class="number">0</span>]=tr[p].g[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;tr[p].g[<span class="number">1</span>][<span class="number">1</span>]=-inf;</span><br><span class="line">tr[p].g[<span class="number">1</span>][<span class="number">0</span>]=a[fl[l]];<span class="keyword">int</span> x=fl[l];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">tr[p].g[<span class="number">0</span>][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">tr[p].g[<span class="number">1</span>][<span class="number">0</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">tr[p].g[<span class="number">0</span>][<span class="number">1</span>]=tr[p].g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">ori[fl[l]]=tr[p];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(l,mid,le(p));build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[p]=ori[fl[l]],<span class="keyword">void</span>();</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) add(x,l,mid,le(p));</span><br><span class="line"><span class="keyword">else</span> add(x,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tr[p];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid&amp;&amp;mid&lt;nr) <span class="keyword">return</span> query(nl,nr,l,mid,le(p))*query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nl&lt;=mid) <span class="keyword">return</span> query(nl,nr,l,mid,le(p));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> query(id[top[x]],id[bot[x]],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">ori[x].g[<span class="number">1</span>][<span class="number">0</span>]+=k-a[x];a[x]=k;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">matrix old,news;</span><br><span class="line">old=query(top[x]);<span class="comment">//没修改的</span></span><br><span class="line">add(id[x],<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//change </span></span><br><span class="line">news=query(top[x]);<span class="comment">//修改过的 </span></span><br><span class="line">x=fa[top[x]];<span class="keyword">if</span>(!x) <span class="keyword">break</span>;</span><br><span class="line">ori[x].g[<span class="number">0</span>][<span class="number">0</span>]+=max(news.g[<span class="number">0</span>][<span class="number">0</span>],news.g[<span class="number">1</span>][<span class="number">0</span>])-max(old.g[<span class="number">0</span>][<span class="number">0</span>],old.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">ori[x].g[<span class="number">0</span>][<span class="number">1</span>]=ori[x].g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">ori[x].g[<span class="number">1</span>][<span class="number">0</span>]+=news.g[<span class="number">0</span>][<span class="number">0</span>]-old.g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> query(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scan(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">scan(u),scan(v),add(u,v);</span><br><span class="line">dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>),dfs3(<span class="number">1</span>);build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> x,k;</span><br><span class="line">scan(x,k);</span><br><span class="line">matrix ans=solve(x,k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(ans.g[<span class="number">0</span>][<span class="number">0</span>],ans.g[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>​    [NOIP2018]保卫王国;</p><p>​    有两个点,强制选点或强制不选,求最小覆盖集;</p><p>​    最小覆盖集=全集-最大权独立集;</p><p>​    强制选点或不选可以通过将其改为 $-inf$ 和 $inf$ ,之后就是D-DP模板了;</p><h5 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fa[maxn],id[maxn],fl[maxn],sz[maxn],head[maxn];</span><br><span class="line"><span class="keyword">int</span> son[maxn],top[maxn],cent,tot,bot[maxn];</span><br><span class="line">ll f[maxn][<span class="number">2</span>],a[maxn],sum,ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;to[maxn];</span><br><span class="line"><span class="keyword">char</span> type[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">ll g[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> matrix x) <span class="keyword">const</span>&#123;</span><br><span class="line">matrix ans;</span><br><span class="line">ans.g[<span class="number">0</span>][<span class="number">0</span>]=max(g[<span class="number">0</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">0</span>],g[<span class="number">0</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">ans.g[<span class="number">0</span>][<span class="number">1</span>]=max(g[<span class="number">0</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">1</span>],g[<span class="number">0</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">ans.g[<span class="number">1</span>][<span class="number">0</span>]=max(g[<span class="number">1</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">0</span>],g[<span class="number">1</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">ans.g[<span class="number">1</span>][<span class="number">1</span>]=max(g[<span class="number">1</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">1</span>],g[<span class="number">1</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tr[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line">matrix ori[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">to[u].push_back(v),to[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">sz[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">fa[y]=x;dfs1(y);</span><br><span class="line">sz[x]+=sz[y];</span><br><span class="line"><span class="keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">id[x]=++tot,fl[tot]=x,top[x]=tp;</span><br><span class="line"><span class="keyword">if</span>(son[x]) dfs2(son[x],tp),bot[x]=bot[son[x]];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> bot[x]=x,<span class="keyword">void</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y,y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">f[x][<span class="number">1</span>]=a[x],f[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs3(y);</span><br><span class="line">f[x][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">f[x][<span class="number">1</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tr[p]=tr[le(p)]*tr[re(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tr[p].g[<span class="number">0</span>][<span class="number">0</span>]=tr[p].g[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;<span class="keyword">int</span> x=fl[l];</span><br><span class="line">tr[p].g[<span class="number">1</span>][<span class="number">0</span>]=a[fl[l]];tr[p].g[<span class="number">1</span>][<span class="number">1</span>]=-inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">tr[p].g[<span class="number">0</span>][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">tr[p].g[<span class="number">1</span>][<span class="number">0</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">tr[p].g[<span class="number">0</span>][<span class="number">1</span>]=tr[p].g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">ori[fl[l]]=tr[p];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(l,mid,le(p)),build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[p]=ori[fl[l]],<span class="keyword">void</span>();</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) add(x,l,mid,le(p));</span><br><span class="line"><span class="keyword">else</span> add(x,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tr[p];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid&amp;&amp;mid&lt;nr) <span class="keyword">return</span> query(nl,nr,l,mid,le(p))*query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nl&lt;=mid) <span class="keyword">return</span> query(nl,nr,l,mid,le(p));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> query(id[top[x]],id[bot[x]],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,ll k)</span></span>&#123;</span><br><span class="line">ori[x].g[<span class="number">1</span>][<span class="number">0</span>]+=k-a[x];a[x]=k;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">matrix old,news;</span><br><span class="line">old=query(top[x]);add(id[x],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">news=query(top[x]);</span><br><span class="line">x=fa[top[x]];<span class="keyword">if</span>(!x) <span class="keyword">break</span>;</span><br><span class="line">ori[x].g[<span class="number">0</span>][<span class="number">0</span>]+=max(news.g[<span class="number">0</span>][<span class="number">0</span>],news.g[<span class="number">1</span>][<span class="number">0</span>])-max(old.g[<span class="number">0</span>][<span class="number">0</span>],old.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">ori[x].g[<span class="number">0</span>][<span class="number">1</span>]=ori[x].g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">ori[x].g[<span class="number">1</span>][<span class="number">0</span>]+=news.g[<span class="number">0</span>][<span class="number">0</span>]-old.g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scan(n,m);<span class="built_in">cin</span>&gt;&gt;type;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]),sum+=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">scan(u),scan(v),add(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sort(to[i].begin(),to[i].end());</span><br><span class="line">dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>),dfs3(<span class="number">1</span>),build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> f1,f2,g1,g2,t1,t2;</span><br><span class="line">scan(f1,f2,g1,g2);</span><br><span class="line"><span class="keyword">if</span>(f2==g2&amp;&amp;!f2)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pos=lower_bound(to[f1].begin(),to[f1].end(),g1);</span><br><span class="line"><span class="keyword">if</span>(pos!=to[f1].end()&amp;&amp;(*pos)==g1)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">t1=a[f1],t2=a[g1];</span><br><span class="line">modify(f1,f2?-inf:inf);</span><br><span class="line">modify(g1,g2?-inf:inf);</span><br><span class="line">matrix ol=query(<span class="number">1</span>);</span><br><span class="line">ans=max(ol.g[<span class="number">0</span>][<span class="number">0</span>],ol.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(!f2) ans=ans-inf+t1;</span><br><span class="line"><span class="keyword">if</span>(!g2) ans=ans-inf+t2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum-ans);</span><br><span class="line">modify(f1,t1),modify(g1,t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当然还有倍增做法,但这里不再讲述,D-DP中一个重要思想就是讲DP式子变成矩阵乘的形式,用数据结构进行维护,其高效并支持拓展;</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;必备知识&quot;&gt;&lt;a href=&quot;#必备知识&quot; class=&quot;headerlink&quot; title=&quot;必备知识&quot;&gt;&lt;/a&gt;必备知识&lt;/h4&gt;&lt;p&gt;​    树链剖分,最大权独立集(即没有上司的舞会(树上DP)),矩阵乘法;&lt;/p&gt;&lt;h2 id=&quot;D-DP&quot;&gt;&lt;a href=&quot;#D-DP&quot; class=&quot;headerlink&quot; title=&quot;D-DP&quot;&gt;&lt;/a&gt;D-DP&lt;/h2&gt;&lt;h3 id=&quot;模版简述&quot;&gt;&lt;a href=&quot;#模版简述&quot; class=&quot;headerlink&quot; title=&quot;模版简述&quot;&gt;&lt;/a&gt;模版简述&lt;/h3&gt;&lt;p&gt;​    &lt;a href=&quot;https://www.luogu.org/problem/P4719&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模板&lt;/a&gt; &lt;/p&gt;&lt;p&gt;​    关于动态DP,其实是关于一类动态修改点权的问题,但是很难去处理;&lt;/p&gt;&lt;p&gt;​    我们平常的DP经常是离线DP,而当在线时,就会出现事故;&lt;/p&gt;&lt;p&gt;​    D-DP是关于求最大权独立集的,支持动态修改点值,其思想即DP的通项递推式改为矩阵乘的形式进行递推,而树上问题就可以使用树链剖分提前处理出区间矩阵乘;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DP" scheme="http://leceue.github.io./tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>折半搜索</title>
    <link href="http://leceue.github.io./2019/11/08/meet-in-the-middle/"/>
    <id>http://leceue.github.io./2019/11/08/meet-in-the-middle/</id>
    <published>2019-11-08T11:22:56.000Z</published>
    <updated>2019-11-12T07:47:07.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="折半搜索-meet-in-the-middle"><a href="#折半搜索-meet-in-the-middle" class="headerlink" title="折半搜索(meet in the middle)"></a>折半搜索(meet in the middle)</h2><p>​    我们经常会遇见一些暴力枚举的题目,但是由于时间复杂度太过庞大不得不放弃.</p><p>​    由于子树分支是指数性增长,所以我们考虑将其折半优化;</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    这个知识点曾经在模拟赛中出现过,所以这里稍微提一下;</p><p>​    讲的很浅显,但是不要D讲者;</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​    dfs搜索树是指数性增长,如果将指数减少一半,就将会有量的飞跃,所以在遇见暴力枚举太大时,我们可以考虑这种算法;</p><a id="more"></a><p>​    总体思想即,dfs搜素通常从一个点出发,遍历所有深度,那么我们考虑将深度减半,从两个点出发,然后分别统计两边dfs时的信息,整合即可;</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>​    该算法能否使用的关键是整合,两个深度是否能整合在一起需要思考;</p><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>​    我们通过一道例题来讲解;</p><blockquote><p>​    有一个体积为 $m$ $(m&lt;=1e18)$ 的背包,有 $n$ $(n&lt;=40)$ 个物品,问装背包有多少种方案.</p></blockquote><p>​    若 $m$ 较小时,该题即一个裸的背包,但本题 $m&lt;=1e18$ 背包就会不可做 (我不会) ;</p><p>​    那么考虑最基础的方法,暴力枚举每一种情况,然后统计即可.</p><p>​    直接枚举会导致超时,我们可以考虑双向搜索,将物品截半,将第一次搜索时的情况存下来,排序,第二次搜索时,找到一个结果,二分查找第一次的情况,计数即可;</p><p>​    </p><blockquote><p>给 $n$ $(n&lt;=20)$ 个数，从中任意选出一些数，使这些数能分成和相等的两组。</p><p>求方案数.</p></blockquote><p>​    我们同样考虑两遍dfs,分别整理出两次搜索的结果,但是整合时有些麻烦;</p><p>​    整合时,我们可以暴力计数,考虑到这些数的随机性,所以期望得分 $100$ ,但是如果出题人精心手造数据,就会有些凉凉;</p><p>​    考虑每种情况只会有 $1$ 的贡献,那么我们将 $2^{20}$ 种情况分别跑出来,用两次dfs储存的结果判断是否可行即可;</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    我们面对一些其他算法很难处理的问题,要留住我们的本心 <del>(根)</del> ,优化暴力搜索,也许也会得到一个不错的复杂度.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;折半搜索-meet-in-the-middle&quot;&gt;&lt;a href=&quot;#折半搜索-meet-in-the-middle&quot; class=&quot;headerlink&quot; title=&quot;折半搜索(meet in the middle)&quot;&gt;&lt;/a&gt;折半搜索(meet in the middle)&lt;/h2&gt;&lt;p&gt;​    我们经常会遇见一些暴力枚举的题目,但是由于时间复杂度太过庞大不得不放弃.&lt;/p&gt;&lt;p&gt;​    由于子树分支是指数性增长,所以我们考虑将其折半优化;&lt;/p&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;​    这个知识点曾经在模拟赛中出现过,所以这里稍微提一下;&lt;/p&gt;&lt;p&gt;​    讲的很浅显,但是不要D讲者;&lt;/p&gt;&lt;h3 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h3&gt;&lt;p&gt;​    dfs搜索树是指数性增长,如果将指数减少一半,就将会有量的飞跃,所以在遇见暴力枚举太大时,我们可以考虑这种算法;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="搜索" scheme="http://leceue.github.io./tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于爆搜</title>
    <link href="http://leceue.github.io./2019/11/08/DFS-BFS/"/>
    <id>http://leceue.github.io./2019/11/08/DFS-BFS/</id>
    <published>2019-11-08T11:21:56.000Z</published>
    <updated>2019-11-08T11:22:19.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于爆搜"><a href="#关于爆搜" class="headerlink" title="关于爆搜"></a>关于爆搜</h2><p>​    <del>(这还用说,讲者太菜了)</del> </p><p>​    爆搜通常是没有思路时一个 <del>优秀</del> 玄学的解题方法,但同样是搜索,我们所的分数却相差甚远,即搜索的优化问题;</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    这是很基础的东西,这里只作为回顾.</p><p>​    讲着实力不足,请不要D讲者;</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>​    BFS,广度优先搜索,用于逐层拓展的工具,可以有效地通过比较同一层之间的结果进行有效地减枝,而相比之下DFS的减枝就比较玄学,故能用BFS时,BFS的时间复杂度一般比DFS要低很多;</p><a id="more"></a><p>​    BFS也是SPFA的实现基础 <del>虽然SPFA已经死了</del> .</p><p>​    BFS有双重BFS,常用于两个物品有关联地移动.</p><p>​    BFS还包括双向BFS,通常用于两个物品移动的相遇问题.</p><p>​    <del>例题就不再找了,自行搜索吧</del>;</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>​    DFS,深度优先搜索,用于寻找单个情况,有着很玄学的时间复杂度.</p><p>​    DFS常用于图的遍历和搜索情况,但是在搜索每种情况时,DFS的搜索树会成指数型增长,即爆炸性增长,那么减枝是极其重要的;</p><p>​    此时解决这种情况的一种方法是迭代加深,限制深度,多次搜索.虽然看起来极其浪费,但是当答案所在层很浅时,这种算法的时间复杂度比起DFS的搜索树的爆炸性增长,极度优秀;</p><p>​    当然迭代加深是有许多限制,我们常用的还是减枝,常用的减枝有贪心减枝,<del>显然错误</del>减枝,以及一些玄学优化;</p><p>​    更加高级的还有IDA*优化,最优解减枝;</p><p>​    </p><p>​    为了增加一些体验感受<del>(讲不动了)</del>,我们加入一些水题;</p><p>​    [NOIP2004]虫食算</p><blockquote><p>给你 $n$ 个字母构成的的 $3$ 行 $n$ 列的 $n$ 进制加法式子,请求出各个字母的一个解.</p></blockquote><p>​    这是我在搜索入门时写的题目,然后…..<del>炸了</del>.于是我就放弃了,现在再来看这道题,其实还好<del>(还是那么毒瘤)</del></p><p>​    正解是什么逆矩阵,我不会啊QWQ(交给数论组吧OAO)</p><p>​    那么考虑爆搜,我们暴力枚举每个字母的值,然后求出第 $3$ 行的值,检验即可;</p><p>​    但是复杂度会爆炸,怎么办?</p><p>​    优化1: 暴力检验第三行<del>(废话)</del></p><p>​    优化2:将矩阵扫一遍,检查是否合法;</p><p>​    优化3:检验第 $1$ 列,查看是否符合性质;</p><p>​    这样应该就可以过了;</p><p>​    </p><p>​    除了以上这些优化,DFS优化方式还有更加玄学的随机搜索,期望得分较高,实际得分玄学;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于爆搜&quot;&gt;&lt;a href=&quot;#关于爆搜&quot; class=&quot;headerlink&quot; title=&quot;关于爆搜&quot;&gt;&lt;/a&gt;关于爆搜&lt;/h2&gt;&lt;p&gt;​    &lt;del&gt;(这还用说,讲者太菜了)&lt;/del&gt; &lt;/p&gt;&lt;p&gt;​    爆搜通常是没有思路时一个 &lt;del&gt;优秀&lt;/del&gt; 玄学的解题方法,但同样是搜索,我们所的分数却相差甚远,即搜索的优化问题;&lt;/p&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;​    这是很基础的东西,这里只作为回顾.&lt;/p&gt;&lt;p&gt;​    讲着实力不足,请不要D讲者;&lt;/p&gt;&lt;h3 id=&quot;BFS&quot;&gt;&lt;a href=&quot;#BFS&quot; class=&quot;headerlink&quot; title=&quot;BFS&quot;&gt;&lt;/a&gt;BFS&lt;/h3&gt;&lt;p&gt;​    BFS,广度优先搜索,用于逐层拓展的工具,可以有效地通过比较同一层之间的结果进行有效地减枝,而相比之下DFS的减枝就比较玄学,故能用BFS时,BFS的时间复杂度一般比DFS要低很多;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="搜索" scheme="http://leceue.github.io./tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>记忆化搜索</title>
    <link href="http://leceue.github.io./2019/11/08/mem-dfs/"/>
    <id>http://leceue.github.io./2019/11/08/mem-dfs/</id>
    <published>2019-11-08T11:20:54.000Z</published>
    <updated>2019-11-12T07:46:12.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>​    记忆化搜索,属于DP的分支,但是其实现更加简单,依靠于DFS,所以在一些方面更具优越性;</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    记忆化可以作为DP难以实现时一个简易的方法<del>(我知道你们都秒切DP,就我一个蒟蒻不会QWQ)</del>.</p><p>​    讲的很浅显,但是不要D讲者;</p><h3 id="浅谈"><a href="#浅谈" class="headerlink" title="浅谈"></a>浅谈</h3><p>​    记忆化搜素,顾名思义,是通过储存一个状态的最优信息,减少DFS的搜索树;</p><a id="more"></a><p>​    记忆化搜索的几个条件,状态可以储存,而且没有层次的限制(若是一层一层了话,BFS?)</p><p>​    它具有几个DP所不具有的优点:</p><p>​        1.状态更少;</p><p>​        2.可以减枝;</p><p>​        3.实现更加简单;</p><p>​    但是似乎在状压DP中用的是最多的;</p><p>​    [NOIP2016]愤怒的小鸟</p><blockquote><p>就是让你定几个抛物线(过原点),去砸小猪,看最少用几个小鸟;</p></blockquote><p>​    思路显然,我们知道两点定一个抛物线,那么考虑直接枚举小猪,定抛物线,二进制记录已经打过的小猪即可,时间复杂度 $O(n^2 log n)$ ;</p><p>​    当然我们还可以优化,枚举两个小猪优化到定一个小猪枚举另一个小猪,时间复杂度 $O(n logn)$ ;</p><p>​    [NOIP2017]逛公园</p><p>​    思路即,先跑个最短路,然后跑个最短路DP即可;</p><p>​    但是这里要判 0 环,有两种方法,拓扑和DFS,拓扑就很显然了,但是有许多人写炸;</p><p>​    DFS判环我们曾经在SPFA判负环中见过,做法高效;</p><p>​    那么我们可以采用DFS记忆化搜索,储存两维状态 $f[x][k]$ ,第一维表示在哪个点,第二维表示与最短路的差值;</p><p>​    如果我们跑了正向最短路,那么我们就可以反向建边,跑DFS,用 $dis[y]-dis[x]+edge[i].w$ 求出差值,储存状态即可,而0环的判断,只要记录每个点是否访问过,如果在一次访问过之后再次访问,即得到0环;</p><h4 id="话外题"><a href="#话外题" class="headerlink" title="话外题"></a>话外题</h4><p>​    状态压缩是我们常用储存状态的方式,而DFS与状压的结合更加完美,其减枝之后甚至比正解状压DP更快一步.</p><p>​    [NOIP2017]宝藏</p><blockquote><p>有 $n$ 个点和 $m$ 条道路,我们可以选择一个点出发,开拓道路的代价是 $L*K$ (L代表这条道路的长度，K代表从起点到这条道路起点所经过的点的数量)</p></blockquote><p>​    <del>我们既然是搜索专题,怎么能想正解DP呢</del> ;</p><p>​    我们可以暴力枚举起点,然后搜索道路,时间复杂度 $O( 玄学 )=O( 超时 )$ ;</p><p>​    考虑优化;</p><p>​        1.我们可以在记录状态时用二进制维护</p><p>​        2.贪心地从较小边搜索,这样可以较快的解出较优解去减枝;</p><p>​        3.每次将一个点的边枚举完之后再去枚举下一个点;</p><p>​        4.在同一点,记录枚举到哪条边,避免重复枚举;</p><p>​        5.进行最优解减枝,类似于IDA*的做法,我们记录一个当前点之后的价值,加上当前价值,进行减枝,最直接的做法是直接记录所有没有探寻的点的最小出边,然后乘上当前点的K即可;</p><p>​    </p><p>​    这种减枝速度极快,甚至比正解还快上几分…</p><h5 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h5><p>​    有的时候,正解很难得到,我们可以选择搜索,进行合理化减枝(注意,不要减枝错误),<del>也许你就AK了</del>;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;记忆化搜索&quot;&gt;&lt;a href=&quot;#记忆化搜索&quot; class=&quot;headerlink&quot; title=&quot;记忆化搜索&quot;&gt;&lt;/a&gt;记忆化搜索&lt;/h2&gt;&lt;p&gt;​    记忆化搜索,属于DP的分支,但是其实现更加简单,依靠于DFS,所以在一些方面更具优越性;&lt;/p&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;​    记忆化可以作为DP难以实现时一个简易的方法&lt;del&gt;(我知道你们都秒切DP,就我一个蒟蒻不会QWQ)&lt;/del&gt;.&lt;/p&gt;&lt;p&gt;​    讲的很浅显,但是不要D讲者;&lt;/p&gt;&lt;h3 id=&quot;浅谈&quot;&gt;&lt;a href=&quot;#浅谈&quot; class=&quot;headerlink&quot; title=&quot;浅谈&quot;&gt;&lt;/a&gt;浅谈&lt;/h3&gt;&lt;p&gt;​    记忆化搜素,顾名思义,是通过储存一个状态的最优信息,减少DFS的搜索树;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="搜索" scheme="http://leceue.github.io./tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>trie浅谈</title>
    <link href="http://leceue.github.io./2019/10/30/trie/"/>
    <id>http://leceue.github.io./2019/10/30/trie/</id>
    <published>2019-10-30T11:27:04.000Z</published>
    <updated>2019-10-30T23:35:48.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于trie"><a href="#关于trie" class="headerlink" title="关于trie"></a>关于trie</h2><p>​    其实字典树和以上两种算法有很大不同,但是hash由于其优秀的应用,导致有些字符串查找用hash也是可行的.</p><p>​    字典树中支持添加,查找,区间查询(可持久化字典树),而且在异或操作上有更加好的操作;</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    树的基本构造;</p><h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    字典树是通过动态建点,而形成的树,基本数组有两维, $tr[x][to]$ 中第一维存的是节点标号,而第二维存的是当字符为 $to$ 时通向的节点;</p><a id="more"></a><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>​    我当时入门是学的是<a href="https://www.luogu.org/problem/P2580" target="_blank" rel="noopener">这道题</a>;</p><blockquote><p>给你一些初始字符串,询问,给你一个字符串,这个字符串在这个初始字符串中是否存在</p></blockquote><p>​    当时使用hash写的,但是没过;</p><p>​    现在我们可以用字典树先存一下初始字符串,然后在树上匹配,单次时间复杂度 $O(n)$ ;</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,trie[<span class="number">300007</span>][<span class="number">27</span>],num[<span class="number">300007</span>],sz;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">300007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[now][a[i]-<span class="string">'a'</span>]) trie[now][a[i]-<span class="string">'a'</span>]=++sz;</span><br><span class="line">now=trie[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line">num[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exam</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!trie[now][a[i]-<span class="string">'a'</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">now=trie[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!num[now]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(vis[now]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">vis[now]=<span class="number">1</span>; <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">60</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">build(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">60</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line"><span class="keyword">int</span> x=exam(a);</span><br><span class="line"><span class="keyword">switch</span>(x)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WRONG\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"REPEAT\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="另"><a href="#另" class="headerlink" title="另"></a>另</h4><p>​    我在hash中介绍了map,这里其实也可以用map存字符串,但是其时间复杂度比原来的多了一个 $logn$ ,写法虽然简单但是时间并不优秀;</p><h5 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">p[s]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(p[s]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"OK"</span>),p[s]=<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[s]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"WRONG"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[s]==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"REPEAT"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>​    异或,是我们经常会见到的,但是如何高效的处理异或信息是一个让人头痛的事,而字典树为我们提供了策略.    </p><h3 id="0-1串树"><a href="#0-1串树" class="headerlink" title="0/1串树"></a>0/1串树</h3><p>​    $0/1$ 串树,常用来储存一个2进制数字,我们知道异或正是与二进制有关,那么我们是否可以找在字典树上操作序列呢?</p><p>​    显然是可以的,我们在一个节点,分别走0通向的节点和1通向的节点,那么贪心地操作,这样一定是异或对最大值,反之,都走0或者1可以有效地得到最小值,</p><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>​    <a href="https://www.luogu.org/problem/P4551" target="_blank" rel="noopener">最长异或路径</a> ,这个例题应该比较合适;</p><blockquote><p>给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $N$ 。寻找树中找两个结点，求最长的异或路径。</p><p>异或路径指的是指两个结点之间唯一路径上的所有边权的异或。</p></blockquote><p>​    显然,我们可以将每个点到根root的异或和保存一下,然后将其加入字典树,现在我们要求的就是最大的异或数对,跟上面说的一样,我们只要从字典树顶端开始BFS,就可以得到最大异或数对.</p><h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y,z,w) (nd)&#123;x,y,z,w&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[maxn],dis[maxn],tr[maxn*<span class="number">32</span>][<span class="number">2</span>],ed[maxn*<span class="number">32</span>],val[maxn*<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> tot,cent,ans[<span class="number">34</span>],ol;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val,dep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">edge[++cent]=(node)&#123;head[v],u,w&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">dis[y]=dis[x]^edge[i].w;</span><br><span class="line">dfs(y,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//求异或和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">int</span> pos=!!(x&amp;(<span class="number">1</span>&lt;&lt;i));</span><br><span class="line"><span class="keyword">if</span>(!tr[now][pos]) tr[now][pos]=++tot;</span><br><span class="line">now=tr[now][pos];</span><br><span class="line">&#125;</span><br><span class="line">ed[tot]=id,val[tot]=x;</span><br><span class="line">&#125;<span class="comment">//树中保存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;nd&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">q.push(mp(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x=q.front().x,y=q.front().y,d=q.front().dep;</span><br><span class="line"><span class="keyword">int</span> val=q.front().val;q.pop();</span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">30</span>) <span class="keyword">return</span> ans[d];<span class="comment">//到底层了,此时一定是最优解</span></span><br><span class="line"><span class="keyword">if</span>(ans[d]&gt;val) <span class="keyword">continue</span>;<span class="comment">//减支</span></span><br><span class="line"><span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">1</span>])&#123;</span><br><span class="line">q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(x!=y) q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">0</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tr[x][<span class="number">0</span>]||!tr[y][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">0</span>])&#123;</span><br><span class="line">q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">0</span>],val&lt;&lt;<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">1</span>])&#123;</span><br><span class="line">q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//分类讨论</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scan(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=n<span class="number">-1</span>;i++) scan(u,v,w),add(u,v,w);</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) insert(dis[i],i),ol=max(ol,dis[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(ol,bfs()));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>​    <a href="https://www.luogu.org/problem/CF888G" target="_blank" rel="noopener">CF888G Xor-MST</a> </p><blockquote><p>已知一个 $n$ 个节点的无向完全图,每个节点的编号为 $a_i$ , $i$ 与 $j$ 的边的权值是 $a_i$ ^ $a_j$ ,求该图的 $MST$ 的权值;</p></blockquote><p>​    我们可以想一下 $kruskal$ 算法的过程,那么我们也可以每次寻找最小值,可以通过在trie上BFS得到;</p><p>​    值得注意的是,所有分叉点的个数为建边个数(去掉两点权值相同),那么其实直接寻找即可;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y,z,w) (node)&#123;x,y,z,w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],tr[maxn*<span class="number">33</span>][<span class="number">2</span>],ed[maxn*<span class="number">33</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];<span class="keyword">bool</span> vis[maxn*<span class="number">33</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dep[<span class="number">34</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,d,ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--,d++)&#123;</span><br><span class="line"><span class="keyword">int</span> pos=(!(x&amp;(<span class="number">1</span>&lt;&lt;i)));</span><br><span class="line"><span class="keyword">if</span>(!tr[now][pos]) tr[now][pos]=++tot;</span><br><span class="line"><span class="keyword">if</span>(tr[now][pos^<span class="number">1</span>]&amp;&amp;!vis[now]) vis[now]=<span class="number">1</span>,dep[d].push_back(now);</span><br><span class="line">now=tr[now][pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ed[now]) fa[ed[now]]=id;</span><br><span class="line">ed[now]=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> d,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f1=tr[now][<span class="number">0</span>],f2=tr[now][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">127</span>,<span class="keyword">sizeof</span> ans);ans[d]=<span class="number">1</span>;</span><br><span class="line">q.push((node)&#123;f1,f2,d,<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">x=q.front().x,y=q.front().y;</span><br><span class="line"><span class="keyword">int</span> dx=q.front().d,ans1=q.front().ans;q.pop();</span><br><span class="line"><span class="keyword">if</span>(ed[x]&amp;&amp;ed[y])&#123;</span><br><span class="line">x=ed[x],y=ed[y];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans1&gt;ans[dx])  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">0</span>]) q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">0</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">1</span>]) q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">1</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!tr[x][<span class="number">0</span>]||!tr[y][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">0</span>])</span><br><span class="line">q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">0</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(tr[y][<span class="number">1</span>]&amp;&amp;tr[x][<span class="number">0</span>])</span><br><span class="line">q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">1</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans[<span class="number">30</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=get(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("tree.in","r",stdin);</span></span><br><span class="line"><span class="comment">// freopen("tree.out","w",stdout);</span></span><br><span class="line">scan(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">scan(a[i]);add(a[i],i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(!dep[i].size()) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dep[i].size();j++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,f;</span><br><span class="line">f=find(dep[i][j],i,x,y);</span><br><span class="line"><span class="keyword">if</span>(get(x)==get(y)) <span class="keyword">continue</span>;</span><br><span class="line">fa[get(x)]=get(y);ans+=<span class="number">1l</span>l*f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 2 3 4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="可持久化串树"><a href="#可持久化串树" class="headerlink" title="可持久化串树"></a>可持久化串树</h3><p>​    可持久化串树,即可在区间中查询的串树,与可持久数组有些类似,只是前者用trie,后者用主席树罢了.</p><p>​    建树时,我们可以再建一个节点,然后继承上一个节点的信息,然后再建一个新节点去保存自己的信息.</p><p>​    区间查询时,我们进入右端点的trie节点,为了限制左边界,我们可以在建图时将其序号标上,在搜索到小于左端点编号时跳过,去寻找另一个节点即可.</p><h4 id="建树-0-1trie"><a href="#建树-0-1trie" class="headerlink" title="建树(0/1trie)"></a>建树(0/1trie)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> last,<span class="keyword">int</span> &amp;f,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now;now=f=++tot;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];<span class="comment">//继承</span></span><br><span class="line">last=trie[last][ol];</span><br><span class="line">trie[now][ol]=++tot;<span class="comment">//开拓新节点</span></span><br><span class="line">mark[tot]=pos;<span class="comment">//记录序号</span></span><br><span class="line">now=trie[now][ol];<span class="comment">//向下拓展</span></span><br><span class="line">&#125;</span><br><span class="line">ending[now]=x;<span class="comment">//结尾数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询-0-1trie"><a href="#查询-0-1trie" class="headerlink" title="查询(0/1trie)"></a>查询(0/1trie)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line"><span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ending[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里的查询是在一段区间中查询异或k的最大值;</p><h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><p>​    <a href="https://www.luogu.org/problem/P4735" target="_blank" rel="noopener">最大异或和</a>,模版题;</p><p>​    我们就按照上面的步骤即可;</p><h5 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1200007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,trie[maxn*<span class="number">10</span>][<span class="number">2</span>],a[maxn],sum[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> ending[maxn*<span class="number">10</span>],mark[maxn*<span class="number">10</span>],lim,id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> last,<span class="keyword">int</span> &amp;f,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now;now=f=++tot;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];</span><br><span class="line">last=trie[last][ol];</span><br><span class="line">trie[now][ol]=++tot;</span><br><span class="line">mark[tot]=pos;</span><br><span class="line">now=trie[now][ol];</span><br><span class="line">&#125;</span><br><span class="line">ending[now]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line"><span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ending[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// freopen("cin.in","r",stdin);</span></span><br><span class="line">scan(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">scan(a[i]),sum[i]=sum[i<span class="number">-1</span>]^a[i];</span><br><span class="line">lim=max(sum[i],lim);</span><br><span class="line">&#125;</span><br><span class="line">lim=(<span class="keyword">int</span>)log2(<span class="number">1e7</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">build(sum[i],id[i<span class="number">-1</span>],id[i],i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r,x;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s!=<span class="string">'A'</span>&amp;&amp;s!=<span class="string">'Q'</span>) s=getchar();</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">'A'</span>) scan(x),n++,sum[n]=sum[n<span class="number">-1</span>]^x,build(sum[n],id[n<span class="number">-1</span>],id[n],n);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">'Q'</span>)&#123;</span><br><span class="line">scan(l,r,x); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(sum[n]^x)^dfs((sum[n]^x),id[r<span class="number">-1</span>],l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h4><p>​    <a href="https://www.luogu.org/problem/P5283" target="_blank" rel="noopener">异或粽子</a>,可持久化trie查询区间最大异或值;</p><p>​    这道题的思路可以从 <a href="https://www.luogu.org/problem/P2048" target="_blank" rel="noopener">超级钢琴</a> 中得到.</p><p>​    超级钢琴的思路是将权值处理出来,与区间信息一起保存在优先队列中,然后每次取出最大值,再更新左右区间即可;</p><p>​    而这道题与其不同的是,这里将权值处理出来的方式不同,这里运用可持久化trie,然后在区间查询最大异或值,其他的与超级钢琴几乎一致;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n,k,trie[maxn*<span class="number">23</span>][<span class="number">2</span>],mark[maxn*<span class="number">23</span>],val[maxn*<span class="number">23</span>];</span><br><span class="line">ll sum[maxn],ans,tot,lim=<span class="number">33</span>,a[maxn],id[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll val,l,r,pos,ori;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll x,ll last,ll &amp;f,ll pos)</span></span>&#123;</span><br><span class="line">ll now;now=f=++tot;</span><br><span class="line"><span class="keyword">for</span>(ll i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];</span><br><span class="line">last=trie[last][ol];</span><br><span class="line">trie[now][ol]=++tot;</span><br><span class="line">mark[tot]=pos;</span><br><span class="line">now=trie[now][ol];</span><br><span class="line">&#125;</span><br><span class="line">val[now]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x,ll f,ll op,ll &amp;pos)</span></span>&#123;</span><br><span class="line">ll now=f;</span><br><span class="line"><span class="keyword">for</span>(ll i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line"><span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos=mark[now],val[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("xor.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("xor.out","w",stdout);</span></span><br><span class="line">scan(n,k);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">scan(a[i]),sum[i]=sum[i<span class="number">-1</span>]^a[i];</span><br><span class="line">build(sum[i],id[i<span class="number">-1</span>],id[i],i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ll ol,pos;</span><br><span class="line">ol=query(sum[i<span class="number">-1</span>],id[n],i,pos);</span><br><span class="line">q.push((node)&#123;ol^sum[i<span class="number">-1</span>],i,n,pos,sum[i<span class="number">-1</span>]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(q.empty()) <span class="keyword">continue</span>;</span><br><span class="line">node x=q.top();ans+=x.val;q.pop();</span><br><span class="line">ll ol,pos;</span><br><span class="line"><span class="keyword">if</span>(x.l&lt;x.pos)&#123;</span><br><span class="line">ol=query(x.ori,id[x.pos<span class="number">-1</span>],x.l,pos);</span><br><span class="line">q.push((node)&#123;ol^x.ori,x.l,x.pos<span class="number">-1</span>,pos,x.ori&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x.pos&lt;x.r)&#123;</span><br><span class="line">ol=query(x.ori,id[x.r],x.pos+<span class="number">1</span>,pos);</span><br><span class="line">q.push((node)&#123;ol^x.ori,x.pos+<span class="number">1</span>,x.r,pos,x.ori&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    这里只是总结了一下trie的用法,我见到的主要还是0/1trie,以后见到还会再加入;</p><h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于trie&quot;&gt;&lt;a href=&quot;#关于trie&quot; class=&quot;headerlink&quot; title=&quot;关于trie&quot;&gt;&lt;/a&gt;关于trie&lt;/h2&gt;&lt;p&gt;​    其实字典树和以上两种算法有很大不同,但是hash由于其优秀的应用,导致有些字符串查找用hash也是可行的.&lt;/p&gt;&lt;p&gt;​    字典树中支持添加,查找,区间查询(可持久化字典树),而且在异或操作上有更加好的操作;&lt;/p&gt;&lt;h4 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h4&gt;&lt;p&gt;​    树的基本构造;&lt;/p&gt;&lt;h2 id=&quot;入坑&quot;&gt;&lt;a href=&quot;#入坑&quot; class=&quot;headerlink&quot; title=&quot;入坑&quot;&gt;&lt;/a&gt;入坑&lt;/h2&gt;&lt;p&gt;​    字典树是通过动态建点,而形成的树,基本数组有两维, $tr[x][to]$ 中第一维存的是节点标号,而第二维存的是当字符为 $to$ 时通向的节点;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="字符串" scheme="http://leceue.github.io./tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>hash应用</title>
    <link href="http://leceue.github.io./2019/10/30/hash/"/>
    <id>http://leceue.github.io./2019/10/30/hash/</id>
    <published>2019-10-30T11:26:25.000Z</published>
    <updated>2019-10-30T23:36:39.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于HASH"><a href="#关于HASH" class="headerlink" title="关于HASH"></a>关于HASH</h2><p>​    这应该是经常使用的一个算法,因为其预处理后,优秀的$O(1)$处理出子串,并且$O(1)$比较,大快人心,而且写法简单,令人心情愉悦;</p><p>​    但是其空间复杂度较高,并且有玄学模数以及哈希冲突,以至于如果想hack,其实可以hack掉;</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    关于进制,模数,hash就用到了重构进制,取模稀疏,所以哈希表又叫稀疏表;</p><a id="more"></a><h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    hash很好理解,而且匹配非常方便,<del>不容易写炸,对于萌新十分友好</del>,</p><h3 id="HASH查询"><a href="#HASH查询" class="headerlink" title="HASH查询"></a>HASH查询</h3><p>​    我们知道数字匹配复杂度为 $O(1)$ ,数字匹配速度快,而字符串却只能一个一个匹配, <del>这不公平</del> .那么我们考虑将字符串变成数字.</p><p>​    想一下数字有进制,那么我们定义一下字母的进制,不一定是26,我们可以随便取一个数,习惯性取质数;</p><p>​    但是数字太长,爆 $long$ $long$ 我们没办法存怎么办,我们考虑字符串很少,但是空间很大,我们考虑将数字安排入一个位置,其实这个位置是随机的,但是我们可以推出,这就够了;</p><p>​    那么我们可以模一个数字,将数字限制在一个范围之内,然后储存下来,而这个模数一般是一个质数,因为质数的特殊性质,可以造成更好地将数字稀疏;</p><h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll base=<span class="number">133</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">19491001</span>;</span><br><span class="line"><span class="function">ll <span class="title">id</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);ll ol=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">ol=(ol*base+s[i]-<span class="string">'a'</span>+<span class="number">1</span>)%mod;</span><br><span class="line"><span class="keyword">return</span> ol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    处理复杂度 $O(n)$ 然后开个数组储存即可;</p><h3 id="HASH子串匹配"><a href="#HASH子串匹配" class="headerlink" title="HASH子串匹配"></a>HASH子串匹配</h3><p>​    我们知道,如果每次都处理出一个串的子串,那么时间复杂度 $O(n^2)$ ,这是我们不能接受的,但是考虑一下我们存的是数字,数字有进制,那么一定可以通过加减操作得到其子串,那么,就简单很多了;</p><p>​    我们可以先预处理出 $HASH$ 前缀和,之后通过加减得到一段区间的子串;</p><p>​    但是直接开数组了话,有可能开不下,或者加大hash冲突的可能(即两个字符串hash值相同),那么我们可以考虑在不超时的情况下,加入一个map储存hash值,这样不需再担心空间问题,但是每次查询时间会多一个 $logn$ ,请谨慎使用;</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>​    我不再直接附上模版,而是引入一个 <a href="https://www.luogu.org/problem/P5546" target="_blank" rel="noopener">例题</a>;</p><blockquote><p>给出几个由小写字母构成的单词，求它们最长的公共子串的长度。</p></blockquote><h5 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h5><p>​    我们可以二分枚举公共子串长度,因为公共子串长度一定是满足单调性质的.</p><p>​    那么我们选择枚举第一个串的子串,然后将其他串中相同长度的子串储存起来,那么就可以匹配了;</p><h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ll base=<span class="number">133</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;ha[<span class="number">6</span>];</span><br><span class="line">ll sum[<span class="number">6</span>][maxn],ad[maxn];</span><br><span class="line"><span class="keyword">int</span> n,lim=maxn,len[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (sum[pos][r+<span class="number">1</span>]-sum[pos][l]*ad[r-l+<span class="number">1</span>]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ha[i].clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+l<span class="number">-1</span>&lt;len[i];j++)</span><br><span class="line">ha[i][id(i,j,l+j<span class="number">-1</span>)]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+l<span class="number">-1</span>&lt;len[<span class="number">1</span>];i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=id(<span class="number">1</span>,i,i+l<span class="number">-1</span>),cnt=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ha[j][temp]) cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!cnt) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">ad[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2001</span>;i++) ad[i]=ad[i<span class="number">-1</span>]*base%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len[i];j++)&#123;</span><br><span class="line">sum[i][j+<span class="number">1</span>]=(sum[i][j]*base+(c[i][j]-<span class="string">'a'</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scan(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,c[i]),lim=min(len[i]=<span class="built_in">strlen</span>(c[i]),lim);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=lim;init();</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于HASH&quot;&gt;&lt;a href=&quot;#关于HASH&quot; class=&quot;headerlink&quot; title=&quot;关于HASH&quot;&gt;&lt;/a&gt;关于HASH&lt;/h2&gt;&lt;p&gt;​    这应该是经常使用的一个算法,因为其预处理后,优秀的$O(1)$处理出子串,并且$O(1)$比较,大快人心,而且写法简单,令人心情愉悦;&lt;/p&gt;&lt;p&gt;​    但是其空间复杂度较高,并且有玄学模数以及哈希冲突,以至于如果想hack,其实可以hack掉;&lt;/p&gt;&lt;h4 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h4&gt;&lt;p&gt;​    关于进制,模数,hash就用到了重构进制,取模稀疏,所以哈希表又叫稀疏表;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="字符串" scheme="http://leceue.github.io./tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>KMP浅谈</title>
    <link href="http://leceue.github.io./2019/10/30/KMP/"/>
    <id>http://leceue.github.io./2019/10/30/KMP/</id>
    <published>2019-10-30T11:25:09.000Z</published>
    <updated>2019-10-30T23:43:02.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于KMP"><a href="#关于KMP" class="headerlink" title="关于KMP"></a>关于KMP</h2><p>​    KMP其实是三个人名字的缩写,因为是他们同时发现的<del>(大佬惹不起)</del>;</p><p>​    KMP作为CSP考点,主要亮点是其优秀的匹配复杂度,而且消耗空间小,比起hash虽然有些局限性,但是因为其正确率高,所以经常被人使用.</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    关于字符串的读取,以及字符串相关操作的基础了解,这里涉及字符串匹配以及子串;</p><a id="more"></a><h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    其实KMP并不困难,只是让人难受的是它比较抽象的数组跳跃,我想这个并不需要过多解释;</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>​    KMP常用于一个字符串是否出现在另一个字符串中.我们知道,如果暴力匹配了话,每次失配时就必须重新开始(不能贪心地从失配位置匹配),这样造成很大的浪费,那么我们想从已经匹配过的字符串中提取一些信息,以至于让我们不跳那么远,那这怎么办?</p><p>​    KMP算法就由此诞生了,它通过记录模式串的内部信息,为匹配时提供信息,可以节省大量时间.</p><h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,nxt[maxn],l1,l2,ans;</span><br><span class="line"><span class="keyword">char</span> s1[maxn],s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nxt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l2;i++)&#123;</span><br><span class="line">t=nxt[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">while</span>(s2[i]!=s2[t+<span class="number">1</span>]&amp;&amp;t&gt;=<span class="number">0</span>) t=nxt[t];</span><br><span class="line"><span class="keyword">if</span>(s2[t+<span class="number">1</span>]==s2[i]) nxt[i]=t+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> nxt[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;l1)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">i++,j++;</span><br><span class="line"><span class="keyword">if</span>(j==l2)</span><br><span class="line">ans++,j=nxt[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>) i++;</span><br><span class="line"><span class="keyword">else</span> j=nxt[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;s2&gt;&gt;s1;ans=<span class="number">0</span>;</span><br><span class="line">l1=<span class="built_in">strlen</span>(s1),l2=<span class="built_in">strlen</span>(s2);</span><br><span class="line"><span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="keyword">sizeof</span> nxt);</span><br><span class="line">get_nxt();KMP();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于next数组的几个性质"><a href="#关于next数组的几个性质" class="headerlink" title="关于next数组的几个性质"></a>关于next数组的几个性质</h3><p>​    因为next与stl冲突所以命名为nxt数组;</p><p>​    next数组有一些性质:</p><p>​    $next[l]$ 到 $l$ 为模式串的最小循环节,当然必须满足一个条件,即最小循环节长度是整个串长度的因数,如果不是了话,那么一定是开头的字符串有残余,而残余字符串为循环节的后缀;</p><p>​    那么考虑一下,如果我们想要找最小循环节,直接初始化后,找 $next[l]$ 即可,当然还要判断一下;</p><p>​    想象一下 $next$ 数组的跳跃,我们能找到什么?即从 $1$ ~ $next [ l ] $ 既是前缀又是后缀,那么我们可以找到子串中的最大前缀和后缀相同的;</p><h3 id="匹配时需要注意的细节"><a href="#匹配时需要注意的细节" class="headerlink" title="匹配时需要注意的细节"></a>匹配时需要注意的细节</h3><p>​    我们常常会遇到让我们求出循环次数,以及不重叠循环次数,其区别只是判断 $j==l2$ 时 $j$ 是否要跳回 $next[j]$ ;</p><p>​    或者是直接判断是否有这个模式串,直接 $return$ 即可;</p><h3 id="关于题目变形"><a href="#关于题目变形" class="headerlink" title="关于题目变形"></a>关于题目变形</h3><p>​    主要是应该看出匹配方式,以及字符串的重构问题;</p><h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于KMP&quot;&gt;&lt;a href=&quot;#关于KMP&quot; class=&quot;headerlink&quot; title=&quot;关于KMP&quot;&gt;&lt;/a&gt;关于KMP&lt;/h2&gt;&lt;p&gt;​    KMP其实是三个人名字的缩写,因为是他们同时发现的&lt;del&gt;(大佬惹不起)&lt;/del&gt;;&lt;/p&gt;&lt;p&gt;​    KMP作为CSP考点,主要亮点是其优秀的匹配复杂度,而且消耗空间小,比起hash虽然有些局限性,但是因为其正确率高,所以经常被人使用.&lt;/p&gt;&lt;h4 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h4&gt;&lt;p&gt;​    关于字符串的读取,以及字符串相关操作的基础了解,这里涉及字符串匹配以及子串;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="字符串" scheme="http://leceue.github.io./tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>基环树初步</title>
    <link href="http://leceue.github.io./2019/10/26/Base-ring-tree/"/>
    <id>http://leceue.github.io./2019/10/26/Base-ring-tree/</id>
    <published>2019-10-26T00:28:08.000Z</published>
    <updated>2019-10-26T06:46:22.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>​    说实话,基环树一般比较综合,所以一般只要就要具有图论基本知识便可以开始学习.</p><h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>​    博主实力不足,如果出错,<del>请用力D他</del> .</p><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>​    基环树,原体是树,有树上任意连一条边,就成了一个环,即基环树,一般特征,$n$个点$n$条边;</p><p>​    由于有树的特征,所以经常会用一些树的算法来计算基环树;</p><a id="more"></a><h2 id="基础的知识"><a href="#基础的知识" class="headerlink" title="基础的知识"></a>基础的知识</h2><h3 id="找环"><a href="#找环" class="headerlink" title="找环"></a>找环</h3><p>​    寻找环,这是基环树的基础,也很简单.</p><p>​    考虑记录每个点是否访问过,当再次经过这个点时,那么这个点就能找出这个环了.</p><p>​    我们只要在dfs时记录点的前继即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cir</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=x;stk[++tot]=x;id[x]=tot;w[y]=f;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">temp=pre[temp];</span><br><span class="line">stk[++tot]=temp;</span><br><span class="line">id[temp]=tot;</span><br><span class="line">&#125;<span class="keyword">while</span>(temp!=y);</span><br><span class="line">sum[<span class="number">1</span>]=w[y];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+w[stk[i<span class="number">-1</span>]];</span><br><span class="line">&#125;<span class="comment">//记录环 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) &#123;</span><br><span class="line">pre[y]=x,w[y]=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(dfs1(y,x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">get_cir(x,y,edge[i].w);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//返回值为是否找到环</span></span><br></pre></td></tr></table></figure><p>​    这个是根据原理自己构造的,需要注意的是,环处理出来的前缀和终点不是该点,即$sum[i]$为从0点到$i+1$点的距离,所以记录环中第2个for循环就是讲$sum$数组循环移动一次,当然这是我自己构造而导致的$bug$,不过也并不碍事;</p><h3 id="子树DP找直径以及最大深度"><a href="#子树DP找直径以及最大深度" class="headerlink" title="子树DP找直径以及最大深度"></a>子树DP找直径以及最大深度</h3><p>​    这里应该是比较基础的,确实,两遍bfs或dfs理解很容易,但是相比之下,DP有更优的时间以及优秀的代码长度,所以DP找直径是必要的;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ll f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">ll other=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa||id[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y,x);</span><br><span class="line">f=max(f,root[x]+root[y]+edge[i].w);</span><br><span class="line">f=max(f,other+root[y]+edge[i].w);<span class="comment">//更新直径 </span></span><br><span class="line">other=max(other,root[y]+edge[i].w);</span><br><span class="line">dep[x]=max(dep[x],dep[y]+edge[i].w);<span class="comment">//深度更新 </span></span><br><span class="line">&#125;</span><br><span class="line">root[x]+=other;</span><br><span class="line">&#125;<span class="comment">//DP找直径以及最大深度</span></span><br></pre></td></tr></table></figure><h2 id="进阶结合"><a href="#进阶结合" class="headerlink" title="进阶结合"></a>进阶结合</h2><p>​    基环树,最终都是在环上处理问题,通常处理路径长度问题,因为博主实力不足,目前见过两种,都总结下来;</p><h3 id="set维护"><a href="#set维护" class="headerlink" title="set维护"></a>set维护</h3><p>​    <strong><a href="https://www.luogu.org/problem/CF835F" target="_blank" rel="noopener">Roads in the Kingdom</a></strong></p><blockquote><p>​    王国有$n$座城市与$n$条有长度的街道，保证所有城市直接或间接联通，我们定义王国的直径为所有点对最短距离中的最大值，现因财政危机需拆除一条道路并同时要求所有城市仍然联通，求所有拆除方案中王国直径的最小值</p></blockquote><p>​    显然,这是一道有基环树特征的题,考虑枚举拆除道路,即环上道路(不在环上就不连通了),那么如何快速求出直径是我们所需要的;</p><p>​    我们可以先考虑直径不过环,那么可以先DP预处理出子树上直径,并同时处理出最大深度$dep$(后面要用).</p><p>​    之后考虑环上直径,我们可以维护环上前缀和,注意前缀和$sum[i]$必须以点$i$结尾;那么,直径公式就很显然了;</p><script type="math/tex; mode=display">max_{i<j}(sum[j]+dep[j]-sum[i]+dep[i])</script><p>​    那么,我们可以用两个set维护$sum[i]+dep[i]$和$-sum[i]+dep[i]$,每次取出最大值,相加即可;</p><p>​    还有一些细节问题需要注意:</p><blockquote><p>1.显然$i\not =j$,如果相等,我们可以取次小值最大的更新.</p><p>2.万一不在一个环上怎么办,我们知道,环上有两种求直径, $sum[j]-sum[i]$ 和 $sum[tot]-sum[j]+sum[i]$,那么我们如何保证一定是第一个公式呢.考虑我们在存前缀和时,$sum[1]$是点$1$与点$tot$之间的距离,那么我们可以先枚举这条边,那么,此时一定是第一个公式,这个可以想一想环上前缀和的特点;那么我们就可以在枚举点,枚举的边即为它与$i-1$之间的边,每次到下一个点,使我们这个点的$sum$加上$sum[tot]$,即相当于变成了前缀和最后一个点,然后在set中加入,并删除以前的;</p><p>3.如何保证$j&gt;i$,考虑一下,如果 $j<i$ ,但是前缀和中 $sum[i]>sum[j]$ ,那么显然</i$></p><script type="math/tex; mode=display">sum[j]+dep[j]-sum[i]+dep[i]<sum[i]+dep[i]-sum[j]+dep[j]</script><p>而我们求出的是最优的,所以一定是后者,所以只要注意一下第一条所说的$i=j$的情况,其他情况下$i&lt;j$.</p></blockquote><p>这样应该就能解决了,对了,multiset的结构体删除请注意一下,重载运算符可能会出差错;</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 400007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) (d)&#123;x,y&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st multiset<span class="meta-string">&lt;d&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[maxn],pre[maxn],stk[maxn],id[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> cent,vis[maxn],w[maxn];</span><br><span class="line">ll sum[maxn],ans,dep[maxn],root[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line"><span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">edge[++cent]=(node)&#123;head[v],u,w&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cir</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=x;stk[++tot]=x;id[x]=tot;w[y]=f;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">temp=pre[temp];</span><br><span class="line">stk[++tot]=temp;</span><br><span class="line">id[temp]=tot;</span><br><span class="line">&#125;<span class="keyword">while</span>(temp!=y);</span><br><span class="line">sum[<span class="number">1</span>]=w[y];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+w[stk[i<span class="number">-1</span>]];</span><br><span class="line">&#125;<span class="comment">//记录环 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!vis[y]) &#123;</span><br><span class="line">pre[y]=x,w[y]=edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(dfs1(y,x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">get_cir(x,y,edge[i].w);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//返回值为是否找到环 </span></span><br><span class="line"></span><br><span class="line">ll f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">ll other=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> y=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(y==fa||id[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y,x);</span><br><span class="line">f=max(f,root[x]+root[y]+edge[i].w);</span><br><span class="line">f=max(f,other+root[y]+edge[i].w);<span class="comment">//更新直径 </span></span><br><span class="line">other=max(other,root[y]+edge[i].w);</span><br><span class="line">dep[x]=max(dep[x],dep[y]+edge[i].w);<span class="comment">//深度更新 </span></span><br><span class="line">&#125;</span><br><span class="line">root[x]+=other;</span><br><span class="line">&#125;<span class="comment">//DP找直径以及最大深度 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d</span>&#123;</span></span><br><span class="line">ll val,pos;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> d &amp;x) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val&gt;x.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;d&gt;a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scan(n);ans=<span class="number">2305843009213693652</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=n;i++) scan(u,v,w),add(u,v,w);</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) dfs2(stk[i],<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">a.insert(mp(sum[i]+dep[stk[i]],i)),b.insert(mp(-sum[i]+dep[stk[i]],i));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">st x=a.begin(),y=b.begin();</span><br><span class="line">ll ol=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x-&gt;pos==y-&gt;pos)&#123;</span><br><span class="line">st dir=a.begin();dir++;</span><br><span class="line">ol=dir-&gt;val+y-&gt;val;</span><br><span class="line">dir=b.begin();dir++;</span><br><span class="line">ol=max(ol,dir-&gt;val+x-&gt;val);</span><br><span class="line">&#125;<span class="keyword">else</span> ol=x-&gt;val+y-&gt;val;</span><br><span class="line">ans=min(ans,ol);</span><br><span class="line">x=a.find(mp(sum[i]+dep[stk[i]],i)),y=b.find(mp(-sum[i]+dep[stk[i]],i));</span><br><span class="line">a.erase(x),b.erase(y);</span><br><span class="line">a.insert(mp(sum[i]+sum[tot]+dep[stk[i]],i)),b.insert(mp(-sum[i]-sum[tot]+dep[stk[i]],i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,max(f,ans));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>​    <strong><a href="https://www.luogu.org/problem/P4381" target="_blank" rel="noopener">P4381 [IOI2008]Island</a></strong></p><blockquote><p>你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为$L_i$的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：</p><ul><li><p>可以自行挑选一个岛开始游览。</p></li><li><p>任何一个岛都不能游览一次以上。</p></li><li><p>无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$</p><p> 有如下方法： </p><ul><li>步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。</li><li>渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。</li></ul></li></ul><p>注意，你不必游览所有的岛，也可能无法走完所有的桥。</p></blockquote><p>​    我们很容易分析出这是一个基环树森林,分别计算每一个基环树上的直径,但是我们不能排除环的干扰,难道要暴力枚举环上边,博主并没有尝试,<del>决定口胡</del>;</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>​    以下为博主口胡部分(并不是主流的正解做法):</p><p>​    根据公式$d=sum[j]-sum[i]+dep[i]+dep[j]$;</p><p>​    我们可以用上面的方法枚举断边,然后用set维护,求出最大直径,之后对于每一个基环树进行操作,累加和即可.</p><p>​    总时间复杂度$O(nlongn)$,估计可以通过此题,但是因为这道题时间太过久远,博主在之前写过单调队列,已经不想再写一遍了,不过这种方法预测可行<del>(还挺具有普适性的)</del>;</p><h4 id="主流的单调队列"><a href="#主流的单调队列" class="headerlink" title="主流的单调队列"></a>主流的单调队列</h4><p>​    显然,我们可以枚举点$i,j$,不过这样会$T$,</p><p>​    但是考虑当$i&lt;j$时,我们可以用单调队列维护$-sum[i]+dep[i]$的最大值,然后断环成链,更新即可</p><p>​    至于出队条件,即为$pos[j]-pos[front]&gt;len$($len$为环长度).时间复杂度$O(n)$.</p><p>​    这里不再附上代码,因为当时代码太丑,有很大一部分是与他人代码雷同(因为当时不会写),为了防止误导,就不再附上代码;</p><p>ps:当遇到这类题时会再次update.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h2&gt;&lt;p&gt;​    说实话,基环树一般比较综合,所以一般只要就要具有图论基本知识便可以开始学习.&lt;/p&gt;&lt;h4 id=&quot;警告&quot;&gt;&lt;a href=&quot;#警告&quot; class=&quot;headerlink&quot; title=&quot;警告&quot;&gt;&lt;/a&gt;警告&lt;/h4&gt;&lt;p&gt;​    博主实力不足,如果出错,&lt;del&gt;请用力D他&lt;/del&gt; .&lt;/p&gt;&lt;h2 id=&quot;认识&quot;&gt;&lt;a href=&quot;#认识&quot; class=&quot;headerlink&quot; title=&quot;认识&quot;&gt;&lt;/a&gt;认识&lt;/h2&gt;&lt;p&gt;​    基环树,原体是树,有树上任意连一条边,就成了一个环,即基环树,一般特征,$n$个点$n$条边;&lt;/p&gt;&lt;p&gt;​    由于有树的特征,所以经常会用一些树的算法来计算基环树;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="图论" scheme="http://leceue.github.io./tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>一维以及二维的差分的简述</title>
    <link href="http://leceue.github.io./2019/10/25/one-two-difference/"/>
    <id>http://leceue.github.io./2019/10/25/one-two-difference/</id>
    <published>2019-10-25T08:22:08.000Z</published>
    <updated>2019-10-25T13:24:23.195Z</updated>
    
    <content type="html"><![CDATA[<p>　　差分，也就是数与数之间的差值。拿一维差分来举例子，将差分设为c[ ]数组，原数为a[ ],那么</p><p>　　$c[i]=a[i]-a[i-1]$</p><p>　　这便是简单的差分数组；</p><p>　　那么要他何用？</p><p>　　最为主要的作用就是区间的修改，那么在修改之前，我们先明白如何将原数求出。很显然，$c[1]$~$c[i]$差分数组求和即可得到$a[i]$。</p><a id="more"></a><p>　　那区间修改呢？</p><p>　　如我们将从l到r的区间加上s（减去也一样），那么由差分数组的定义得，观察数组，发现只有c[l]和c[r+1]变化了。</p><p>　　具体证明可以手动模拟，而中间的不变是因为i项与i-1项都加上了s，差值不变;</p><p>　　那么这样就能得到</p><p>　　$a[l]$~$a[r]+=s$—&gt;$c[l]+s,c[r+1]+s$</p><p>　　这样就实现了$O(1)$修改；</p><p>　　当然还有区间求和，这里给出证明</p><p><img src="\images\7.png" alt="alt"></p><p>　　这样我们可以发现一个规律，即第二个多项式的系数为i-1</p><p>　　那么我们用c2[ ]来维护这个数组，那么</p><script type="math/tex; mode=display">c2[i]=(i-1)*c[i]</script><p>　　并且在修改时维护$c2[ i]$数组，即</p><script type="math/tex; mode=display">c[l]+(l-1)*s,c[r+1]-(r+1-1)*s</script><p>　　之后便有了公式</p><p>　　<img src="\images\8.png" alt="alt"></p><p>　　这里便是一维差分</p><p>　　<strong>二维差分的推导</strong></p><p>　　这里的推导只是单纯的根据一维差分和二维前缀和的性质来推的</p><p>　　二维前缀和请务必提前了解，并有一定的认识；</p><p>　　那么开始推导；</p><p>　　根据二维前缀和表示的是右上角矩形的和，由于差分只涉及前面相邻的数（由一维可以推出），并且由前面范围的数相加得到这个位置的数；</p><p>　　那么类比二维前缀和和一维差分，可以简单推测出二维差分的公式</p><p>　　$c[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$</p><p> 　　是不是觉得非常眼熟？</p><p>　　我们再代入检验，即将左上角的矩阵差分求和，正好得到了这个数·</p><p>　　这还并不能代表什么，重要的是区间的修改；</p><p>　　同样，我们将要修改的矩阵的右上角设为$(x1,y1)$,右下角设为$(x2,y2)$</p><p>　　<img src="\images\9.png" alt="alt"></p><p>　　我们发现有影响的只有我所标注的点，除了$(x2,y2)$,这个应该很好看出；</p><p>　　那么，我们就得到公式</p><p>　　$c[x1][y1]+=s,c[x1][y2+1]-=s,c[x2+1][y1]-=s,c[x2+1][y2+1]+=s$</p><p>　　推荐自己再推一遍。</p><p>　　之后求数只需累加即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　差分，也就是数与数之间的差值。拿一维差分来举例子，将差分设为c[ ]数组，原数为a[ ],那么&lt;/p&gt;&lt;p&gt;　　$c[i]=a[i]-a[i-1]$&lt;/p&gt;&lt;p&gt;　　这便是简单的差分数组；&lt;/p&gt;&lt;p&gt;　　那么要他何用？&lt;/p&gt;&lt;p&gt;　　最为主要的作用就是区间的修改，那么在修改之前，我们先明白如何将原数求出。很显然，$c[1]$~$c[i]$差分数组求和即可得到$a[i]$。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="基础知识" scheme="http://leceue.github.io./tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>扫描线</title>
    <link href="http://leceue.github.io./2019/10/25/scan-line/"/>
    <id>http://leceue.github.io./2019/10/25/scan-line/</id>
    <published>2019-10-25T08:21:22.000Z</published>
    <updated>2019-10-25T13:17:23.598Z</updated>
    
    <content type="html"><![CDATA[<p>请在学习之前有一定的线段树基础</p><p>在一些题中，它总会给你一些矩形，之后让你求总覆盖面积。</p><p>它的难点在于，有重叠面积，如果只是罗列情况，那么只会一事无成。</p><p>所以说，这里就引进了扫描线做法；</p><p>其实它的原理很简单，只是底*高而已，只是分段求解；</p><p>而问题大概的图就是这样</p><p><img src="/images/10.png" alt="alt"></p><p>根据我刚刚说的分段求解和底*高，那么我们就可以推测出扫描线是什么了</p><a id="more"></a><p>它是由矩形的上边和下边构成，并记录其左右端点和其所在的纵坐标；</p><p><img src="/images/11.png" alt="img"></p><p>图中标红的即为扫描线，那么我们用它做什么？</p><p>根据 S=a<em>h，那么我们可以将扫描线按<em>*纵坐标排序</em></em>，这样分步求解。</p><p>这是扫描线的储存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//左右端点坐标 </span></span><br><span class="line">    <span class="keyword">int</span> h;<span class="comment">//还是按 扫描线写，这个是y轴坐标 </span></span><br><span class="line">    <span class="keyword">int</span> d;<span class="comment">//标记这个线是不是上界或下界 </span></span><br><span class="line">&#125;s[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线</span></span><br></pre></td></tr></table></figure><p>那么便可以得到高，即</p><p><strong>s[i+1].h-s[i].h</strong></p><p>之后考虑存底，只需要用线段树维护即可；</p><p>当扫描线为下界时，应当将扫描线所在区域加入线段树，而当为上界时再减去即可；</p><p>由于底边过大，不可能全部建树，这里给出了离散化做法，还有动态开点做法之后将会提到</p><p>由于找不到最合适的模板题，只能拿这个来充数<a href="https://www.luogu.org/problemnew/show/P2061" target="_blank" rel="noopener"> P2061 [USACO07OPEN]城市的地平线City Horizon</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">　  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,h;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;h);</span><br><span class="line">    ls[++cent]=a;<span class="comment">//其实是用来离散化的 </span></span><br><span class="line">    s[cent]=(node)&#123;a,b,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    ls[++cent]=b;</span><br><span class="line">    s[cent]=(node)&#123;a,b,h,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(ls+<span class="number">1</span>,ls+<span class="number">1</span>+cent);<span class="comment">//离散化初始 </span></span><br><span class="line">sort(s+<span class="number">1</span>,s+<span class="number">1</span>+cent);ls[++m]=ls[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls[i]!=ls[i<span class="number">-1</span>])</span><br><span class="line">        ls[++m]=ls[i];<span class="comment">//去重 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便是简单的离散化，当然，你也可以排序后用unique函数，得到m和ls数组，这个可以网上查询，这里便不再赘述</p><p>之后是线段树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[p]) tree[p].sum=ls[r]-ls[l];<span class="comment">//如何避免少减？ </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tree[p].sum=tree[le(p)].sum+tree[re(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_date</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> d,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=tree[p].l,r=tree[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        mark[p]+=d;</span><br><span class="line">        push_up(l,r,p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r<span class="number">-1</span>==l) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=L) up_date(le(p),d,L,R);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) up_date(re(p),d,L,R);</span><br><span class="line">    push_up(l,r,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码是我根据多种方面得出，但是仍由问题，即代码所说的，因为在线段数中 l 是可以等于 r 的，但是线段的长度必须由两个不同的数得出，这是不行的</p><p>所以，我们可以先建出一颗空树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l;</span><br><span class="line">    tree[p].r=r;</span><br><span class="line">    tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p)),build(mid,r,re(p));<span class="comment">/*注意，mid在左子树和右子树中都有出现，所以在 </span></span><br><span class="line"><span class="comment">    叶子节点，r=l+1，这个也是对return 的解释*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，这样便避免了这个问题，不过请读者注意这些点，这些便是易错的小细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> l=search(s[i].x,ls);<span class="comment">//二分寻找离散化位置</span></span><br><span class="line">    <span class="keyword">int</span> r=search(s[i].y,ls);</span><br><span class="line">    up_date(<span class="number">1</span>,s[i].d,l,r);<span class="comment">// 用线段树更新sum，即矩形底边 </span></span><br><span class="line">    rt+=(ll)tree[<span class="number">1</span>].sum*<span class="number">1l</span>l*(s[i+<span class="number">1</span>].h-s[i].h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是主函数的计算，而search有解释，也可以用lower_bound，推荐提前处理出来，否则可能会提高时间复杂度，这不是我们所期望的</p><p>这样的做法不易错是真的，这里给出二分search做法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> pur,<span class="keyword">int</span>* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[mid]&lt;pur) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便是整个过程，这里给出<strong>code</strong></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 40007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,cent,m,mark[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> ls[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line">ll rt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tr</span>&#123;</span></span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//左右端点坐标 </span></span><br><span class="line">    <span class="keyword">int</span> h;<span class="comment">//还是按 扫描线写，这个是y轴坐标 </span></span><br><span class="line">    <span class="keyword">int</span> d;<span class="comment">//标记这个线是不是上界或下界 </span></span><br><span class="line">&#125;s[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[p]) tree[p].sum=ls[r]-ls[l];<span class="comment">//如何避免少减？ </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tree[p].sum=tree[le(p)].sum+tree[re(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_date</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> d,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=tree[p].l,r=tree[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        mark[p]+=d;</span><br><span class="line">        push_up(l,r,p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r<span class="number">-1</span>==l) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=L) up_date(le(p),d,L,R);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) up_date(re(p),d,L,R);</span><br><span class="line">    push_up(l,r,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l;</span><br><span class="line">    tree[p].r=r;</span><br><span class="line">    tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p)),build(mid,r,re(p));<span class="comment">/*注意，mid在左子树和右子树中都有出现，所以在 </span></span><br><span class="line"><span class="comment">    叶子节点，r=l+1，这个也是对return 的解释*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> pur,<span class="keyword">int</span>* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[mid]&lt;pur) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,h;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;h);</span><br><span class="line">        ls[++cent]=a;<span class="comment">//其实是用来离散化的 </span></span><br><span class="line">        s[cent]=(node)&#123;a,b,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        ls[++cent]=b;</span><br><span class="line">        s[cent]=(node)&#123;a,b,h,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ls+<span class="number">1</span>,ls+<span class="number">1</span>+cent);<span class="comment">//离散化初始 </span></span><br><span class="line">    sort(s+<span class="number">1</span>,s+<span class="number">1</span>+cent);ls[++m]=ls[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ls[i]!=ls[i<span class="number">-1</span>])</span><br><span class="line">            ls[++m]=ls[i];<span class="comment">//去重 </span></span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l=search(s[i].x,ls);<span class="comment">//二分寻找离散化位置</span></span><br><span class="line">        <span class="keyword">int</span> r=search(s[i].y,ls);</span><br><span class="line">        up_date(<span class="number">1</span>,s[i].d,l,r);<span class="comment">// 用线段树更新sum，即矩形底边 </span></span><br><span class="line">        rt+=(ll)tree[<span class="number">1</span>].sum*<span class="number">1l</span>l*(s[i+<span class="number">1</span>].h-s[i].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;rt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-24-补充："><a href="#7-24-补充：" class="headerlink" title="7.24 补充："></a>7.24 补充：</h2><p><a href="https://www.luogu.org/problemnew/show/P1502" target="_blank" rel="noopener"><strong>LUOGU P1502 窗口的星星</strong></a></p><p>　　</p><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>小卡买到了一套新房子，他十分的高兴，在房间里转来转去。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>晚上，小卡从阳台望出去，“哇~~~~好多星星啊”，但他还没给其他房间设一个窗户，天真的小卡总是希望能够在晚上能看到最多最亮的星星，但是窗子的大小是固定的，边也必须和地面平行。这时小卡使用了超能力（透视术）知道了墙后面每个星星的位置和亮度，但是小卡发动超能力后就很疲劳，只好拜托你告诉他最多能够有总和多亮的星星能出现在窗口上。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p><strong>输入格式：</strong></p><p>本题有多组数据，第一行为T 表示有T组数据T&lt;=10</p><p>对于每组数据</p><p>第一行3个整数n，W，H，（n&lt;=10000,1&lt;=W,H&lt;=1000000）表示有n颗星星，窗口宽为W，高为H。</p><p>接下来n行，每行三个整数xi，yi，li 表示星星的坐标在（xi，yi），亮度为li。（0&lt;=xi,yi&lt;2^31)</p><p><strong>输出格式：</strong></p><p>T个整数，表示每组数据中窗口星星亮度总和的最大值。</p><p>这道题的一个关键点是，将星星作为一个窗户的左下角（其实是为了不出现负数），将每一个星星都创一个窗户，之后寻找重叠部分</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h3><p><strong><img src="/images/12.png" alt="alt"></strong></p><p>看这个图，这是两个相交的情况，矩形左下角是星星，然后如果有重叠部分，那么我们要贴着相交部分的上边和右边建一个窗户，那么就可以盖住这两个星星，</p><p><img src="/images/13.png" alt="alt"></p><p>类比到所有星星是一样的，我们只要将矩形附上权值即可，用扫描线寻找。</p><p><strong>但是这个边框不是不能包含星星吗？所以我们需要处理一些小细节，将矩形右边的横坐标减去1，也就是提前减去，再将扫描线上端-1，这就处理了边界问题；</strong></p><p><strong>并且在sort的时候当横坐标相同时，将加上的排在前面。</strong></p><p>这个细节请一定要理解，否则wa了也不好调（因为不给数据），代码我会做上标记。</p><p>矩形权值直接附在扫描线上即可；</p><p>上一道例题中，我用离散化解决了范围大的问题，这里我们介绍动态开点做法；</p><p>首先不需要在意太多的离散化细节是一个优点，干干的介绍不是非常简洁，所以我直接附上代码讲解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,w,h,cnt,lim,root;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,l,r,w,d;</span><br><span class="line">&#125;a[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> le,ri,w,tag;</span><br><span class="line">&#125;tr[<span class="number">5000007</span>];<span class="comment">//动态开点的不同，le和ri记录的是左端点和右端点的p值 </span></span><br><span class="line"><span class="comment">//tr记住稍微大一点 （别 MLE 了 ），反正不会错 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x==y.x?x.d&gt;y.d:x.x&lt;y.x;</span><br><span class="line">&#125;<span class="comment">//sort的细节*** </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[p].le) tr[p].le=++cnt;<span class="comment">//没点开点 </span></span><br><span class="line">    <span class="keyword">if</span>(!tr[p].ri) tr[p].ri=++cnt;</span><br><span class="line">    tr[tr[p].le].w+=k,tr[tr[p].ri].w+=k;</span><br><span class="line">    tr[tr[p].le].tag+=k,tr[tr[p].ri].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;<span class="comment">//没点开点 </span></span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p].w+=k,tr[p].tag+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag) push_down(p,tr[p].tag);tr[p].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) add(nl,nr,l,mid,tr[p].le,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) add(nl,nr,mid+<span class="number">1</span>,r,tr[p].ri,k);</span><br><span class="line">    tr[p].w=max(tr[tr[p].le].w,tr[tr[p].ri].w);</span><br><span class="line">&#125;<span class="comment">//与线段树相同 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">    scan(n);scan(w),scan(h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,v;i&lt;=n;i++)</span><br><span class="line">        scan(x),scan(y),scan(v),lim=max(x+w+<span class="number">1</span>,lim),<span class="comment">//lim是线段树范围 </span></span><br><span class="line">        a[(i&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>]=(node)&#123;x,y,y+h<span class="number">-1</span>,v,<span class="number">1</span>&#125;,<span class="comment">//强行转换格式，-1的细节** </span></span><br><span class="line">        a[i&lt;&lt;<span class="number">1</span>]=(node)&#123;x+w<span class="number">-1</span>,y,y+h<span class="number">-1</span>,v,<span class="number">-1</span>&#125;;<span class="comment">//细节** </span></span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+<span class="number">2</span>*n);<span class="comment">//细节** </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        add(a[i].l,a[i].r,<span class="number">1</span>,lim,root,a[i].w*a[i].d);</span><br><span class="line">        ans=max(ans,tr[root].w);<span class="comment">//直接用整棵树更新就好啦 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(t);</span><br><span class="line">    <span class="keyword">while</span>(t--) work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扫描线2种方法都已经讲完，可以再找一些题练习一下；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请在学习之前有一定的线段树基础&lt;/p&gt;&lt;p&gt;在一些题中，它总会给你一些矩形，之后让你求总覆盖面积。&lt;/p&gt;&lt;p&gt;它的难点在于，有重叠面积，如果只是罗列情况，那么只会一事无成。&lt;/p&gt;&lt;p&gt;所以说，这里就引进了扫描线做法；&lt;/p&gt;&lt;p&gt;其实它的原理很简单，只是底*高而已，只是分段求解；&lt;/p&gt;&lt;p&gt;而问题大概的图就是这样&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/10.png&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;&lt;p&gt;根据我刚刚说的分段求解和底*高，那么我们就可以推测出扫描线是什么了&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://leceue.github.io./tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>悬线法</title>
    <link href="http://leceue.github.io./2019/10/25/suspended-line/"/>
    <id>http://leceue.github.io./2019/10/25/suspended-line/</id>
    <published>2019-10-25T08:21:05.000Z</published>
    <updated>2019-10-25T13:17:48.636Z</updated>
    
    <content type="html"><![CDATA[<p>例题 P1169 [ZJOI2007]棋盘制作</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8×88 \times 88×8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。</p><p>而我们的主人公<code>小Q</code>，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友<code>小W</code>决定将棋盘扩大以适应他们的新规则。</p><a id="more"></a><p><code>小Q</code>找到了一张由N×MN \times MN×M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。<code>小Q</code>想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。</p><p>不过<code>小Q</code>还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。</p><p>于是<code>小Q</code>找到了即将参加全国信息学竞赛的你，你能帮助他么？</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p><strong>输入格式：</strong></p><p>包含两个整数NNN和MMM，分别表示矩形纸片的长和宽。接下来的NNN行包含一个N ×MN  \times MN ×M的010101矩阵，表示这张矩形纸片的颜色（000表示白色，111表示黑色）。</p><p><strong>输出格式：</strong></p><p>包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。</p><p>审题可以发现，我们所以寻找的最大矩形其实已经含有正方形，所以不需要单独去寻找，但是当时我只想到如何DP求正方形，所以分开写了；</p><p>这里就引进一个概念——<strong>悬线法</strong></p><h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a><strong>用途：</strong></h2><p>　　<strong>求满足条件的最大矩形或正方形</strong></p><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a><strong>方法：</strong></h2><p>　　通过不断更新矩形左右端点所能到达的距离（1 ： 初始化；2：dp中更新）</p><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h2><p>　　left [ i ] [ j ] 数组更新包含第（i，j）点的最左能到达距离；</p><p>　　right [ i ] [ j ] 数组更新包含第（i，j）点的最右能到达距离；</p><p>　　up [ i ] [ j ] 数组更新包含第（i，j）点的向上能到达的距离；</p><p>　　PS：为什么没有下？因为down可以在dp中用up代替；</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h2><p>　　1：初始化 left 和 right 数组</p><p>　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=m-1;j&gt;0;j--)&#123;</span><br><span class="line">            if(maps[i][j]!=maps[i][j+1])//判断条件 </span><br><span class="line">                right[i][j]=right[i][j+1];</span><br><span class="line">        &#125;//右端点从右往左更新 </span><br><span class="line">        for(int j=2;j&lt;=m;j++)&#123;</span><br><span class="line">            if(maps[i][j-1]!=maps[i][j])</span><br><span class="line">                left[i][j]=left[i][j-1];</span><br><span class="line">        &#125;//左端点从左往右更新 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　2：DP更新 up 数组和 left，right 数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;maps[i][j]!=maps[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">            left[i][j]=max(left[i][j],left[i<span class="number">-1</span>][j]);<span class="comment">//由上更新 </span></span><br><span class="line">            right[i][j]=min(right[i][j],right[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="comment">//左取大，右取小 </span></span><br><span class="line">            up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=right[i][j]-left[i][j]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b=min(a,up[i][j]);</span><br><span class="line">        ans1=max(ans1,b*b);<span class="comment">//正方形做法2 </span></span><br><span class="line">        ans2=max(ans2,a*up[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　思考：该方法的正确性，因为每个点都取到了一次，每次选取最优解，则正解定会取到</p><p><strong>完整Code</strong>（附有正方形另类做法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,maps[maxn][maxn],ans1;</span><br><span class="line"><span class="keyword">int</span> f1[maxn][maxn],ans2,up[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> left[maxn][maxn],right[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cube</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=maps[i][j];</span><br><span class="line">            <span class="keyword">if</span>(x==maps[i<span class="number">-1</span>][j]||x==maps[i][j<span class="number">-1</span>]||x!=maps[i][j])&#123;</span><br><span class="line">                f1[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                f1[i][j]=min(f1[i<span class="number">-1</span>][j],min(f1[i][j<span class="number">-1</span>],f1[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans1=max(f1[i][j],ans1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans1*=ans1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maps[i][j]);</span><br><span class="line">            left[i][j]=j,right[i][j]=j;</span><br><span class="line">            up[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cube();<span class="comment">//正方形的做法1 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[i][j]!=maps[i][j+<span class="number">1</span>])<span class="comment">//判断条件 </span></span><br><span class="line">                right[i][j]=right[i][j+<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="comment">//右端点从右往左更新 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[i][j<span class="number">-1</span>]!=maps[i][j])</span><br><span class="line">                left[i][j]=left[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="comment">//左端点从左往右更新 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;maps[i][j]!=maps[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                left[i][j]=max(left[i][j],left[i<span class="number">-1</span>][j]);<span class="comment">//由上更新 </span></span><br><span class="line">                right[i][j]=min(right[i][j],right[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="comment">//左取大，右取小 </span></span><br><span class="line">                up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a=right[i][j]-left[i][j]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b=min(a,up[i][j]);</span><br><span class="line">            ans1=max(ans1,b*b);<span class="comment">//正方形做法2 </span></span><br><span class="line">            ans2=max(ans2,a*up[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结与反思；正确灵活使用，可以快速解决问题；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;例题 P1169 [ZJOI2007]棋盘制作&lt;/p&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8×88 \times 88×8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。&lt;/p&gt;&lt;p&gt;而我们的主人公&lt;code&gt;小Q&lt;/code&gt;，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友&lt;code&gt;小W&lt;/code&gt;决定将棋盘扩大以适应他们的新规则。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DP" scheme="http://leceue.github.io./tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分</title>
    <link href="http://leceue.github.io./2019/10/25/Heavy-light-Decomposition/"/>
    <id>http://leceue.github.io./2019/10/25/Heavy-light-Decomposition/</id>
    <published>2019-10-25T08:20:01.000Z</published>
    <updated>2019-10-25T13:17:32.413Z</updated>
    
    <content type="html"><![CDATA[<p>。。。。</p><p>有点懒；</p><p>需要先理解几个概念：</p><ol><li><p>LCA</p></li><li><p>线段树（熟练，要不代码能调一天）</p></li><li><p>图论的基本知识（dfs序的性质）</p></li></ol><p>这大概就好了；</p><p><strong>定义</strong>：</p><p>　　1.重儿子：一个点所连点树size最大的，这个son被称为这个点的重儿子；</p><p>　　2.轻儿子：一个点所连点除重儿子以外的都是轻儿子；</p><p>　　3.重链：从一个轻儿子或根节点开始沿重儿子走所成的链；</p><a id="more"></a><p><strong>步骤</strong>：</p><p>　　在代码里，结合代码更清晰。。。（其实是太懒了）</p><p>　有重点需要注意的东西在code中有提到，仔细看。。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,root,mod,a[maxn],head[maxn],fa[maxn],son[maxn],cnt,tag[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//a：原始点值，fa：父亲节点，son：重儿子，tag：懒标记 </span></span><br><span class="line"><span class="keyword">int</span> top[maxn],sz[maxn],id[maxn],dep[maxn],w[maxn],cent,tr[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//top：所在重链的头结点，sz：子树大小，id：dfs序，dep：深度 </span></span><br><span class="line"><span class="comment">//w：dfs序所对应的值（建线段树），tr：线段树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------------线段树红色预警 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[p]=tr[le(p)]+tr[re(p)];</span><br><span class="line">    tr[p]%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[p]=w[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p));</span><br><span class="line">    build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[le(p)]+=k*(mid-l+<span class="number">1</span>),tr[re(p)]+=k*(r-mid);</span><br><span class="line">    tr[le(p)]%=mod,tr[re(p)]%=mod;</span><br><span class="line">    tag[le(p)]+=k,tag[re(p)]+=k;</span><br><span class="line">    tag[le(p)]%=mod,tag[re(p)]%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p]+=k*(r-l+<span class="number">1</span>);tag[p]+=k;</span><br><span class="line">        tr[p]%=mod,tag[p]%=mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) r_add(nl,nr,l,mid,le(p),k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) r_add(nl,nr,mid+<span class="number">1</span>,r,re(p),k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">r_query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r) <span class="keyword">return</span> tr[p];</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=r_query(nl,nr,l,mid,le(p)),ans%=mod;</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=r_query(nl,nr,mid+<span class="number">1</span>,r,re(p)),ans%=mod;</span><br><span class="line">    push_up(p);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------线段树结束</span></span><br><span class="line"><span class="comment">//-----------------------------------------------------开始预处理 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;<span class="comment">//sz初始化 </span></span><br><span class="line">    <span class="keyword">int</span> max_part=<span class="number">-1</span>;<span class="comment">//max_part更新寻找重儿子 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x,dep[y]+=dep[x]+<span class="number">1</span>;<span class="comment">//更新子节点，准备开始继续dfs1 </span></span><br><span class="line">        dfs1(y);sz[x]+=sz[y];<span class="comment">//更新自身的sz数组 </span></span><br><span class="line">        <span class="keyword">if</span>(max_part&lt;sz[y]) son[x]=y,max_part=sz[y];<span class="comment">//更新重儿子 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*dfs1功能介绍</span></span><br><span class="line"><span class="comment">1.更新fa数组；</span></span><br><span class="line"><span class="comment">2.更新dep数组；</span></span><br><span class="line"><span class="comment">3.更新sz数组； </span></span><br><span class="line"><span class="comment">4.更新son数组； </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[x]=++cnt,w[cnt]=a[x],top[x]=t;<span class="comment">//更新dfs序，dfs序所对的值，重链头节点 </span></span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*dfs2功能介绍</span></span><br><span class="line"><span class="comment">1.更新id数组；</span></span><br><span class="line"><span class="comment">2.更新w数组；</span></span><br><span class="line"><span class="comment">3.更新top数组</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------预处理结束 </span></span><br><span class="line"><span class="comment">//------------------------------------------------开始主要操作 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实没有说的这么简单，这里重点是理解重链之间的跳跃方式，线段树的优化 </span></span><br><span class="line"><span class="comment">//一个性质：重链上的dfs序是连续的，dfs1在dfs2前的原因就在此 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">road_query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);<span class="comment">//从最下面往上跳 </span></span><br><span class="line">        ans+=r_query(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//更新重链 </span></span><br><span class="line">        ans%=mod;</span><br><span class="line">        x=fa[top[x]];<span class="comment">//跳到重链头的fa </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    ans+=r_query(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//已经在同一条重链上，直接加 </span></span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>)%mod;</span><br><span class="line">&#125;<span class="comment">//一个性质：在同一颗子树上的dfs序是连续的 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">road_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        r_add(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    r_add(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//类比 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//相同的性质 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------树链剖分 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m),scan(root),scan(mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        scan(u),scan(v),add(u,v),add(v,u);</span><br><span class="line">    dfs1(root),dfs2(root,root),build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> type,x,y,z;</span><br><span class="line">        scan(type);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>) scan(x),scan(y),scan(z),</span><br><span class="line">            road_add(x,y,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>) scan(x),scan(y),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,road_query(x,y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>) scan(x),scan(z),</span><br><span class="line">            tree_add(x,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">4</span>) scan(x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tree_query(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，可以开始调代码了</p><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>　　树链剖分，作为一个优秀的暴力结构，以O（n logn logn）的时间复杂度完成路径查询，在子树查询做到了nlogn级别，所以不得不说其优秀；</p><p>　　但是，它的作用远不及此：</p><h3 id="1-LCA查询："><a href="#1-LCA查询：" class="headerlink" title="　　1.LCA查询："></a>　　1.LCA查询：</h3><p>　　　　与倍增相同，树链剖分可以用logn的时间复杂度完成LCA查询（跳跃性好像更优），而他的初始化是两遍dfs O（n），理论上更优。</p><p>　　　　可以猜测，LCA依旧运用重链跳法，然后比较即可，这里给出示范代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">&#125;<span class="comment">//只要看懂树链剖分的基本操作，这个很简单</span></span><br></pre></td></tr></table></figure><p>　　　　可以看到，其实代码很短。。。</p><h3 id="2-换根操作："><a href="#2-换根操作：" class="headerlink" title="　　2.换根操作："></a>　　2.换根操作：</h3><p>　　　　设现在的根是root，我们可以发现，换根对于路径上的操作并没有影响，但是子树操作就会影响了，所以我们分类讨论</p><p>　　　　　　设u为我们要查的子树的根节点</p><p>　　　　　　（1）如果root=u，那么子树即为整棵树；</p><p>　　　　　　（2）设 lca 为root和u的LCA，这里可以用上面所讲的树链剖分做，如果lca！=u，那么root并不是u的子节点，所以对于查询并不影响，常规操作即可</p><p>　　　　　　（3）如果lca=u，那么u节点的子树就是整颗树减去u-root这个路径上与u相挨的节点v的子树即可，这里给出logn求点v的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//前提条件：要求的节点相挨的节点u，必须是root的LCA </span><br><span class="line">int find(int x,int y)&#123;</span><br><span class="line">    while(top[x]!=top[y])&#123;</span><br><span class="line">        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);//从最下往上跳 </span><br><span class="line">        if(fa[top[x]]==y) return top[x];//如果y是x所在重链top的父亲节点，那么就可以返回了 </span><br><span class="line">        x=fa[top[x]];//跳 </span><br><span class="line">    &#125;</span><br><span class="line">    if(dep[x]&lt;dep[y]) swap(x,y);//让y最浅 </span><br><span class="line">    return son[y];// 因为在一条重链上，那么重儿子一定是路径上与要求节点相挨的 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　　整个操作的代码层次感我写的还是比较清楚了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">            r_add(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,-k);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>)-r_query(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐评测网站<a href="https://loj.ac/problem/139" target="_blank" rel="noopener">LOJ </a>。。。（因为洛谷没有换根操作）</p><h3 id="AC代码附上"><a href="#AC代码附上" class="headerlink" title="AC代码附上"></a>AC代码附上</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ol putchar(<span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],cent,dep[maxn],son[maxn],fa[maxn],vis[maxn];</span><br><span class="line"><span class="keyword">int</span> top[maxn],a[maxn],id[maxn],w[maxn],sz[maxn],cnt,ij,root;</span><br><span class="line">ll tr[maxn&lt;&lt;<span class="number">3</span>],tag[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[p]=tr[le(p)]+tr[re(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[le(p)]+=<span class="number">1l</span>l*(mid-l+<span class="number">1</span>)*k,</span><br><span class="line">    tr[re(p)]+=<span class="number">1l</span>l*(r-mid)*k,</span><br><span class="line">    tag[le(p)]+=k,tag[re(p)]+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[p]=w[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p));</span><br><span class="line">    build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p]+=<span class="number">1l</span>l*(r-l+<span class="number">1</span>)*k;</span><br><span class="line">        tag[p]+=<span class="number">1l</span>l*k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) r_add(nl,nr,l,mid,le(p),k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) r_add(nl,nr,mid+<span class="number">1</span>,r,re(p),k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">r_query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r) <span class="keyword">return</span> tr[p];</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=r_query(nl,nr,l,mid,le(p));</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=r_query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;<span class="keyword">int</span> max_part=<span class="number">-1</span>;vis[x]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">        dfs1(y);sz[x]+=sz[y];</span><br><span class="line">        <span class="keyword">if</span>(max_part&lt;sz[y]) son[x]=y,max_part=sz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[x]=++cnt;w[cnt]=a[x];top[x]=t;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==son[x]||fa[x]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">&#125;<span class="comment">//只要看懂树链剖分的基本操作，这个很简单 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前提条件：要求的节点相挨的节点u，必须是root的LCA </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);<span class="comment">//从最下往上跳 </span></span><br><span class="line">        <span class="keyword">if</span>(fa[top[x]]==y) <span class="keyword">return</span> top[x];<span class="comment">//如果y是x所在重链top的父亲节点，那么就可以返回了 </span></span><br><span class="line">        x=fa[top[x]];<span class="comment">//跳 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);<span class="comment">//让y最浅 </span></span><br><span class="line">    <span class="keyword">return</span> son[y];<span class="comment">// 因为在一条重链上，那么重儿子一定是路径上与要求节点相挨的 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">            r_add(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,-k);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>)-r_query(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">road_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        r_add(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    r_add(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">road_query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        ans+=r_query(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    ans+=r_query(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("co.out","w",stdout);</span></span><br><span class="line">    scan(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,v;i&lt;=n;i++) scan(v),add(i,v),add(v,i);</span><br><span class="line">    dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>),build(<span class="number">1</span>,n,<span class="number">1</span>);root=<span class="number">1</span>;</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> type,x,y,z;</span><br><span class="line">        scan(type),scan(x);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>) root=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>) scan(y),scan(z),road_add(x,y,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>) scan(z),tree_add(x,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">4</span>) scan(y),<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,road_query(x,y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tree_query(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;。。。。&lt;/p&gt;&lt;p&gt;有点懒；&lt;/p&gt;&lt;p&gt;需要先理解几个概念：&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;LCA&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线段树（熟练，要不代码能调一天）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图论的基本知识（dfs序的性质）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这大概就好了；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;　　1.重儿子：一个点所连点树size最大的，这个son被称为这个点的重儿子；&lt;/p&gt;&lt;p&gt;　　2.轻儿子：一个点所连点除重儿子以外的都是轻儿子；&lt;/p&gt;&lt;p&gt;　　3.重链：从一个轻儿子或根节点开始沿重儿子走所成的链；&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://leceue.github.io./tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>莫队--基于分块的优化</title>
    <link href="http://leceue.github.io./2019/10/25/mo-algorithm/"/>
    <id>http://leceue.github.io./2019/10/25/mo-algorithm/</id>
    <published>2019-10-25T08:19:32.000Z</published>
    <updated>2019-10-25T13:17:15.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="莫队思想浅谈"><a href="#莫队思想浅谈" class="headerlink" title="莫队思想浅谈"></a>莫队思想浅谈</h1><p>莫队，基于分块思想。</p><p>所以说，在学习莫队时可以先了解一下分块的优化原理，这对于莫队的理解会有帮助；</p><p>我们将分层次讲解，难度不断增加，并附有例题。。。（由于博主太烂懒，所以莫队的模板概念知识只会在这里叙述）</p><h2 id="1-莫队："><a href="#1-莫队：" class="headerlink" title="1.莫队："></a><strong>1.莫队：</strong></h2><p>　　基础的莫队是用来解决区间离线查询问题，利用分块原理和排序，将查询时的重叠部分集中以来优化的算法，大多的算法的复杂度为$O(nsqrt(n))$，实际更优；</p><a id="more"></a><p>　　莫队代码一般很短，且有套路可言，所以应熟练掌握；</p><p>　　表述完毕，开始讲解：</p><p>　　<a href="https://www.luogu.org/problem/P1972" target="_blank" rel="noopener">P1972 [SDOI2009]HH的项链</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行：一个整数N，表示项链的长度。</p><p>第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。</p><p>第三行：一个整数M，表示HH 询问的个数。</p><p>接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>M 行，每行一个整数，依次表示询问对应的答案。</p><p>　　莫队的一道例题，但是这道题很恶心，数据专门卡了莫队，不过不用担心，我们可以吸口氧，再吸口臭氧，然后再有一些优化就可以A掉（如果实在过不了，后面附上了树状数组代码），然后让我们来讲解；</p><p>设第一个查询的区间为[ l1,r1 ] , 第二个查询的区间为[ l2,r2 ]；</p><p>既然已经说莫队时暴力结构，那么就能猜到它的统计方式是暴力统计；</p><p>引入两个指针 l ，r，首先让 l 移动，让l = l1，移动时进行增加或减去操作，像这道题，是颜色个数的减少或增加，那么暴力统计就可以不说了吧；</p><p>在移动到第二个区间时，用同样的操作移动；</p><p>但是这个不就是纯暴力了吗，不知道你是否有这样的疑问；</p><p>但是当我们将区间分块，再将区间按l，r所在块进行排序，那么每次移动的时间复杂度就变成了sqrt（n）（因为我们分成了sqrt（n）个块）；</p><p>这样就应该明白其原理，如果真的还是不懂了话，那么可以看看代码；</p><p><strong>Code（带有O2优化，O3优化和排序优化）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="comment">//luogu的O2，NOIP没有 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)<span class="comment">//O3优化，联赛时没有 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ri register int<span class="comment">//指针优化 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,be[maxn],a[maxn],unit,col[maxn*<span class="number">10</span>],ans,l=<span class="number">1</span>,r,prin[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r,id;&#125;q[maxn];<span class="comment">//query的结构体，便于排序 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]^be[b.l]?be[a.l]&lt;be[b.l]:(be[a.l]&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r;</span><br><span class="line">&#125;<span class="comment">//排序小优化 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;col[x]+=d;<span class="keyword">if</span>(d&gt;<span class="number">0</span>)ans+=(col[x]==<span class="number">1</span>);<span class="keyword">if</span>(d&lt;<span class="number">0</span>)ans-=(col[x]==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="comment">//d==1为增加，d==-1为减少 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);unit=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(a[i]),be[i]=i/unit+<span class="number">1</span>;<span class="comment">//分块 </span></span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        scan(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);<span class="comment">//排序 </span></span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(a[l],<span class="number">-1</span>),l++;<span class="comment">//减去l上这个数 </span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(a[l<span class="number">-1</span>],<span class="number">1</span>),l--;<span class="comment">//加上l-1上这个数 </span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(a[r+<span class="number">1</span>],<span class="number">1</span>),r++; </span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(a[r],<span class="number">-1</span>),r--;</span><br><span class="line">        prin[q[i].id]=ans;<span class="comment">//记录答案 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        print(prin[i]),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码至少过了这道题，但是仍然很悬，所以尽可能地优化常数</p><p>附上树状数组代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[maxn&lt;&lt;<span class="number">2</span>],a[maxn],cent,col[maxn*<span class="number">10</span>],pre[maxn*<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r,id,ans;&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;<span class="keyword">return</span> a.r==b.r?a.l&lt;b.l:a.r&lt;b.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(query a,query b)</span></span>&#123;<span class="keyword">return</span> a.id&lt;b.id;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x)) tree[x]+=d;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">while</span>(x) ans+=tree[x],x-=lowbit(x);<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(a[i]);</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        scan(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cent&lt;q[i].r)&#123;</span><br><span class="line">            add(++cent,<span class="number">1</span>);</span><br><span class="line">            col[a[cent]]++;</span><br><span class="line">            <span class="keyword">if</span>(col[a[cent]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                add(pre[a[cent]],<span class="number">-1</span>);</span><br><span class="line">                pre[a[cent]]=cent;</span><br><span class="line">                col[a[cent]]--;</span><br><span class="line">            &#125;<span class="keyword">else</span> pre[a[cent]]=cent;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].ans=ask(q[i].r)-ask(q[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        print(q[i].ans),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样应该可以去<a href="https://www.luogu.org/problem/SP3267" target="_blank" rel="noopener">水题</a>了，紫题，不用谢我；</p><h2 id="2-带修莫队："><a href="#2-带修莫队：" class="headerlink" title="2.带修莫队："></a><strong>2.带修莫队：</strong></h2><p>例题：<a href="https://www.luogu.org/problem/P1903" target="_blank" rel="noopener">P1903 [国家集训队]数颜色 / 维护队列</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令：</p><p>1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p><p>2、 R P Col 把第P支画笔替换为颜色Col。</p><p>为了满足墨墨的要求，你知道你需要干什么了吗？</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。</p><p>第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。</p><p>第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p><p>　　带修莫队其实没什么，只要查询是离线就别虚，只要加入一个时间指针t即可。</p><p>　　但是如果只是单纯的分块了话，可能时间会超，我们看一下分块块数unit，</p><p>　　当同l块时，移动需要n<em>unit，当l块之间r携带移动时需要(n^2)/unit，当时间 t 移动时仍然有 l 和 r 块的移动，所以需要 (n^2</em>t)/(unit^2)</p><p>　　时间复杂度时三个移动取最大值（因为省略常数），发现如果unit取sqrt（n）时，最坏时间复杂度为n^2，这不是我们所期望的，</p><p>　　将t看似为n那么整理第三个为(n^3)/(unit^2)，那么让两两相等，三种情况取最优，发现当unit=n^(2/3)时，时间复杂度最优，为O(n^(5/3))；</p><p>　　那么就可以看代码了。。。</p><p>　　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ri register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,col[maxn*<span class="number">100</span>],s[maxn],unit,be[maxn],T,l=<span class="number">1</span>,r;</span><br><span class="line"><span class="keyword">int</span> cent,t,ans[maxn],Ans,now[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,Time,id;</span><br><span class="line">&#125;q[maxn];<span class="comment">//查询数组 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">change</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> exfo,New,Old;</span><br><span class="line">&#125;c[maxn];<span class="comment">//change数组 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(be[a.l]!=be[b.l]) <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(be[a.r]!=be[b.r]) <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">    <span class="keyword">return</span> a.Time&lt;b.Time;</span><br><span class="line">&#125;<span class="comment">//不同的排序方式 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;col[x]+=d;<span class="keyword">if</span>(d&gt;<span class="number">0</span>)Ans+=(col[x]==<span class="number">1</span>);<span class="keyword">if</span>(d&lt;<span class="number">0</span>)Ans-=(col[x]==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spe</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;<span class="keyword">if</span>(l&lt;=x&amp;&amp;x&lt;=r) syst(d,<span class="number">1</span>),syst(s[x],<span class="number">-1</span>);s[x]=d;&#125;<span class="comment">//t指针移动方式 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m);unit=<span class="built_in">pow</span>(n,<span class="number">0.666666</span>);<span class="comment">//2/3=0.6666666，6越多越精确 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(s[i]),now[i]=s[i],be[i]=i/unit+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c %d%d"</span>,&amp;type,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="string">'Q'</span>) q[++cent]=(query)&#123;x,y,t,cent&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">'R'</span>) c[++t]=(change)&#123;x,y,now[x]&#125;,now[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+cent,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;    </span><br><span class="line">        <span class="keyword">while</span>(T&lt;q[i].Time) spe(c[T+<span class="number">1</span>].exfo,c[T+<span class="number">1</span>].New),T++;</span><br><span class="line">        <span class="keyword">while</span>(T&gt;q[i].Time) spe(c[T].exfo,c[T].Old),T--;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(s[l],<span class="number">-1</span>),l++;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(s[l<span class="number">-1</span>],<span class="number">1</span>),l--;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(s[r+<span class="number">1</span>],<span class="number">1</span>),r++;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(s[r],<span class="number">-1</span>),r--;</span><br><span class="line">        ans[q[i].id]=Ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-树上莫队："><a href="#3-树上莫队：" class="headerlink" title="3.树上莫队："></a><strong>3.树上莫队：</strong></h2><p>要说树上操作，那么莫队可以操作的有两种类型，第一种是子树统计，第二种是路径统计，那么让我们详细来看；</p><p>警告：前方有dfs序和euler序出现；</p><h3 id="1-子树统计"><a href="#1-子树统计" class="headerlink" title="1.子树统计"></a><strong>1.子树统计</strong></h3><p>　　这个如果只是一颗子树单纯的统计非常简单，只要一次dfs求出dfs序和子树size即可，你会发现子树上的dfs序时连续的，直接查询一段区间即可；</p><p>　　<img src="/images/15.png" alt="alt"></p><p>　　有点丑，不要介意，它的dfs序是1 2 3 7 9 4 6 5 8</p><p>　　　　2的子树序列即为 2 3 7 9；</p><p>　　这个应该不需要再解释了吧。。。</p><p>　　但是在两颗子树上统计再加上换根操作是不是很毒瘤，我们在后面会讲到；</p><h3 id="2-路径统计"><a href="#2-路径统计" class="headerlink" title="2.路径统计"></a>2.路径统计</h3><p>　　莫队只能维护序列，所以我们将子树转化为dfs序，将其从树中拿出，维护其序列，那么路径上怎么办呢</p><p>　　　　我们再拿出这个图（我知道很丑！）</p><p>　　　　<img src="/images/16.png" alt="alt"></p><p>　　　　不知道euler序？没关系，我解释就行了，euler序将一个数记录两遍，进的时候记录一遍，出的时候记录一遍；</p><p>　　　　我们将序列列出来就很清晰了 ： 1 2 3 7 7 9 9 3 4 4 2 6 5 5 8 8 6 1;</p><p>　　　　 那么每个数字都出现了两遍，我们设节点 i 在euler序中第一次出现的位置为first [ i ] ，第二次出现的位置为last [ i ] 。</p><p>　　　　观察路径2-&gt;9，你会发现路径上first [ 2 ] -&gt; fisrt [ 9 ]：2 3 7 7 9，其中路径上的点都只出现了一次，出现两次的都不在路径上，证明也很简单，这里就不再赘述。</p><p>　　　　当然last [ 2 ] -&gt; last [ 9 ]是一样的，只是顺序不一样。</p><p>　　　　但是这个只是一种情况——当两个点中有一个点是另一个点子树的一部分，或者问题转换一下一个点是另一个点的LCA，如刚刚的2是9的LCA。</p><p>　　　　但是当不在同一颗子树上会发生什么？</p><p>　　　　例如3 -&gt; 6：3 7 7 9 9 3 4 4 2 6 5 5 8 8 6，这是3和6出现两次时序列，我们已经发现没有1这个点，我们选取last [ 3 ] -&gt; first [ 6 ]  : 3 4 4 2 6，其中路径上的点3 2 6都出现</p><p>　　　　但是1却没有出现，我们可以发现1时LCA（3，6），所以euler序中在这种情况下是没有LCA的，那么我们在统计答案时将其加上，然后再减去。</p><p>　　　　两种情况都已经讨论完毕，我们只要在存q数组时做个lca的标记即可。</p><p>　　　　这里给出一道　　<strong>例题</strong>　　</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个n个节点的树，每个节点表示一个整数，问u到v的路径上有多少个不同的整数。</p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有两个整数n和m（n＝40000，m＝100000）。</p><p>第二行有n个整数。第i个整数表示第i个节点表示的整数。</p><p>在接下来的n-1行中，每行包含两个整数u v，描述一条边（u，v）。</p><p>在接下来的m行中，每一行包含两个整数u v，询问u到v的路径上有多少个不同的整数。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问，输出结果。</p><p> 　　　　</p><p>　　　　这是模板测试，只需要分类讨论，直接套莫队；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 40007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ls[maxn],euler[maxn&lt;&lt;<span class="number">1</span>],ans[N],cent,cnt,dep[maxn&lt;&lt;<span class="number">1</span>],num[maxn&lt;&lt;<span class="number">1</span>],l=<span class="number">1</span>,r,now;</span><br><span class="line"><span class="keyword">int</span> first[maxn&lt;&lt;<span class="number">1</span>],last[maxn&lt;&lt;<span class="number">1</span>],b[maxn],fa[maxn&lt;&lt;<span class="number">1</span>][<span class="number">30</span>],be[maxn&lt;&lt;<span class="number">1</span>],vis[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn&lt;&lt;<span class="number">1</span>],unit,col[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,id,lca;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    euler[++cnt]=x;first[x]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][<span class="number">0</span>]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dep[y]+=dep[x]+<span class="number">1</span>;fa[y][<span class="number">0</span>]=x;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">    euler[++cnt]=x;last[x]=cnt;</span><br><span class="line">&#125;<span class="comment">//在完成LCA初始化的同时完成euler序的记录 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">1</span>,fa[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">-1</span>;dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[k][i<span class="number">-1</span>]&lt;<span class="number">0</span>) fa[k][i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> fa[k][i]=fa[fa[k][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,d=dep[x]-dep[y];d;d&gt;&gt;=<span class="number">1</span>,i++)</span><br><span class="line">        <span class="keyword">if</span>(d&amp;<span class="number">1</span>) x=fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">25</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">            y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是倍增求LCA，当然也可以2遍dfs+树剖 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]^be[b.l]?be[a.l]&lt;be[b.l]:(be[a.l]&amp;<span class="number">1</span>?a.r&lt;b.r:a.r&gt;b.r); </span><br><span class="line">&#125;<span class="comment">//排序小优化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] ? now -= (!--num[ls[x]]):now += !num[ls[x]]++;</span><br><span class="line">    <span class="comment">//CASE 1 ：前者减去，而！是为了判断是否应该减取（true=1，false=0） </span></span><br><span class="line">    <span class="comment">//CASE 2 ：后者加上，！同上面所说 </span></span><br><span class="line">    vis[x] ^= <span class="number">1</span>;<span class="comment">//异或操作可以方便的转换出现次数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);unit=<span class="built_in">sqrt</span>(<span class="number">2</span>*n);<span class="comment">//记住euler序是2*n </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ls[i]),b[i]=ls[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> tot=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ls[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+tot,ls[i])-b;</span><br><span class="line">    <span class="comment">//由于数值太大，我们进行离散化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b),add(a,b);</span><br><span class="line">    init();<span class="comment">//初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) be[i]=i/unit+<span class="number">1</span>;<span class="comment">//分块 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,L,R;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;L,&amp;R);</span><br><span class="line">        <span class="keyword">int</span> lca=getlca(L,R);q[i].id=i;</span><br><span class="line">        <span class="keyword">if</span>(first[L]&gt;first[R]) swap(L,R);<span class="comment">//小的在前面哦 </span></span><br><span class="line">        <span class="keyword">if</span>(lca==L)&#123;<span class="comment">//CASE 1 ： </span></span><br><span class="line">            q[i].l=first[L];</span><br><span class="line">            q[i].r=first[R];</span><br><span class="line">            q[i].lca=<span class="number">0</span>;<span class="comment">//不需要考虑LCA </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//CASE 2 ： </span></span><br><span class="line">            q[i].l=last[L];</span><br><span class="line">            q[i].r=first[R];</span><br><span class="line">            q[i].lca=lca;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=q[i].lca;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(euler[l]),l++;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(euler[l<span class="number">-1</span>]),l--;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(euler[r+<span class="number">1</span>]),r++;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(euler[r]),r--;</span><br><span class="line">        <span class="keyword">if</span>(lca) syst(lca);<span class="comment">//判断是否需要考虑LCA </span></span><br><span class="line">        ans[q[i].id]=now;</span><br><span class="line">        <span class="keyword">if</span>(lca) syst(lca);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您已经AC了这几道题，恭喜您已经大概掌握莫队的框架。（这几道题不是小意思嘛，博主太菜了）</p><p>由于博主太菜，还没有学回滚莫队，所以这里先不再说（逃ε=ε=ε=┏(゜ロ゜;)┛）</p><p>不过这里再留下一道模板题，<a href="https://www.luogu.org/problem/P4074" target="_blank" rel="noopener">糖果公园</a>——带修树上莫队，两种算法相结合，不要虚，虽然是黑题</p><p>这里不再附上代码，请原谅。。。</p><p><strong>拓展提升</strong></p><h2 id="4-双指针莫队"><a href="#4-双指针莫队" class="headerlink" title="4.双指针莫队"></a><strong>4.双指针莫队</strong></h2><p>　　其实这才是莫队的本质，虽然带修莫队是三指针，但是别忘了其时间复杂度还是很难让人接受的（尤其是常数巨大的博主），所以我们还是用双指针的比较多。</p><p>　　我们以上看到的莫队是一个区间的查询，一个指针维护l，一个指针维护r，然后再用分块排序；</p><p>　　但是当我们遇见了两个区间怎么办？比如说这道题<a href="https://www.luogu.org/problem/P5268" target="_blank" rel="noopener">P5268 [SNOI2017]一个简单的询问</a>，请读者不要被其吓住，这其实只有一个普通莫队的难度，只是需要从原来的思维跳出来</p><p>　　真正理解莫队双指针的作用。</p><p> <img src="/images/17.png" alt="alt"></p><p>　　设该函数为f( l1 , r1 , l2 , r2)，那么可以拆成f（ 1  , l1-1 , 1 , l2-1 ) + f ( 1 , r1, 1 , r2 ) - f (1 , l1-1 , 1 , r2) - f ( 1 , l2 - 1 , 1 , r2 )；</p><p>　　这里用到了容斥原理，将区间容斥，那么我们就可以引用莫队，维护两个变量，双指针移动，分块排序（博主太唠叨了）</p><p>　　这里附上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],be[maxn],unit,ans[maxn],ol,all;</span><br><span class="line"><span class="keyword">int</span> t[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d,id;</span><br><span class="line">&#125;q[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]==be[b.l]?a.r&lt;b.r:be[a.l]&lt;be[b.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    ol+=t[a[x]][type^<span class="number">1</span>];</span><br><span class="line">    t[a[x]][type]++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    ol-=t[a[x]][type^<span class="number">1</span>];</span><br><span class="line">    t[a[x]][type]--;</span><br><span class="line">&#125;<span class="comment">//简单的操作 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);unit=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]),be[i]=(i<span class="number">-1</span>)/unit+<span class="number">1</span>;</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l1,r1,l2,r2;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(l1),scan(r1),scan(l2),scan(r2);</span><br><span class="line">        q[++all].l=r1,q[all].r=r2,q[all].d=<span class="number">1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l2<span class="number">-1</span>,q[all].r=r1,q[all].d=<span class="number">-1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l1<span class="number">-1</span>,q[all].r=r2,q[all].d=<span class="number">-1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l1<span class="number">-1</span>,q[all].r=l2<span class="number">-1</span>,q[all].d=<span class="number">1</span>,q[all].id=i;</span><br><span class="line">    &#125;<span class="comment">//拆成四个询问 ，id一样 </span></span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+all,cmp);<span class="comment">//排序是一样的 </span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) add(++l,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) del(l--,<span class="number">0</span>);<span class="comment">//两个指针要分开标记用1和0即可（可以异或） </span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) add(++r,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) del(r--,<span class="number">1</span>);</span><br><span class="line">        ans[q[i].id]+=ol*q[i].d;<span class="comment">// 4个询问最后会累加在一起 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;莫队思想浅谈&quot;&gt;&lt;a href=&quot;#莫队思想浅谈&quot; class=&quot;headerlink&quot; title=&quot;莫队思想浅谈&quot;&gt;&lt;/a&gt;莫队思想浅谈&lt;/h1&gt;&lt;p&gt;莫队，基于分块思想。&lt;/p&gt;&lt;p&gt;所以说，在学习莫队时可以先了解一下分块的优化原理，这对于莫队的理解会有帮助；&lt;/p&gt;&lt;p&gt;我们将分层次讲解，难度不断增加，并附有例题。。。（由于博主太烂懒，所以莫队的模板概念知识只会在这里叙述）&lt;/p&gt;&lt;h2 id=&quot;1-莫队：&quot;&gt;&lt;a href=&quot;#1-莫队：&quot; class=&quot;headerlink&quot; title=&quot;1.莫队：&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.莫队：&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　基础的莫队是用来解决区间离线查询问题，利用分块原理和排序，将查询时的重叠部分集中以来优化的算法，大多的算法的复杂度为$O(nsqrt(n))$，实际更优；&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="http://leceue.github.io./tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Guass初步</title>
    <link href="http://leceue.github.io./2019/10/25/Guass/"/>
    <id>http://leceue.github.io./2019/10/25/Guass/</id>
    <published>2019-10-25T08:18:46.000Z</published>
    <updated>2019-10-25T13:16:05.442Z</updated>
    
    <content type="html"><![CDATA[<p>Gauss算法，称为高斯消元算法，用来解决n元一次方程，在解决线性方程问题起着重要作用。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h2><p>　　运用高斯消元的方法，我们可以在O(n3)的时间求出n元线性方程，但是由于时间复杂度的原因，请注意题目数据范围的提示。</p><p>　　<strong>高斯消元三大定理（在小学就学过了吧）：</strong></p><p>　　　　1.两个方程互换位置，解不变；</p><p>　　　　2.一个方程进行加减乘除，解不变；</p><a id="more"></a><p>　　　　3.一个方程乘上数k加上另一个方程，解不变；</p><p>　　这便是我们解决的基础；</p><h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a><strong>过程：</strong></h2><p>　　这里给出<a href="https://www.luogu.org/problem/P3389" target="_blank" rel="noopener">luogu例题链接</a>，这样方便寻找；</p><p>　　我们这里不用luogu的样例示范（因为不是整数好麻烦），这里给出方程</p><p>　　2 x + 3 y - z = 21;</p><p>　　x + 2 y + 2 z = 7;</p><p>　  3 x + y + 5 z = 8;　</p><p>　　我们将系数提出，然后就可以得到一个3 * 3的矩阵，之后将每个方程等号右边放到矩阵的最右边，就得到了：</p><p>　　<img src="/images/18.png" alt="alt"></p><p>　　这里每个方程的结果与系数我用黑线隔开了，想必也更清楚；</p><p>　　有了定理，我们理一下目标：</p><p>　　我们如果将每一个方程只留下一个未知数的系数，那么最后就可以求解了，如：</p><p>　　<img src="/images/19.png" alt="alt"></p><p>　　当然系数不一定只会是1，但是只要除一下就好，根据这个定义，我们将第 i 个未知数的前系数非零而且其他系数都为零，这个系数在矩阵的位置为 i ，i；</p><p>　　这样的矩阵称为“简化阶梯矩阵”；</p><p>　　我们只要将每个矩阵化成简化阶梯矩阵即可；</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h2><p>　　1.枚举第 i 个未知数（外循坏）；</p><p>　　2.决定在哪一行求解这个未知数：</p><p>　　　　这里采用先对每一行 j 第 i 个系数找到最大值，有最大值的这一行定义为第ms行（名字随便起的，没有其他意思），然后将第ms行交换至第 i 行</p><p>　　3.判断第i行第i个数的值是否为0，这里由于数学期望和精度问题，我们将这个判断改为这个数的值是否小于我们定义的那个精度，如果小于（那就相当于为0了），</p><p>　　　　那么无解（因为这个项的系数是所有中最大的，所以其他的也都为0，一定无解）；</p><p>　　4.然后进行消元，就是将其他方程这个项的系数归0，这里有精度问题，但是从期望来讲，是不成问题的；</p><h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a><strong>Code：</strong></h2><p>　　（我才不会说其实我有模拟操作但是太麻烦不想写了。。。）</p><p>　　不过我很良心，所以我有输出模拟，运行一下我的代码就行了；</p><p>　　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> db cmp=<span class="number">1e-8</span>;</span><br><span class="line">db a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟啦 biu~</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"work %d \n"</span>,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ms=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt;<span class="built_in">fabs</span>(a[ms][i]))</span><br><span class="line">                ms=j;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[ms][i])&lt;cmp)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            swap(a[i][j],a[ms][j]);</span><br><span class="line">        biu(<span class="number">2</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">            db rate=a[j][i]/a[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)</span><br><span class="line">                a[j][k]-=a[i][k]*rate;</span><br><span class="line">        &#125;</span><br><span class="line">        biu(<span class="number">4</span>);<span class="comment">//良心模拟。。。 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,a[i][n+<span class="number">1</span>]/a[i][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong>例题</strong></h2><p>　　<a href="https://www.luogu.org/problem/P4035" target="_blank" rel="noopener">P4035 [JSOI2008]球形空间产生器</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个球形空间产生器能够在 nnn 维空间中产生一个坚硬的球体。现在，你被困在了这个 nnn 维球体中，你只知道球面上 n+1n+1n+1 个点的坐标，你需要以最快的速度确定这个 nnn 维球体的球心坐标，以便于摧毁这个球形空间产生器。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数 nnn (1&lt;=N=10)(1&lt;=N=10)(1&lt;=N=10)。接下来的 n+1n+1n+1 行，每行有 nnn 个实数，表示球面上一点的 nnn 维坐标。每一个实数精确到小数点后 666 位，且其绝对值都不超过 200002000020000。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>有且只有一行，依次给出球心的 nnn 维坐标（ nnn 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 333 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。</p><p>　　这个只要构造出矩阵即可；</p><p>　　可惜我不会在博客上用数学公式。。。</p><p>　　所以就随便写写了；</p><p>　　设xi为第i维的坐标；</p><p>　　sum(j=1,n) { (a[ i , j ] - x [ j ]) }=r^2;</p><p>　　这样的方程共有11个，我们要将r消掉，所以将相邻的两个方程相减，得到11个方程，然后将多项式拆开，合并，移项得到；</p><p>　　sum(j=1,n){ 2<em>(a[ i , j ] - a[ i + 1 , j ) </em> x [ j ] } = sum(j=1,n){ a[ i , j ] - a[ i + 1 , j ] };</p><p>　　这样就可以将左边的作为方程左边，右边作为结果，列出矩阵，这里还不需要检验，直接上代码。。。</p><p>　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">db a[<span class="number">17</span>][<span class="number">17</span>],c[<span class="number">17</span>][<span class="number">17</span>];</span><br><span class="line"><span class="keyword">const</span> db cmp=<span class="number">1e-8</span>;</span><br><span class="line"><span class="function">db <span class="title">calc</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            c[i<span class="number">-1</span>][j]=<span class="number">2</span>*(a[i<span class="number">-1</span>][j]-a[i][j]);</span><br><span class="line">            c[i<span class="number">-1</span>][n+<span class="number">1</span>]+=calc(a[i<span class="number">-1</span>][j])-calc(a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ms=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(c[j][i])&gt;<span class="built_in">fabs</span>(c[ms][i])) ms=j;</span><br><span class="line">        <span class="keyword">if</span>(ms!=i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            swap(c[i][j],c[ms][j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            db rate=c[j][i]/c[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)</span><br><span class="line">                c[j][k]-=c[i][k]*rate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%.3f "</span>,c[i][n+<span class="number">1</span>]/c[i][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还有一些拓展内容，到时候再补充。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gauss算法，称为高斯消元算法，用来解决n元一次方程，在解决线性方程问题起着重要作用。&lt;/p&gt;&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　运用高斯消元的方法，我们可以在O(n3)的时间求出n元线性方程，但是由于时间复杂度的原因，请注意题目数据范围的提示。&lt;/p&gt;&lt;p&gt;　　&lt;strong&gt;高斯消元三大定理（在小学就学过了吧）：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　　　1.两个方程互换位置，解不变；&lt;/p&gt;&lt;p&gt;　　　　2.一个方程进行加减乘除，解不变；&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数论" scheme="http://leceue.github.io./tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>manacher</title>
    <link href="http://leceue.github.io./2019/10/25/manacher/"/>
    <id>http://leceue.github.io./2019/10/25/manacher/</id>
    <published>2019-10-25T08:18:22.000Z</published>
    <updated>2019-10-25T13:16:23.332Z</updated>
    
    <content type="html"><![CDATA[<p>manacher算法的由来不再赘述，自行百度QWQ。。。</p><p>进入正题，manacher算法是一个高效的计算回文串的算法，回文串如果不知道可以给出一个例子：“ noon ”，这样应该就很清晰了；</p><p>其实这个算法虽然名字长，但是实际代码很短，而且理解起来并不难。。。（连我这种蒟蒻都懂了）</p><p>这里给出<a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">模板题</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.</p><a id="more"></a><p>字符串长度为n</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一行小写英文字符a,b,c…y,z组成的字符串S</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数表示答案</p><p>　　其中n的范围为11000000，很显然，只能是$O(n)$的复杂度，但是为何复杂度这么优秀，这里在讲完算法之后会简述。</p><p><strong>定理：</strong></p><ul><li>　　一个回文串只有一个对称中心，这个中心上可能有字母或者没有（如果没有字母，我们可以再加上一个，再后面会解释），我们暂且定义其为mid；</li><li>　　mid两端的区间对称，两边全等（回文串的定义）；</li><li>　　如果一个大的回文串一端的区间中有回文串，我们先定义它的中心为 i ，那么大回文串的另一端一定会有相同的回文串；</li><li>　　根据上一条，如果我们要更新在右端区间的回文串，那么在左边的回文串半径就可以更新右边的，但是有大回文串的区间限制，所以应当两者取min；</li><li>　　结束上面定理的继承之后，直接暴力枚举检查是否两端更新。</li></ul><p><strong>解释：</strong></p><p>　　上面的原理毕竟太过干，只是纯理论，所以制图说明；</p><p>　　<img src="/images/14.png" alt="alt"></p><p>　　比如说这个区间是一个大回文串，我们我们用r保留其有边界，那么l就可以根据中点坐标公式变形得到mid*2 - r，所以我们只保留右边界 r 即可。</p><p>　　那么可以看见，如果我们以 i 为这段区间中一个回文串的中心，那么，与它对称的回文串中心就可以求出（根据中点公式，得2*mid - i ，与上面相同）；</p><p>　　那么我们就可以根据定理来继承左边回文串的半径，但是如果左边这个回文串有超过区间的部分怎么办？</p><p>　　这里就用到我们所说的取min了，将左边回文串半径和r - i相比取min，这里就得到了 i 的一个半径，但这个半径一定小于或等于真实半径，所以还需暴力枚举；</p><p>　　这里就可见manachar算法的核心操作了，就是枚举回文串中心，然后继承半径以来减少枚举的次数；</p><p>　　我们用p[ i ]表示以点 i 为中心的回文串的半径，r记录回文串到达的最右边的坐标，mid随之更新，记录这个回文串的中心；</p><p><strong>Code</strong></p><p>　　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 22000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> dat[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn],r,cnt=<span class="number">1</span>,mid,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s=getchar();</span><br><span class="line">    dat[<span class="number">0</span>]=<span class="string">'~'</span>;<span class="comment">//为了不超出边界的小操作 </span></span><br><span class="line">    dat[<span class="number">1</span>]=<span class="string">'|'</span>;<span class="comment">//这个间隔解决了对称中心没有字母的情况 </span></span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'a'</span>&amp;&amp;s&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">        dat[++cnt]=s;</span><br><span class="line">        dat[++cnt]=<span class="string">'|'</span>;</span><br><span class="line">        s=getchar();</span><br><span class="line">    &#125;<span class="comment">//其实与读入优化没差啦 </span></span><br><span class="line">&#125;<span class="comment">//自定义读入 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;i) p[i]=min(p[<span class="number">2</span>*mid-i],r-i);<span class="comment">//由对称的回文串继承，用r-i限制 </span></span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">1</span>;<span class="comment">//CASE ：无法继承 </span></span><br><span class="line">        <span class="keyword">while</span>(dat[i-p[i]]==dat[i+p[i]]) p[i]++;<span class="comment">//暴力更新 </span></span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;r) r=p[i]+i,mid=i;<span class="comment">// r边界必须是最右 </span></span><br><span class="line">        ans=max(ans,p[i]);<span class="comment">//更新答案 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans<span class="number">-1</span>);<span class="comment">//这个减一可以自己模拟一下，数学推了话好麻烦的说 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是manachar算法的简述了，当然这里解释一下为什么复杂度为O（n）：</p><p>　　我感觉这和KMP复杂度有些类似，因为这里因为继承的缘故，所以每个点更新次数较少，然后均摊到每个循环，那么复杂度就变成了$O(n)$了；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;manacher算法的由来不再赘述，自行百度QWQ。。。&lt;/p&gt;&lt;p&gt;进入正题，manacher算法是一个高效的计算回文串的算法，回文串如果不知道可以给出一个例子：“ noon ”，这样应该就很清晰了；&lt;/p&gt;&lt;p&gt;其实这个算法虽然名字长，但是实际代码很短，而且理解起来并不难。。。（连我这种蒟蒻都懂了）&lt;/p&gt;&lt;p&gt;这里给出&lt;a href=&quot;https://www.luogu.org/problem/P3805&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模板题&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="字符串" scheme="http://leceue.github.io./tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="http://leceue.github.io./2019/10/25/AC-automata/"/>
    <id>http://leceue.github.io./2019/10/25/AC-automata/</id>
    <published>2019-10-25T08:18:02.000Z</published>
    <updated>2019-10-25T13:15:32.357Z</updated>
    
    <content type="html"><![CDATA[<p>先存代码</p><h2 id="AC自动机（简单版）"><a href="#AC自动机（简单版）" class="headerlink" title="AC自动机（简单版）"></a>AC自动机（简单版）</h2><p>　　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> tr[maxn][<span class="number">28</span>],val[maxn],cnt,fail[maxn];</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;</span><br><span class="line">&#125;<span class="comment">//建树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);<span class="comment">//26个字母跑 </span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);<span class="comment">//调取指针 </span></span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];<span class="comment">//建立“虚边”——指向失配指针的i边</span></span><br><span class="line">            <span class="comment">//这里已经改变了trie图 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ol=<span class="number">0</span>,u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)&#123;</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=u;j&amp;&amp;val[j]!=<span class="number">-1</span>;j=fail[j])</span><br><span class="line">            ol+=val[j],val[j]=<span class="number">-1</span>;<span class="comment">//fail跳（这样其实很慢） </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("co.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod),build(mod);</span><br><span class="line">    AC();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);ans=query(tx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="AC自动机（加强版）"><a href="#AC自动机（加强版）" class="headerlink" title="AC自动机（加强版）"></a>AC自动机（加强版）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,ans;</span><br><span class="line"><span class="keyword">char</span> mod[maxn][<span class="number">100</span>],tx[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC&#123;</span><br><span class="line">    <span class="keyword">int</span> tr[maxn][<span class="number">27</span>],fail[maxn],tot;</span><br><span class="line">    <span class="keyword">int</span> cnt,val[maxn],num[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span>(tr));</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(fail,<span class="number">0</span>,<span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">        cnt=ans=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tr[now][s[i]-<span class="string">'a'</span>]) tr[now][s[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">            now=tr[now][s[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[now]=id;<span class="comment">//记录id，这个不怕覆盖 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">                <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),<span class="built_in">cerr</span>&lt;&lt;fail[tr[u][i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)&#123;</span><br><span class="line">            u=tr[u][t[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=u;j;j=fail[j])</span><br><span class="line">                <span class="keyword">if</span>(val[j]) num[val[j]]++,ans=max(ans,num[val[j]]);</span><br><span class="line">        &#125;<span class="comment">//还是跳，不过记录的不一样而已 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(ans==num[i]) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,mod[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        AC::Init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod[i]),AC::insert(mod[i],i);</span><br><span class="line">        AC::build();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);</span><br><span class="line">        AC::query(tx);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC自动机（二次加强版）"><a href="#AC自动机（二次加强版）" class="headerlink" title="AC自动机（二次加强版）"></a>AC自动机（二次加强版）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn];</span><br><span class="line"><span class="keyword">int</span> fail[maxn],tr[maxn][<span class="number">27</span>],val[maxn],num[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn],cnt,in[maxn],to[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;id[idx]=now;<span class="comment">//记录 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),in[fail[tr[u][i]]]++;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>],num[u]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v=fail[u];q.pop();</span><br><span class="line">        num[v]+=num[u];--in[v];</span><br><span class="line">        <span class="keyword">if</span>(!(in[v])) q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这里是跟题解学的topu,效率也挺高 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod),insert(mod,i);</span><br><span class="line">    build();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);query(tx);</span><br><span class="line">    topu(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num[id[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> fail[maxn],tr[maxn][<span class="number">28</span>],val[maxn],num[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn],cnt,in[maxn],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;id[idx]=now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),in[fail[tr[u][i]]]++;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>],num[u]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v=fail[u];q.pop();</span><br><span class="line">        num[v]+=num[u];--in[v];</span><br><span class="line">        <span class="keyword">if</span>(!(in[v])) q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(a),len2=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len1;i&lt;len1+len2;i++)</span><br><span class="line">        a[i]=b[i-len1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c),work(mod,c),</span><br><span class="line">        tot=<span class="built_in">strlen</span>(mod),insert(c,i),mod[tot++]=<span class="string">'&#123;'</span>;</span><br><span class="line">    build();</span><br><span class="line">    query(mod);topu();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num[id[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先存代码&lt;/p&gt;&lt;h2 id=&quot;AC自动机（简单版）&quot;&gt;&lt;a href=&quot;#AC自动机（简单版）&quot; class=&quot;headerlink&quot; title=&quot;AC自动机（简单版）&quot;&gt;&lt;/a&gt;AC自动机（简单版）&lt;/h2&gt;&lt;p&gt;　　&lt;/p&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; maxn 1000007&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tr[maxn][&lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;],val[maxn],cnt,fail[maxn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; mod[maxn],tx[maxn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;gt;q;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *a)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; now=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;a[i];i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!tr[now][a[i]-&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;]) tr[now][a[i]-&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;]=++cnt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        now=tr[now][a[i]-&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val[now]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;//建树 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AC&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;;i++) &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(tr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][i]) q.push(tr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][i]);&lt;span class=&quot;comment&quot;&gt;//26个字母跑 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!q.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; u=q.front();q.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);&lt;span class=&quot;comment&quot;&gt;//调取指针 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; tr[u][i]=tr[fail[u]][i];&lt;span class=&quot;comment&quot;&gt;//建立“虚边”——指向失配指针的i边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//这里已经改变了trie图 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *t)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ol=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,u=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;t[i];i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        u=tr[u][t[i]-&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=u;j&amp;amp;&amp;amp;val[j]!=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;j=fail[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ol+=val[j],val[j]=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//fail跳（这样其实很慢） &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ol;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//    freopen(&quot;cin.in&quot;,&quot;r&quot;,stdin);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//    freopen(&quot;co.out&quot;,&quot;w&quot;,stdout);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s&quot;&lt;/span&gt;,mod),build(mod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s&quot;&lt;/span&gt;,tx);ans=query(tx);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,ans);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="字符串" scheme="http://leceue.github.io./tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>math collect</title>
    <link href="http://leceue.github.io./2019/10/25/math-collect/"/>
    <id>http://leceue.github.io./2019/10/25/math-collect/</id>
    <published>2019-10-25T08:00:59.000Z</published>
    <updated>2019-10-25T13:16:31.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EXGCD"><a href="#EXGCD" class="headerlink" title="EXGCD"></a>EXGCD</h2><p>　　我们在遇见不定方程的时候，总会一筹莫展，但是EXGCD为我们提供了方法，如同</p><p>　　$ a x + b y = c $   </p><p>　　那么我们先从这个这个式子出发：</p><p>　　$ax+by=gcd(a,b)$ 　　 $(1)$</p><p>　　我们不妨设出另一个式子</p><p>　　$ b x_{0}+(a \% b)y_{0}=gcd(b,a \% b)$ 　　 $(2)$</p><a id="more"></a><p>　　Because $gcd(a,b)= gcd ( b , a \% b ) $ ,thus:</p><p>　　(a x+b y=bx_{0}+a \% b y_{0})</p><p>　　(a x+b y=bx_{0} +(x-a/b \times y_{0}))</p><p>　　(a x+b y=ay_{0} +b(x-a/b \times y_{0}))</p><p>　　根据乘法等式，相对应系数的未知数相等，那么就可以得到：</p><p>　　$x=y_{0}　　y=x-a/b*y_{0}$　　</p><p> 　　那么在求gcd的过程中，我们可以在其中不断求解，但是递归到底时返回的x，y值是多少？</p><p>　　我们令在b=0时，带入（1）式，那么得到</p><p>　　$ax = a$,我们令x=1,y=0即可。</p><p>　　然后思考如何求解一开始的那个式子：</p><p>　　若有$ax+by=c$，则设$ax_{0}+by_{0}=c$,</p><p>　　两式相减：$a(x-x_{0})+b(y-y_{0})=0$</p><p>　　移项，除以gcd(a,b):$\frac{a}{gcd(a,b)}(x-x_{0})= - \frac{b}{gcd(a,b)}(y-y_{0})$</p><p>　　因为$gcd(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1$</p><p>　　所以$\frac{b}{gcd(a,b)}$可以整除$(x-x_{0})$</p><p>　　即 $\frac{b}{gcd(a,b)} \times t=(x-x_{0}), t \in Z$</p><p>　　对于任意x，都可以表示为</p><p>　　$x=x_{0}+\frac{b}{gcd(a,b)}$</p><p>　　那么根据exgcd求出的特解且$t \in Z$，我们可以这样求出最小解：</p><p>　　$x_{min}=x \%(\frac{b}{gcd(a,b)})$</p><p>　　在代码中的写法可以是</p><p>　　</p><p>　mod=b/gcd(a,b),ans=(x%mod+mod)%mod</p><p>　　那么这样我们就解决了$ax+by=gcd(a,b)$最小解问题。</p><p>　　如果是$ax+bx=c$，只需要两边乘上$\frac{c}{gcd(a,b)}$即可；</p><p> 　　这里附上 <a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">例题</a> </p><p>　　并给出模板Code：</p><p>　　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,L,t1,t2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="comment">//更新特解 </span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> t=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=t-(a/b)*y;<span class="comment">//公式迭代 </span></span><br><span class="line">    <span class="keyword">return</span>  d;<span class="comment">//return gcd  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;t1,&amp;t2,&amp;n,&amp;m,&amp;L);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;n) swap(m,n),swap(t1,t2);<span class="comment">//由于exgcd函数默认a，b为正整数，所以要换一下 </span></span><br><span class="line">    <span class="keyword">int</span> gcd=exgcd(m-n,L,x,y);</span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;x*((t1-t2)/gcd)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">if</span>((t1-t2)%gcd!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>); <span class="comment">//根据推论，应当满足等式两端成立 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(<span class="number">1l</span>l*x*((t1-t2)/gcd)%(L/gcd)+L/gcd)%(L/gcd));<span class="comment">//正负处理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><p>　　这里给出定理的内容，我大概描述一下：</p><p>　　对于$a,b$两个整数,且$gcd(a,b)=d$，那么对于任意的$x,y ,ax+by$是d的倍数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;EXGCD&quot;&gt;&lt;a href=&quot;#EXGCD&quot; class=&quot;headerlink&quot; title=&quot;EXGCD&quot;&gt;&lt;/a&gt;EXGCD&lt;/h2&gt;&lt;p&gt;　　我们在遇见不定方程的时候，总会一筹莫展，但是EXGCD为我们提供了方法，如同&lt;/p&gt;&lt;p&gt;　　$ a x + b y = c $   &lt;/p&gt;&lt;p&gt;　　那么我们先从这个这个式子出发：&lt;/p&gt;&lt;p&gt;　　$ax+by=gcd(a,b)$ 　　 $(1)$&lt;/p&gt;&lt;p&gt;　　我们不妨设出另一个式子&lt;/p&gt;&lt;p&gt;　　$ b x_{0}+(a \% b)y_{0}=gcd(b,a \% b)$ 　　 $(2)$&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数论" scheme="http://leceue.github.io./tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>euler</title>
    <link href="http://leceue.github.io./2019/10/25/euler/"/>
    <id>http://leceue.github.io./2019/10/25/euler/</id>
    <published>2019-10-25T08:00:39.000Z</published>
    <updated>2019-10-25T13:15:53.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="euler函数"><a href="#euler函数" class="headerlink" title="euler函数"></a>euler函数</h2><p>euler函数是表示从1~n中与n互质的个数，互质的定义简单提一下，$gcd(a,b)=1$。</p><p>那么如何求一个数的euler函数？</p><p>我们可以将每个数与n求gcd一下，如果gcd为1，则贡献加1，时间复杂度为 $O(n logn)$，极其优秀（雾）</p><p>那么来思考更加优秀的算法（为什么一定要求euler函数($\varphi(n)$函数)呢QAQ）</p><a id="more"></a><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><p>在算法基本定理中，$N=p1^{c1}<em>p2^{c2}</em>p3^{c3}…$，其中pi为质因数，那么：</p><script type="math/tex; mode=display">\varphi(N)=N*\frac{p1-1}{p1}*\frac{p2-1}{p2}...=\frac{pn-1}{pn}=N*\prod_{p|n} \frac{p-1}{p}</script><p>简单证明：</p><p>设p是N的质因子，那么显然p的倍数与N不互质，这些数分别是$p<em>1,p</em>2…p*N/p$，</p><p>显然有N/p个，那么我们可以减去这N/p个。设q是N的质因子，那么同理，q的倍数的个数有N/q个，那么在这N/p和N/q个当中有同时是p和q的倍数的，而我们多减了一次，我们容斥一下可以得到：</p><script type="math/tex; mode=display">\varphi(N)=N-N/p-N/q+N/pq=N*(q-1)/q*(p-1)/p</script><p>那么推广到全部即可；</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们可以枚举其质因数，不用素数筛，当中我们可以直接用自然数筛，将N中所有的该数倍数筛掉，那么之后的合数必然是之前质因数的组合乘积，但是我们已经筛掉，所以不可能筛到合数，并且我们只用筛到$\sqrt{n}$即可，这个证明较简单，不再赘述。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,lim,ans;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">lim=sqrt(n),ans=n;</span><br><span class="line">for(int i=2;i&lt;=lim;i++)</span><br><span class="line">if(!(n%i))&#123;</span><br><span class="line">ans=ans/i*(i-1);</span><br><span class="line">while(!(n%i)) n/=i;</span><br><span class="line">&#125;</span><br><span class="line">if(n&gt;1) ans=ans/n*(n-1);//质因数大于sqrt(n) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><p>1.如果n&gt;1，1~n中与n互质的数的和为$n*\varphi(n)/2$</p></blockquote><p>简单证明：</p><p>根据更相减损术可得，$gcd(a,b)=gcd(a,a-b)$，那么与n互质的数成对出现，则平均数为n/2，那么易得到结论；</p><p>2.如果a,b互质,$\varphi(ab)=\varphi(a)\varphi(b)$</p><p>简单证明：</p><p>根据euler函数的计算公式可得：</p><script type="math/tex; mode=display">\varphi(ab)=ab*\prod_{p|ab}(p-1)/p=a*\prod_{p|a}(p-1)/p *b*\prod_{p|b}(p-1)/p=\varphi(a)*\varphi{b}</script><p>==定义：满足性质2的为积性函数==</p><p>3.如果$f(n)$为积性函数，$n=\prod_{i=1}^{m}p_{i}^{c_{i}}$，那么$f(n)=\prod_{i=1}^{m}f(pi^{c_{i}})$</p><p>简单证明：</p><p>类比积性函数的定义和定义式可以得到</p><p>4.设p为质数,p|n且$p^{2}|n$,那么$\varphi(n)=varphi(n/p)*p$</p><p>简单证明:</p><p>这个就很好证了,显然p和n/p的质因数相同,那么定义式中只有N是不同的,那么拆开再合并定义式就可以得到结论;</p><p>5.设p为质数,p|n但$p^{2}\not\mid n$,那么$\varphi(n)=\varphi(n/p)*(p-1)$</p><p>简单证明:</p><p>显然,p与n/p互质,那么根据积性函数$\varphi(n)=\varphi(n/p)*\varphi(p)$,当中$\varphi(p)=p-1$(因为p是质数),那么结论显然;</p><p>==以上性质4,5可以用来线性求euler函数,在后面会提到==</p><p>6.$\sum_{d|n}\varphi(d)=n$</p><p>证明忽略(雾</p><h3 id="euler函数的线性筛法"><a href="#euler函数的线性筛法" class="headerlink" title="euler函数的线性筛法"></a>euler函数的线性筛法</h3><p>如果要求1~n的euler函数,那么如何求解?</p><p>暴力解法,对每一个数进行求解,那么可以得到一个$O(n\sqrt{n})$的算法;</p><p>如何更优?</p><p>运用性质4,5即可,在素数筛的过程中进行性质4,5的判断,然后统计;</p><h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100008</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,prim[maxn],vis[maxn],euler[maxn],m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">vis[i]=i;prim[++m]=i;</span><br><span class="line">euler[i]=i<span class="number">-1</span>;<span class="comment">//这个很好理解 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(prim[j]&gt;vis[i]||prim[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">vis[prim[j]*i]=prim[j];</span><br><span class="line"><span class="comment">//素数筛 </span></span><br><span class="line">euler[prim[j]*i]=euler[prim[j]]*(i%prim[j]?(prim[j]<span class="number">-1</span>):(prim[j]));</span><br><span class="line"><span class="comment">//性质4,5的判断 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><h5 id="简述"><a href="#简述" class="headerlink" title="简述:"></a>简述:</h5><script type="math/tex; mode=display">gcd(a,b)=1,a^{\varphi(b)}\equiv1(\mod b)</script><p>证明略(不会(雾</p><h4 id="拓展欧拉定理"><a href="#拓展欧拉定理" class="headerlink" title="拓展欧拉定理"></a>拓展欧拉定理</h4><h5 id="简述-1"><a href="#简述-1" class="headerlink" title="简述;"></a>简述;</h5><p>$gcd(a,n)=1,则a^{b}\equiv a^{b\% \varphi(n)}(mod n)$    </p><p>简单证明:</p><p>设$b=p*\varphi(n)+r$,那么$r= b(mod \varphi(n))$,由欧拉定理可得:</p><script type="math/tex; mode=display">a^{b}=a^{p*\varphi(n)+r}=(a^{\varphi(n)})^p*a^{r} \equiv 1^{p}*a^{r} \equiv a^{r} \equiv a^{b \%\ \varphi(n)}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;euler函数&quot;&gt;&lt;a href=&quot;#euler函数&quot; class=&quot;headerlink&quot; title=&quot;euler函数&quot;&gt;&lt;/a&gt;euler函数&lt;/h2&gt;&lt;p&gt;euler函数是表示从1~n中与n互质的个数，互质的定义简单提一下，$gcd(a,b)=1$。&lt;/p&gt;&lt;p&gt;那么如何求一个数的euler函数？&lt;/p&gt;&lt;p&gt;我们可以将每个数与n求gcd一下，如果gcd为1，则贡献加1，时间复杂度为 $O(n logn)$，极其优秀（雾）&lt;/p&gt;&lt;p&gt;那么来思考更加优秀的算法（为什么一定要求euler函数($\varphi(n)$函数)呢QAQ）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数论" scheme="http://leceue.github.io./tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
</feed>
