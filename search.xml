<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>trie浅谈</title>
    <url>/2019/10/30/trie%E6%B5%85%E8%B0%88/</url>
    <content><![CDATA[<h2 id="关于trie"><a href="#关于trie" class="headerlink" title="关于trie"></a>关于trie</h2><p>​    其实字典树和以上两种算法有很大不同,但是hash由于其优秀的应用,导致有些字符串查找用hash也是可行的.</p><p>​    字典树中支持添加,查找,区间查询(可持久化字典树),而且在异或操作上有更加好的操作;</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    树的基本构造;</p><h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    字典树是通过动态建点,而形成的树,基本数组有两维, $tr[x][to]$ 中第一维存的是节点标号,而第二维存的是当字符为 $to$ 时通向的节点;</p><a id="more"></a>



<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>​    我当时入门是学的是<a href="https://www.luogu.org/problem/P2580" target="_blank" rel="noopener">这道题</a>;</p>
<blockquote>
<p>给你一些初始字符串,询问,给你一个字符串,这个字符串在这个初始字符串中是否存在</p>
</blockquote>
<p>​    当时使用hash写的,但是没过;</p>
<p>​    现在我们可以用字典树先存一下初始字符串,然后在树上匹配,单次时间复杂度 $O(n)$ ;</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,trie[<span class="number">300007</span>][<span class="number">27</span>],num[<span class="number">300007</span>],sz;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">300007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!trie[now][a[i]-<span class="string">'a'</span>]) trie[now][a[i]-<span class="string">'a'</span>]=++sz;</span><br><span class="line">		now=trie[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	num[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exam</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!trie[now][a[i]-<span class="string">'a'</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		now=trie[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!num[now]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(vis[now]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	vis[now]=<span class="number">1</span>; <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">60</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">		build(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">60</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">		<span class="keyword">int</span> x=exam(a);</span><br><span class="line">		<span class="keyword">switch</span>(x)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"WRONG\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"REPEAT\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="另"><a href="#另" class="headerlink" title="另"></a>另</h4><p>​    我在hash中介绍了map,这里其实也可以用map存字符串,但是其时间复杂度比原来的多了一个 $logn$ ,写法虽然简单但是时间并不优秀;</p>
<h5 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		p[s]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="keyword">if</span>(p[s]==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"OK"</span>),p[s]=<span class="number">2</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[s]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"WRONG"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[s]==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"REPEAT"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>​    异或,是我们经常会见到的,但是如何高效的处理异或信息是一个让人头痛的事,而字典树为我们提供了策略.    </p>
<h3 id="0-1串树"><a href="#0-1串树" class="headerlink" title="0/1串树"></a>0/1串树</h3><p>​    $0/1$ 串树,常用来储存一个2进制数字,我们知道异或正是与二进制有关,那么我们是否可以找在字典树上操作序列呢?</p>
<p>​    显然是可以的,我们在一个节点,分别走0通向的节点和1通向的节点,那么贪心地操作,这样一定是异或对最大值,反之,都走0或者1可以有效地得到最小值,</p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>​    <a href="https://www.luogu.org/problem/P4551" target="_blank" rel="noopener">最长异或路径</a> ,这个例题应该比较合适;</p>
<blockquote>
<p>给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $N$ 。寻找树中找两个结点，求最长的异或路径。</p>
<p>异或路径指的是指两个结点之间唯一路径上的所有边权的异或。</p>
</blockquote>
<p>​    显然,我们可以将每个点到根root的异或和保存一下,然后将其加入字典树,现在我们要求的就是最大的异或数对,跟上面说的一样,我们只要从字典树顶端开始BFS,就可以得到最大异或数对.</p>
<h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y,z,w) (nd)&#123;x,y,z,w&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[maxn],dis[maxn],tr[maxn*<span class="number">32</span>][<span class="number">2</span>],ed[maxn*<span class="number">32</span>],val[maxn*<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> tot,cent,ans[<span class="number">34</span>],ol;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,val,dep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">	edge[++cent]=(node)&#123;head[v],u,w&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">		dis[y]=dis[x]^edge[i].w;</span><br><span class="line">		dfs(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//求异或和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">int</span> pos=!!(x&amp;(<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">		<span class="keyword">if</span>(!tr[now][pos]) tr[now][pos]=++tot;</span><br><span class="line">		now=tr[now][pos];</span><br><span class="line">	&#125;</span><br><span class="line">	ed[tot]=id,val[tot]=x;</span><br><span class="line">&#125;<span class="comment">//树中保存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;nd&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	q.push(mp(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front().x,y=q.front().y,d=q.front().dep;</span><br><span class="line">		<span class="keyword">int</span> val=q.front().val;q.pop();</span><br><span class="line">		<span class="keyword">if</span>(d&gt;<span class="number">30</span>) <span class="keyword">return</span> ans[d];<span class="comment">//到底层了,此时一定是最优解</span></span><br><span class="line">		<span class="keyword">if</span>(ans[d]&gt;val) <span class="keyword">continue</span>;<span class="comment">//减支</span></span><br><span class="line">		<span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">1</span>])&#123;</span><br><span class="line">			q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">			ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">0</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(x!=y) q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">0</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">			ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!tr[x][<span class="number">0</span>]||!tr[y][<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">0</span>])&#123;</span><br><span class="line">					q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">0</span>],val&lt;&lt;<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">					ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">1</span>])&#123;</span><br><span class="line">					q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">					ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//分类讨论</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=n<span class="number">-1</span>;i++) scan(u,v,w),add(u,v,w);</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) insert(dis[i],i),ol=max(ol,dis[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(ol,bfs()));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>​    <a href="https://www.luogu.org/problem/CF888G" target="_blank" rel="noopener">CF888G Xor-MST</a> </p>
<blockquote>
<p>已知一个 $n$ 个节点的无向完全图,每个节点的编号为 $a_i$ , $i$ 与 $j$ 的边的权值是 $a_i$ ^ $a_j$ ,求该图的 $MST$ 的权值;</p>
</blockquote>
<p>​    我们可以想一下 $kruskal$ 算法的过程,那么我们也可以每次寻找最小值,可以通过在trie上BFS得到;</p>
<p>​    值得注意的是,所有分叉点的个数为建边个数(去掉两点权值相同),那么其实直接寻找即可;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y,z,w) (node)&#123;x,y,z,w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],tr[maxn*<span class="number">33</span>][<span class="number">2</span>],ed[maxn*<span class="number">33</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];<span class="keyword">bool</span> vis[maxn*<span class="number">33</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dep[<span class="number">34</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,d,ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--,d++)&#123;</span><br><span class="line">		<span class="keyword">int</span> pos=(!(x&amp;(<span class="number">1</span>&lt;&lt;i)));</span><br><span class="line">		<span class="keyword">if</span>(!tr[now][pos]) tr[now][pos]=++tot;</span><br><span class="line">		<span class="keyword">if</span>(tr[now][pos^<span class="number">1</span>]&amp;&amp;!vis[now]) vis[now]=<span class="number">1</span>,dep[d].push_back(now);</span><br><span class="line">		now=tr[now][pos];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ed[now]) fa[ed[now]]=id;</span><br><span class="line">	ed[now]=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> d,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f1=tr[now][<span class="number">0</span>],f2=tr[now][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="keyword">int</span> ans[<span class="number">32</span>];</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">127</span>,<span class="keyword">sizeof</span> ans);ans[d]=<span class="number">1</span>;</span><br><span class="line">	q.push((node)&#123;f1,f2,d,<span class="number">1</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		x=q.front().x,y=q.front().y;</span><br><span class="line">		<span class="keyword">int</span> dx=q.front().d,ans1=q.front().ans;q.pop();</span><br><span class="line">		<span class="keyword">if</span>(ed[x]&amp;&amp;ed[y])&#123;</span><br><span class="line">			x=ed[x],y=ed[y];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans1&gt;ans[dx])  <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">0</span>]) q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">0</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">1</span>]) q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">1</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!tr[x][<span class="number">0</span>]||!tr[y][<span class="number">0</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">0</span>])</span><br><span class="line">				q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">0</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(tr[y][<span class="number">1</span>]&amp;&amp;tr[x][<span class="number">0</span>])</span><br><span class="line">				q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">1</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans[<span class="number">30</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=get(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen("tree.in","r",stdin);</span></span><br><span class="line"><span class="comment">// 	freopen("tree.out","w",stdout);</span></span><br><span class="line">	scan(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		scan(a[i]);add(a[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dep[i].size()) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dep[i].size();j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x,y,f;</span><br><span class="line">			f=find(dep[i][j],i,x,y);</span><br><span class="line">			<span class="keyword">if</span>(get(x)==get(y)) <span class="keyword">continue</span>;</span><br><span class="line">			fa[get(x)]=get(y);ans+=<span class="number">1l</span>l*f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 2 3 4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="可持久化串树"><a href="#可持久化串树" class="headerlink" title="可持久化串树"></a>可持久化串树</h3><p>​    可持久化串树,即可在区间中查询的串树,与可持久数组有些类似,只是前者用trie,后者用主席树罢了.</p>
<p>​    建树时,我们可以再建一个节点,然后继承上一个节点的信息,然后再建一个新节点去保存自己的信息.</p>
<p>​    区间查询时,我们进入右端点的trie节点,为了限制左边界,我们可以在建图时将其序号标上,在搜索到小于左端点编号时跳过,去寻找另一个节点即可.</p>
<h4 id="建树-0-1trie"><a href="#建树-0-1trie" class="headerlink" title="建树(0/1trie)"></a>建树(0/1trie)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> last,<span class="keyword">int</span> &amp;f,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now;now=f=++tot;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">		trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];<span class="comment">//继承</span></span><br><span class="line">		last=trie[last][ol];</span><br><span class="line">		trie[now][ol]=++tot;<span class="comment">//开拓新节点</span></span><br><span class="line">		mark[tot]=pos;<span class="comment">//记录序号</span></span><br><span class="line">		now=trie[now][ol];<span class="comment">//向下拓展</span></span><br><span class="line">	&#125;</span><br><span class="line">	ending[now]=x;<span class="comment">//结尾数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询-0-1trie"><a href="#查询-0-1trie" class="headerlink" title="查询(0/1trie)"></a>查询(0/1trie)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ending[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这里的查询是在一段区间中查询异或k的最大值;</p>
<h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><p>​    <a href="https://www.luogu.org/problem/P4735" target="_blank" rel="noopener">最大异或和</a>,模版题;</p>
<p>​    我们就按照上面的步骤即可;</p>
<h5 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1200007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,trie[maxn*<span class="number">10</span>][<span class="number">2</span>],a[maxn],sum[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> ending[maxn*<span class="number">10</span>],mark[maxn*<span class="number">10</span>],lim,id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> last,<span class="keyword">int</span> &amp;f,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now;now=f=++tot;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">		trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];</span><br><span class="line">		last=trie[last][ol];</span><br><span class="line">		trie[now][ol]=++tot;</span><br><span class="line">		mark[tot]=pos;</span><br><span class="line">		now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	ending[now]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ending[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen("cin.in","r",stdin);</span></span><br><span class="line">	scan(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		scan(a[i]),sum[i]=sum[i<span class="number">-1</span>]^a[i];</span><br><span class="line">		lim=max(sum[i],lim);</span><br><span class="line">	&#125;</span><br><span class="line">	lim=(<span class="keyword">int</span>)log2(<span class="number">1e7</span>)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		build(sum[i],id[i<span class="number">-1</span>],id[i],i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r,x;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">char</span> s=getchar();</span><br><span class="line">		<span class="keyword">while</span>(s!=<span class="string">'A'</span>&amp;&amp;s!=<span class="string">'Q'</span>) s=getchar();</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="string">'A'</span>) scan(x),n++,sum[n]=sum[n<span class="number">-1</span>]^x,build(sum[n],id[n<span class="number">-1</span>],id[n],n);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">'Q'</span>)&#123;</span><br><span class="line">			scan(l,r,x); </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(sum[n]^x)^dfs((sum[n]^x),id[r<span class="number">-1</span>],l<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h4><p>​    <a href="https://www.luogu.org/problem/P5283" target="_blank" rel="noopener">异或粽子</a>,可持久化trie查询区间最大异或值;</p>
<p>​    这道题的思路可以从 <a href="https://www.luogu.org/problem/P2048" target="_blank" rel="noopener">超级钢琴</a> 中得到.</p>
<p>​    超级钢琴的思路是将权值处理出来,与区间信息一起保存在优先队列中,然后每次取出最大值,再更新左右区间即可;</p>
<p>​    而这道题与其不同的是,这里将权值处理出来的方式不同,这里运用可持久化trie,然后在区间查询最大异或值,其他的与超级钢琴几乎一致;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n,k,trie[maxn*<span class="number">23</span>][<span class="number">2</span>],mark[maxn*<span class="number">23</span>],val[maxn*<span class="number">23</span>];</span><br><span class="line">ll sum[maxn],ans,tot,lim=<span class="number">33</span>,a[maxn],id[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll val,l,r,pos,ori;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll x,ll last,ll &amp;f,ll pos)</span></span>&#123;</span><br><span class="line">	ll now;now=f=++tot;</span><br><span class="line">	<span class="keyword">for</span>(ll i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">		trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];</span><br><span class="line">		last=trie[last][ol];</span><br><span class="line">		trie[now][ol]=++tot;</span><br><span class="line">		mark[tot]=pos;</span><br><span class="line">		now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	val[now]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x,ll f,ll op,ll &amp;pos)</span></span>&#123;</span><br><span class="line">	ll now=f;</span><br><span class="line">	<span class="keyword">for</span>(ll i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pos=mark[now],val[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("xor.in","r",stdin);</span></span><br><span class="line"><span class="comment">//	freopen("xor.out","w",stdout);</span></span><br><span class="line">	scan(n,k);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		scan(a[i]),sum[i]=sum[i<span class="number">-1</span>]^a[i];</span><br><span class="line">		build(sum[i],id[i<span class="number">-1</span>],id[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ll ol,pos;</span><br><span class="line">		ol=query(sum[i<span class="number">-1</span>],id[n],i,pos);</span><br><span class="line">		q.push((node)&#123;ol^sum[i<span class="number">-1</span>],i,n,pos,sum[i<span class="number">-1</span>]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q.empty()) <span class="keyword">continue</span>;</span><br><span class="line">		node x=q.top();ans+=x.val;q.pop();</span><br><span class="line">		ll ol,pos;</span><br><span class="line">		<span class="keyword">if</span>(x.l&lt;x.pos)&#123;</span><br><span class="line">			ol=query(x.ori,id[x.pos<span class="number">-1</span>],x.l,pos);</span><br><span class="line">			q.push((node)&#123;ol^x.ori,x.l,x.pos<span class="number">-1</span>,pos,x.ori&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x.pos&lt;x.r)&#123;</span><br><span class="line">			ol=query(x.ori,id[x.r],x.pos+<span class="number">1</span>,pos);</span><br><span class="line">			q.push((node)&#123;ol^x.ori,x.pos+<span class="number">1</span>,x.r,pos,x.ori&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    这里只是总结了一下trie的用法,我见到的主要还是0/1trie,以后见到还会再加入;</p>
<h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>hash应用</title>
    <url>/2019/10/30/hash%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="关于HASH"><a href="#关于HASH" class="headerlink" title="关于HASH"></a>关于HASH</h2><p>​    这应该是经常使用的一个算法,因为其预处理后,优秀的$O(1)$处理出子串,并且$O(1)$比较,大快人心,而且写法简单,令人心情愉悦;</p><p>​    但是其空间复杂度较高,并且有玄学模数以及哈希冲突,以至于如果想hack,其实可以hack掉;</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    关于进制,模数,hash就用到了重构进制,取模稀疏,所以哈希表又叫稀疏表;</p><a id="more"></a>


<h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    hash很好理解,而且匹配非常方便,<del>不容易写炸,对于萌新十分友好</del>,</p>
<h3 id="HASH查询"><a href="#HASH查询" class="headerlink" title="HASH查询"></a>HASH查询</h3><p>​    我们知道数字匹配复杂度为 $O(1)$ ,数字匹配速度快,而字符串却只能一个一个匹配, <del>这不公平</del> .那么我们考虑将字符串变成数字.</p>
<p>​    想一下数字有进制,那么我们定义一下字母的进制,不一定是26,我们可以随便取一个数,习惯性取质数;</p>
<p>​    但是数字太长,爆 $long$ $long$ 我们没办法存怎么办,我们考虑字符串很少,但是空间很大,我们考虑将数字安排入一个位置,其实这个位置是随机的,但是我们可以推出,这就够了;</p>
<p>​    那么我们可以模一个数字,将数字限制在一个范围之内,然后储存下来,而这个模数一般是一个质数,因为质数的特殊性质,可以造成更好地将数字稀疏;</p>
<h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll base=<span class="number">133</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">19491001</span>;</span><br><span class="line"><span class="function">ll <span class="title">id</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);ll ol=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">		ol=(ol*base+s[i]-<span class="string">'a'</span>+<span class="number">1</span>)%mod;</span><br><span class="line">	<span class="keyword">return</span> ol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    处理复杂度 $O(n)$ 然后开个数组储存即可;</p>
<h3 id="HASH子串匹配"><a href="#HASH子串匹配" class="headerlink" title="HASH子串匹配"></a>HASH子串匹配</h3><p>​    我们知道,如果每次都处理出一个串的子串,那么时间复杂度 $O(n^2)$ ,这是我们不能接受的,但是考虑一下我们存的是数字,数字有进制,那么一定可以通过加减操作得到其子串,那么,就简单很多了;</p>
<p>​    我们可以先预处理出 $HASH$ 前缀和,之后通过加减得到一段区间的子串;</p>
<p>​    但是直接开数组了话,有可能开不下,或者加大hash冲突的可能(即两个字符串hash值相同),那么我们可以考虑在不超时的情况下,加入一个map储存hash值,这样不需再担心空间问题,但是每次查询时间会多一个 $logn$ ,请谨慎使用;</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>​    我不再直接附上模版,而是引入一个 <a href="https://www.luogu.org/problem/P5546" target="_blank" rel="noopener">例题</a>;</p>
<blockquote>
<p>给出几个由小写字母构成的单词，求它们最长的公共子串的长度。</p>
</blockquote>
<h5 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h5><p>​    我们可以二分枚举公共子串长度,因为公共子串长度一定是满足单调性质的.</p>
<p>​    那么我们选择枚举第一个串的子串,然后将其他串中相同长度的子串储存起来,那么就可以匹配了;</p>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ll base=<span class="number">133</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;ha[<span class="number">6</span>];</span><br><span class="line">ll sum[<span class="number">6</span>][maxn],ad[maxn];</span><br><span class="line"><span class="keyword">int</span> n,lim=maxn,len[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sum[pos][r+<span class="number">1</span>]-sum[pos][l]*ad[r-l+<span class="number">1</span>]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ha[i].clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+l<span class="number">-1</span>&lt;len[i];j++)</span><br><span class="line">			ha[i][id(i,j,l+j<span class="number">-1</span>)]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+l<span class="number">-1</span>&lt;len[<span class="number">1</span>];i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=id(<span class="number">1</span>,i,i+l<span class="number">-1</span>),cnt=n<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ha[j][temp]) cnt--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!cnt) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ad[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2001</span>;i++) ad[i]=ad[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len[i];j++)&#123;</span><br><span class="line">			sum[i][j+<span class="number">1</span>]=(sum[i][j]*base+(c[i][j]-<span class="string">'a'</span>))%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,c[i]),lim=min(len[i]=<span class="built_in">strlen</span>(c[i]),lim);</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=lim;init();</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP浅谈</title>
    <url>/2019/10/30/KMP%E6%B5%85%E8%B0%88/</url>
    <content><![CDATA[<h2 id="关于KMP"><a href="#关于KMP" class="headerlink" title="关于KMP"></a>关于KMP</h2><p>​    KMP其实是三个人名字的缩写,因为是他们同时发现的<del>(大佬惹不起)</del>;</p><p>​    KMP作为CSP考点,主要亮点是其优秀的匹配复杂度,而且消耗空间小,比起hash虽然有些局限性,但是因为其正确率高,所以经常被人使用.</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    关于字符串的读取,以及字符串相关操作的基础了解,这里涉及字符串匹配以及子串;</p><a id="more"></a>


<h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    其实KMP并不困难,只是让人难受的是它比较抽象的数组跳跃,我想这个并不需要过多解释;</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>​    KMP常用于一个字符串是否出现在另一个字符串中.我们知道,如果暴力匹配了话,每次失配时就必须重新开始(不能贪心地从失配位置匹配),这样造成很大的浪费,那么我们想从已经匹配过的字符串中提取一些信息,以至于让我们不跳那么远,那这怎么办?</p>
<p>​    KMP算法就由此诞生了,它通过记录模式串的内部信息,为匹配时提供信息,可以节省大量时间.</p>
<h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,nxt[maxn],l1,l2,ans;</span><br><span class="line"><span class="keyword">char</span> s1[maxn],s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nxt</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l2;i++)&#123;</span><br><span class="line">		t=nxt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span>(s2[i]!=s2[t+<span class="number">1</span>]&amp;&amp;t&gt;=<span class="number">0</span>) t=nxt[t];</span><br><span class="line">		<span class="keyword">if</span>(s2[t+<span class="number">1</span>]==s2[i]) nxt[i]=t+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> nxt[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;l1)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">			i++,j++;</span><br><span class="line">			<span class="keyword">if</span>(j==l2)</span><br><span class="line">				ans++,j=nxt[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">0</span>) i++;</span><br><span class="line">			<span class="keyword">else</span> j=nxt[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;s2&gt;&gt;s1;ans=<span class="number">0</span>;</span><br><span class="line">		l1=<span class="built_in">strlen</span>(s1),l2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">		<span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="keyword">sizeof</span> nxt);</span><br><span class="line">		get_nxt();KMP();</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于next数组的几个性质"><a href="#关于next数组的几个性质" class="headerlink" title="关于next数组的几个性质"></a>关于next数组的几个性质</h3><p>​    因为next与stl冲突所以命名为nxt数组;</p>
<p>​    next数组有一些性质:</p>
<p>​    $next[l]$ 到 $l$ 为模式串的最小循环节,当然必须满足一个条件,即最小循环节长度是整个串长度的因数,如果不是了话,那么一定是开头的字符串有残余,而残余字符串为循环节的后缀;</p>
<p>​    那么考虑一下,如果我们想要找最小循环节,直接初始化后,找 $next[l]$ 即可,当然还要判断一下;</p>
<p>​    想象一下 $next$ 数组的跳跃,我们能找到什么?即从 $1$ ~ $next [ l ] $ 既是前缀又是后缀,那么我们可以找到子串中的最大前缀和后缀相同的;</p>
<h3 id="匹配时需要注意的细节"><a href="#匹配时需要注意的细节" class="headerlink" title="匹配时需要注意的细节"></a>匹配时需要注意的细节</h3><p>​    我们常常会遇到让我们求出循环次数,以及不重叠循环次数,其区别只是判断 $j==l2$ 时 $j$ 是否要跳回 $next[j]$ ;</p>
<p>​    或者是直接判断是否有这个模式串,直接 $return$ 即可;</p>
<h3 id="关于题目变形"><a href="#关于题目变形" class="headerlink" title="关于题目变形"></a>关于题目变形</h3><p>​    主要是应该看出匹配方式,以及字符串的重构问题;</p>
<h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>基环树初步</title>
    <url>/2019/10/26/%E5%9F%BA%E7%8E%AF%E6%A0%91%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>​    说实话,基环树一般比较综合,所以一般只要就要具有图论基本知识便可以开始学习.</p><h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>​    博主实力不足,如果出错,<del>请用力D他</del> .</p><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>​    基环树,原体是树,有树上任意连一条边,就成了一个环,即基环树,一般特征,$n$个点$n$条边;</p><p>​    由于有树的特征,所以经常会用一些树的算法来计算基环树;</p><a id="more"></a>



<h2 id="基础的知识"><a href="#基础的知识" class="headerlink" title="基础的知识"></a>基础的知识</h2><h3 id="找环"><a href="#找环" class="headerlink" title="找环"></a>找环</h3><p>​    寻找环,这是基环树的基础,也很简单.</p>
<p>​    考虑记录每个点是否访问过,当再次经过这个点时,那么这个点就能找出这个环了.</p>
<p>​    我们只要在dfs时记录点的前继即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cir</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=x;stk[++tot]=x;id[x]=tot;w[y]=f;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		temp=pre[temp];</span><br><span class="line">		stk[++tot]=temp;</span><br><span class="line">		id[temp]=tot;</span><br><span class="line">	&#125;<span class="keyword">while</span>(temp!=y);</span><br><span class="line">	sum[<span class="number">1</span>]=w[y];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+w[stk[i<span class="number">-1</span>]];</span><br><span class="line">&#125;<span class="comment">//记录环 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!vis[y]) &#123;</span><br><span class="line">			pre[y]=x,w[y]=edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dfs1(y,x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			get_cir(x,y,edge[i].w);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//返回值为是否找到环</span></span><br></pre></td></tr></table></figure>
<p>​    这个是根据原理自己构造的,需要注意的是,环处理出来的前缀和终点不是该点,即$sum[i]$为从0点到$i+1$点的距离,所以记录环中第2个for循环就是讲$sum$数组循环移动一次,当然这是我自己构造而导致的$bug$,不过也并不碍事;</p>
<h3 id="子树DP找直径以及最大深度"><a href="#子树DP找直径以及最大深度" class="headerlink" title="子树DP找直径以及最大深度"></a>子树DP找直径以及最大深度</h3><p>​    这里应该是比较基础的,确实,两遍bfs或dfs理解很容易,但是相比之下,DP有更优的时间以及优秀的代码长度,所以DP找直径是必要的;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	ll other=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa||id[y]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(y,x);</span><br><span class="line">		f=max(f,root[x]+root[y]+edge[i].w);</span><br><span class="line">		f=max(f,other+root[y]+edge[i].w);<span class="comment">//更新直径 </span></span><br><span class="line">		other=max(other,root[y]+edge[i].w);</span><br><span class="line">		dep[x]=max(dep[x],dep[y]+edge[i].w);<span class="comment">//深度更新 </span></span><br><span class="line">	&#125;</span><br><span class="line">	root[x]+=other;</span><br><span class="line">&#125;<span class="comment">//DP找直径以及最大深度</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶结合"><a href="#进阶结合" class="headerlink" title="进阶结合"></a>进阶结合</h2><p>​    基环树,最终都是在环上处理问题,通常处理路径长度问题,因为博主实力不足,目前见过两种,都总结下来;</p>
<h3 id="set维护"><a href="#set维护" class="headerlink" title="set维护"></a>set维护</h3><p>​    <strong><a href="https://www.luogu.org/problem/CF835F" target="_blank" rel="noopener">Roads in the Kingdom</a></strong></p>
<blockquote>
<p>​    王国有$n$座城市与$n$条有长度的街道，保证所有城市直接或间接联通，我们定义王国的直径为所有点对最短距离中的最大值，现因财政危机需拆除一条道路并同时要求所有城市仍然联通，求所有拆除方案中王国直径的最小值</p>
</blockquote>
<p>​    显然,这是一道有基环树特征的题,考虑枚举拆除道路,即环上道路(不在环上就不连通了),那么如何快速求出直径是我们所需要的;</p>
<p>​    我们可以先考虑直径不过环,那么可以先DP预处理出子树上直径,并同时处理出最大深度$dep$(后面要用).</p>
<p>​    之后考虑环上直径,我们可以维护环上前缀和,注意前缀和$sum[i]$必须以点$i$结尾;那么,直径公式就很显然了;</p>
<script type="math/tex; mode=display">
max_{i<j}(sum[j]+dep[j]-sum[i]+dep[i])</script><p>​    那么,我们可以用两个set维护$sum[i]+dep[i]$和$-sum[i]+dep[i]$,每次取出最大值,相加即可;</p>
<p>​    还有一些细节问题需要注意:</p>
<blockquote>
<p>1.显然$i\not =j$,如果相等,我们可以取次小值最大的更新.</p>
<p>2.万一不在一个环上怎么办,我们知道,环上有两种求直径, $sum[j]-sum[i]$ 和 $sum[tot]-sum[j]+sum[i]$,那么我们如何保证一定是第一个公式呢.考虑我们在存前缀和时,$sum[1]$是点$1$与点$tot$之间的距离,那么我们可以先枚举这条边,那么,此时一定是第一个公式,这个可以想一想环上前缀和的特点;那么我们就可以在枚举点,枚举的边即为它与$i-1$之间的边,每次到下一个点,使我们这个点的$sum$加上$sum[tot]$,即相当于变成了前缀和最后一个点,然后在set中加入,并删除以前的;</p>
<p>3.如何保证$j&gt;i$,考虑一下,如果 $j<i$ ,但是前缀和中 $sum[i]>sum[j]$ ,那么显然</i$></p>
<script type="math/tex; mode=display">
sum[j]+dep[j]-sum[i]+dep[i]<sum[i]+dep[i]-sum[j]+dep[j]</script><p>而我们求出的是最优的,所以一定是后者,所以只要注意一下第一条所说的$i=j$的情况,其他情况下$i&lt;j$.</p>
</blockquote>
<p>这样应该就能解决了,对了,multiset的结构体删除请注意一下,重载运算符可能会出差错;</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 400007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) (d)&#123;x,y&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st multiset<span class="meta-string">&lt;d&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[maxn],pre[maxn],stk[maxn],id[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> cent,vis[maxn],w[maxn];</span><br><span class="line">ll sum[maxn],ans,dep[maxn],root[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">	edge[++cent]=(node)&#123;head[v],u,w&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cir</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=x;stk[++tot]=x;id[x]=tot;w[y]=f;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		temp=pre[temp];</span><br><span class="line">		stk[++tot]=temp;</span><br><span class="line">		id[temp]=tot;</span><br><span class="line">	&#125;<span class="keyword">while</span>(temp!=y);</span><br><span class="line">	sum[<span class="number">1</span>]=w[y];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+w[stk[i<span class="number">-1</span>]];</span><br><span class="line">&#125;<span class="comment">//记录环 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!vis[y]) &#123;</span><br><span class="line">			pre[y]=x,w[y]=edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dfs1(y,x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			get_cir(x,y,edge[i].w);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//返回值为是否找到环 </span></span><br><span class="line"></span><br><span class="line">ll f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	ll other=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa||id[y]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(y,x);</span><br><span class="line">		f=max(f,root[x]+root[y]+edge[i].w);</span><br><span class="line">		f=max(f,other+root[y]+edge[i].w);<span class="comment">//更新直径 </span></span><br><span class="line">		other=max(other,root[y]+edge[i].w);</span><br><span class="line">		dep[x]=max(dep[x],dep[y]+edge[i].w);<span class="comment">//深度更新 </span></span><br><span class="line">	&#125;</span><br><span class="line">	root[x]+=other;</span><br><span class="line">&#125;<span class="comment">//DP找直径以及最大深度 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d</span>&#123;</span></span><br><span class="line">	ll val,pos;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> d &amp;x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val&gt;x.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;d&gt;a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n);ans=<span class="number">2305843009213693652</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=n;i++) scan(u,v,w),add(u,v,w);</span><br><span class="line">	dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) dfs2(stk[i],<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">		a.insert(mp(sum[i]+dep[stk[i]],i)),b.insert(mp(-sum[i]+dep[stk[i]],i));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">		st x=a.begin(),y=b.begin();</span><br><span class="line">		ll ol=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x-&gt;pos==y-&gt;pos)&#123;</span><br><span class="line">			st dir=a.begin();dir++;</span><br><span class="line">			ol=dir-&gt;val+y-&gt;val;</span><br><span class="line">			dir=b.begin();dir++;</span><br><span class="line">			ol=max(ol,dir-&gt;val+x-&gt;val);</span><br><span class="line">		&#125;<span class="keyword">else</span> ol=x-&gt;val+y-&gt;val;</span><br><span class="line">		ans=min(ans,ol);</span><br><span class="line">		x=a.find(mp(sum[i]+dep[stk[i]],i)),y=b.find(mp(-sum[i]+dep[stk[i]],i));</span><br><span class="line">		a.erase(x),b.erase(y);</span><br><span class="line">		a.insert(mp(sum[i]+sum[tot]+dep[stk[i]],i)),b.insert(mp(-sum[i]-sum[tot]+dep[stk[i]],i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,max(f,ans));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>​    <strong><a href="https://www.luogu.org/problem/P4381" target="_blank" rel="noopener">P4381 [IOI2008]Island</a></strong></p>
<blockquote>
<p>你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为$L_i$的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：</p>
<ul>
<li><p>可以自行挑选一个岛开始游览。</p>
</li>
<li><p>任何一个岛都不能游览一次以上。</p>
</li>
<li><p>无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$</p>
<p> 有如下方法： </p>
<ul>
<li>步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。</li>
<li>渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。</li>
</ul>
</li>
</ul>
<p>注意，你不必游览所有的岛，也可能无法走完所有的桥。</p>
</blockquote>
<p>​    我们很容易分析出这是一个基环树森林,分别计算每一个基环树上的直径,但是我们不能排除环的干扰,难道要暴力枚举环上边,博主并没有尝试,<del>决定口胡</del>;</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>​    以下为博主口胡部分(并不是主流的正解做法):</p>
<p>​    根据公式$d=sum[j]-sum[i]+dep[i]+dep[j]$;</p>
<p>​    我们可以用上面的方法枚举断边,然后用set维护,求出最大直径,之后对于每一个基环树进行操作,累加和即可.</p>
<p>​    总时间复杂度$O(nlongn)$,估计可以通过此题,但是因为这道题时间太过久远,博主在之前写过单调队列,已经不想再写一遍了,不过这种方法预测可行<del>(还挺具有普适性的)</del>;</p>
<h4 id="主流的单调队列"><a href="#主流的单调队列" class="headerlink" title="主流的单调队列"></a>主流的单调队列</h4><p>​    显然,我们可以枚举点$i,j$,不过这样会$T$,</p>
<p>​    但是考虑当$i&lt;j$时,我们可以用单调队列维护$-sum[i]+dep[i]$的最大值,然后断环成链,更新即可</p>
<p>​    至于出队条件,即为$pos[j]-pos[front]&gt;len$($len$为环长度).时间复杂度$O(n)$.</p>
<p>​    这里不再附上代码,因为当时代码太丑,有很大一部分是与他人代码雷同(因为当时不会写),为了防止误导,就不再附上代码;</p>
<p>ps:当遇到这类题时会再次update.</p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>一维以及二维的差分的简述</title>
    <url>/2019/10/25/%E4%B8%80%E7%BB%B4%E4%BB%A5%E5%8F%8A%E4%BA%8C%E7%BB%B4%E7%9A%84%E5%B7%AE%E5%88%86%E7%9A%84%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<p>　　差分，也就是数与数之间的差值。拿一维差分来举例子，将差分设为c[ ]数组，原数为a[ ],那么</p><p>　　$c[i]=a[i]-a[i-1]$</p><p>　　这便是简单的差分数组；</p><p>　　那么要他何用？</p><p>　　最为主要的作用就是区间的修改，那么在修改之前，我们先明白如何将原数求出。很显然，$c[1]$~$c[i]$差分数组求和即可得到$a[i]$。</p><a id="more"></a>




<p>　　那区间修改呢？</p>
<p>　　如我们将从l到r的区间加上s（减去也一样），那么由差分数组的定义得，观察数组，发现只有c[l]和c[r+1]变化了。</p>
<p>　　具体证明可以手动模拟，而中间的不变是因为i项与i-1项都加上了s，差值不变;</p>
<p>　　那么这样就能得到</p>
<p>　　$a[l]$~$a[r]+=s$—&gt;$c[l]+s,c[r+1]+s$</p>
<p>　　这样就实现了$O(1)$修改；</p>
<p>　　当然还有区间求和，这里给出证明</p>
<p><img src="\images\7.png" alt="alt"></p>
<p>　　这样我们可以发现一个规律，即第二个多项式的系数为i-1</p>
<p>　　那么我们用c2[ ]来维护这个数组，那么</p>
<script type="math/tex; mode=display">
c2[i]=(i-1)*c[i]</script><p>　　并且在修改时维护$c2[ i]$数组，即</p>
<script type="math/tex; mode=display">
c[l]+(l-1)*s,c[r+1]-(r+1-1)*s</script><p>　　之后便有了公式</p>
<p>　　<img src="\images\8.png" alt="alt"></p>
<p>　　这里便是一维差分</p>
<p>　　<strong>二维差分的推导</strong></p>
<p>　　这里的推导只是单纯的根据一维差分和二维前缀和的性质来推的</p>
<p>　　二维前缀和请务必提前了解，并有一定的认识；</p>
<p>　　那么开始推导；</p>
<p>　　根据二维前缀和表示的是右上角矩形的和，由于差分只涉及前面相邻的数（由一维可以推出），并且由前面范围的数相加得到这个位置的数；</p>
<p>　　那么类比二维前缀和和一维差分，可以简单推测出二维差分的公式</p>
<p>　　$c[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$</p>
<p> 　　是不是觉得非常眼熟？</p>
<p>　　我们再代入检验，即将左上角的矩阵差分求和，正好得到了这个数·</p>
<p>　　这还并不能代表什么，重要的是区间的修改；</p>
<p>　　同样，我们将要修改的矩阵的右上角设为$(x1,y1)$,右下角设为$(x2,y2)$</p>
<p>　　<img src="\images\9.png" alt="alt"></p>
<p>　　我们发现有影响的只有我所标注的点，除了$(x2,y2)$,这个应该很好看出；</p>
<p>　　那么，我们就得到公式</p>
<p>　　$c[x1][y1]+=s,c[x1][y2+1]-=s,c[x2+1][y1]-=s,c[x2+1][y2+1]+=s$</p>
<p>　　推荐自己再推一遍。</p>
<p>　　之后求数只需累加即可。</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线</title>
    <url>/2019/10/25/%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    <content><![CDATA[<p>请在学习之前有一定的线段树基础</p><p>在一些题中，它总会给你一些矩形，之后让你求总覆盖面积。</p><p>它的难点在于，有重叠面积，如果只是罗列情况，那么只会一事无成。</p><p>所以说，这里就引进了扫描线做法；</p><p>其实它的原理很简单，只是底*高而已，只是分段求解；</p><p>而问题大概的图就是这样</p><p><img src="/images/10.png" alt="alt"></p><p>根据我刚刚说的分段求解和底*高，那么我们就可以推测出扫描线是什么了</p><a id="more"></a>







<p>它是由矩形的上边和下边构成，并记录其左右端点和其所在的纵坐标；</p>
<p><img src="/images/11.png" alt="img"></p>
<p>图中标红的即为扫描线，那么我们用它做什么？</p>
<p>根据 S=a<em>h，那么我们可以将扫描线按<em>*纵坐标排序</em></em>，这样分步求解。</p>
<p>这是扫描线的储存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//左右端点坐标 </span></span><br><span class="line">    <span class="keyword">int</span> h;<span class="comment">//还是按 扫描线写，这个是y轴坐标 </span></span><br><span class="line">    <span class="keyword">int</span> d;<span class="comment">//标记这个线是不是上界或下界 </span></span><br><span class="line">&#125;s[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线</span></span><br></pre></td></tr></table></figure>
<p>那么便可以得到高，即</p>
<p><strong>s[i+1].h-s[i].h</strong></p>
<p>之后考虑存底，只需要用线段树维护即可；</p>
<p>当扫描线为下界时，应当将扫描线所在区域加入线段树，而当为上界时再减去即可；</p>
<p>由于底边过大，不可能全部建树，这里给出了离散化做法，还有动态开点做法之后将会提到</p>
<p>由于找不到最合适的模板题，只能拿这个来充数<a href="https://www.luogu.org/problemnew/show/P2061" target="_blank" rel="noopener"> P2061 [USACO07OPEN]城市的地平线City Horizon</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,h;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;h);</span><br><span class="line">    ls[++cent]=a;<span class="comment">//其实是用来离散化的 </span></span><br><span class="line">    s[cent]=(node)&#123;a,b,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    ls[++cent]=b;</span><br><span class="line">    s[cent]=(node)&#123;a,b,h,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(ls+<span class="number">1</span>,ls+<span class="number">1</span>+cent);<span class="comment">//离散化初始 </span></span><br><span class="line">sort(s+<span class="number">1</span>,s+<span class="number">1</span>+cent);ls[++m]=ls[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls[i]!=ls[i<span class="number">-1</span>])</span><br><span class="line">        ls[++m]=ls[i];<span class="comment">//去重 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这便是简单的离散化，当然，你也可以排序后用unique函数，得到m和ls数组，这个可以网上查询，这里便不再赘述</p>
<p>之后是线段树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[p]) tree[p].sum=ls[r]-ls[l];<span class="comment">//如何避免少减？ </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tree[p].sum=tree[le(p)].sum+tree[re(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_date</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> d,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=tree[p].l,r=tree[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        mark[p]+=d;</span><br><span class="line">        push_up(l,r,p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r<span class="number">-1</span>==l) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=L) up_date(le(p),d,L,R);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) up_date(re(p),d,L,R);</span><br><span class="line">    push_up(l,r,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码是我根据多种方面得出，但是仍由问题，即代码所说的，因为在线段数中 l 是可以等于 r 的，但是线段的长度必须由两个不同的数得出，这是不行的</p>
<p>所以，我们可以先建出一颗空树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l;</span><br><span class="line">    tree[p].r=r;</span><br><span class="line">    tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p)),build(mid,r,re(p));<span class="comment">/*注意，mid在左子树和右子树中都有出现，所以在 </span></span><br><span class="line"><span class="comment">    叶子节点，r=l+1，这个也是对return 的解释*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说，这样便避免了这个问题，不过请读者注意这些点，这些便是易错的小细节</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">build(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> l=search(s[i].x,ls);<span class="comment">//二分寻找离散化位置</span></span><br><span class="line">    <span class="keyword">int</span> r=search(s[i].y,ls);</span><br><span class="line">    up_date(<span class="number">1</span>,s[i].d,l,r);<span class="comment">// 用线段树更新sum，即矩形底边 </span></span><br><span class="line">    rt+=(ll)tree[<span class="number">1</span>].sum*<span class="number">1l</span>l*(s[i+<span class="number">1</span>].h-s[i].h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是主函数的计算，而search有解释，也可以用lower_bound，推荐提前处理出来，否则可能会提高时间复杂度，这不是我们所期望的</p>
<p>这样的做法不易错是真的，这里给出二分search做法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> pur,<span class="keyword">int</span>* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[mid]&lt;pur) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这便是整个过程，这里给出<strong>code</strong></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 40007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,cent,m,mark[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> ls[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line">ll rt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tr</span>&#123;</span></span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//左右端点坐标 </span></span><br><span class="line">    <span class="keyword">int</span> h;<span class="comment">//还是按 扫描线写，这个是y轴坐标 </span></span><br><span class="line">    <span class="keyword">int</span> d;<span class="comment">//标记这个线是不是上界或下界 </span></span><br><span class="line">&#125;s[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[p]) tree[p].sum=ls[r]-ls[l];<span class="comment">//如何避免少减？ </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tree[p].sum=tree[le(p)].sum+tree[re(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_date</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> d,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=tree[p].l,r=tree[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        mark[p]+=d;</span><br><span class="line">        push_up(l,r,p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r<span class="number">-1</span>==l) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=L) up_date(le(p),d,L,R);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) up_date(re(p),d,L,R);</span><br><span class="line">    push_up(l,r,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l;</span><br><span class="line">    tree[p].r=r;</span><br><span class="line">    tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p)),build(mid,r,re(p));<span class="comment">/*注意，mid在左子树和右子树中都有出现，所以在 </span></span><br><span class="line"><span class="comment">    叶子节点，r=l+1，这个也是对return 的解释*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> pur,<span class="keyword">int</span>* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[mid]&lt;pur) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,h;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;h);</span><br><span class="line">        ls[++cent]=a;<span class="comment">//其实是用来离散化的 </span></span><br><span class="line">        s[cent]=(node)&#123;a,b,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        ls[++cent]=b;</span><br><span class="line">        s[cent]=(node)&#123;a,b,h,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ls+<span class="number">1</span>,ls+<span class="number">1</span>+cent);<span class="comment">//离散化初始 </span></span><br><span class="line">    sort(s+<span class="number">1</span>,s+<span class="number">1</span>+cent);ls[++m]=ls[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ls[i]!=ls[i<span class="number">-1</span>])</span><br><span class="line">            ls[++m]=ls[i];<span class="comment">//去重 </span></span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l=search(s[i].x,ls);<span class="comment">//二分寻找离散化位置</span></span><br><span class="line">        <span class="keyword">int</span> r=search(s[i].y,ls);</span><br><span class="line">        up_date(<span class="number">1</span>,s[i].d,l,r);<span class="comment">// 用线段树更新sum，即矩形底边 </span></span><br><span class="line">        rt+=(ll)tree[<span class="number">1</span>].sum*<span class="number">1l</span>l*(s[i+<span class="number">1</span>].h-s[i].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;rt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-24-补充："><a href="#7-24-补充：" class="headerlink" title="7.24 补充："></a>7.24 补充：</h2><p><a href="https://www.luogu.org/problemnew/show/P1502" target="_blank" rel="noopener"><strong>LUOGU P1502 窗口的星星</strong></a></p>
<p>　　</p>
<h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>小卡买到了一套新房子，他十分的高兴，在房间里转来转去。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>晚上，小卡从阳台望出去，“哇~~~~好多星星啊”，但他还没给其他房间设一个窗户，天真的小卡总是希望能够在晚上能看到最多最亮的星星，但是窗子的大小是固定的，边也必须和地面平行。这时小卡使用了超能力（透视术）知道了墙后面每个星星的位置和亮度，但是小卡发动超能力后就很疲劳，只好拜托你告诉他最多能够有总和多亮的星星能出现在窗口上。</p>
<h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p><strong>输入格式：</strong></p>
<p>本题有多组数据，第一行为T 表示有T组数据T&lt;=10</p>
<p>对于每组数据</p>
<p>第一行3个整数n，W，H，（n&lt;=10000,1&lt;=W,H&lt;=1000000）表示有n颗星星，窗口宽为W，高为H。</p>
<p>接下来n行，每行三个整数xi，yi，li 表示星星的坐标在（xi，yi），亮度为li。（0&lt;=xi,yi&lt;2^31)</p>
<p><strong>输出格式：</strong></p>
<p>T个整数，表示每组数据中窗口星星亮度总和的最大值。</p>
<p>这道题的一个关键点是，将星星作为一个窗户的左下角（其实是为了不出现负数），将每一个星星都创一个窗户，之后寻找重叠部分</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h3><p><strong><img src="/images/12.png" alt="alt"></strong></p>
<p>看这个图，这是两个相交的情况，矩形左下角是星星，然后如果有重叠部分，那么我们要贴着相交部分的上边和右边建一个窗户，那么就可以盖住这两个星星，</p>
<p><img src="/images/13.png" alt="alt"></p>
<p>类比到所有星星是一样的，我们只要将矩形附上权值即可，用扫描线寻找。</p>
<p><strong>但是这个边框不是不能包含星星吗？所以我们需要处理一些小细节，将矩形右边的横坐标减去1，也就是提前减去，再将扫描线上端-1，这就处理了边界问题；</strong></p>
<p><strong>并且在sort的时候当横坐标相同时，将加上的排在前面。</strong></p>
<p>这个细节请一定要理解，否则wa了也不好调（因为不给数据），代码我会做上标记。</p>
<p>矩形权值直接附在扫描线上即可；</p>
<p>上一道例题中，我用离散化解决了范围大的问题，这里我们介绍动态开点做法；</p>
<p>首先不需要在意太多的离散化细节是一个优点，干干的介绍不是非常简洁，所以我直接附上代码讲解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,w,h,cnt,lim,root;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,l,r,w,d;</span><br><span class="line">&#125;a[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> le,ri,w,tag;</span><br><span class="line">&#125;tr[<span class="number">5000007</span>];<span class="comment">//动态开点的不同，le和ri记录的是左端点和右端点的p值 </span></span><br><span class="line"><span class="comment">//tr记住稍微大一点 （别 MLE 了 ），反正不会错 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x==y.x?x.d&gt;y.d:x.x&lt;y.x;</span><br><span class="line">&#125;<span class="comment">//sort的细节*** </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[p].le) tr[p].le=++cnt;<span class="comment">//没点开点 </span></span><br><span class="line">    <span class="keyword">if</span>(!tr[p].ri) tr[p].ri=++cnt;</span><br><span class="line">    tr[tr[p].le].w+=k,tr[tr[p].ri].w+=k;</span><br><span class="line">    tr[tr[p].le].tag+=k,tr[tr[p].ri].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;<span class="comment">//没点开点 </span></span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p].w+=k,tr[p].tag+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag) push_down(p,tr[p].tag);tr[p].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) add(nl,nr,l,mid,tr[p].le,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) add(nl,nr,mid+<span class="number">1</span>,r,tr[p].ri,k);</span><br><span class="line">    tr[p].w=max(tr[tr[p].le].w,tr[tr[p].ri].w);</span><br><span class="line">&#125;<span class="comment">//与线段树相同 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">    scan(n);scan(w),scan(h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,v;i&lt;=n;i++)</span><br><span class="line">        scan(x),scan(y),scan(v),lim=max(x+w+<span class="number">1</span>,lim),<span class="comment">//lim是线段树范围 </span></span><br><span class="line">        a[(i&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>]=(node)&#123;x,y,y+h<span class="number">-1</span>,v,<span class="number">1</span>&#125;,<span class="comment">//强行转换格式，-1的细节** </span></span><br><span class="line">        a[i&lt;&lt;<span class="number">1</span>]=(node)&#123;x+w<span class="number">-1</span>,y,y+h<span class="number">-1</span>,v,<span class="number">-1</span>&#125;;<span class="comment">//细节** </span></span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+<span class="number">2</span>*n);<span class="comment">//细节** </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        add(a[i].l,a[i].r,<span class="number">1</span>,lim,root,a[i].w*a[i].d);</span><br><span class="line">        ans=max(ans,tr[root].w);<span class="comment">//直接用整棵树更新就好啦 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(t);</span><br><span class="line">    <span class="keyword">while</span>(t--) work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扫描线2种方法都已经讲完，可以再找一些题练习一下；</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>悬线法</title>
    <url>/2019/10/25/%E6%82%AC%E7%BA%BF%E6%B3%95/</url>
    <content><![CDATA[<p>例题 P1169 [ZJOI2007]棋盘制作</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8×88 \times 88×8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。</p><p>而我们的主人公<code>小Q</code>，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友<code>小W</code>决定将棋盘扩大以适应他们的新规则。</p><a id="more"></a>


<p><code>小Q</code>找到了一张由N×MN \times MN×M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。<code>小Q</code>想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。</p>
<p>不过<code>小Q</code>还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。</p>
<p>于是<code>小Q</code>找到了即将参加全国信息学竞赛的你，你能帮助他么？</p>
<h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p><strong>输入格式：</strong></p>
<p>包含两个整数NNN和MMM，分别表示矩形纸片的长和宽。接下来的NNN行包含一个N ×MN  \times MN ×M的010101矩阵，表示这张矩形纸片的颜色（000表示白色，111表示黑色）。</p>
<p><strong>输出格式：</strong></p>
<p>包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。</p>
<p>审题可以发现，我们所以寻找的最大矩形其实已经含有正方形，所以不需要单独去寻找，但是当时我只想到如何DP求正方形，所以分开写了；</p>
<p>这里就引进一个概念——<strong>悬线法</strong></p>
<h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a><strong>用途：</strong></h2><p>　　<strong>求满足条件的最大矩形或正方形</strong></p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a><strong>方法：</strong></h2><p>　　通过不断更新矩形左右端点所能到达的距离（1 ： 初始化；2：dp中更新）</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h2><p>　　left [ i ] [ j ] 数组更新包含第（i，j）点的最左能到达距离；</p>
<p>　　right [ i ] [ j ] 数组更新包含第（i，j）点的最右能到达距离；</p>
<p>　　up [ i ] [ j ] 数组更新包含第（i，j）点的向上能到达的距离；</p>
<p>　　PS：为什么没有下？因为down可以在dp中用up代替；</p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h2><p>　　1：初始化 left 和 right 数组</p>
<p>　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=m-1;j&gt;0;j--)&#123;</span><br><span class="line">            if(maps[i][j]!=maps[i][j+1])//判断条件 </span><br><span class="line">                right[i][j]=right[i][j+1];</span><br><span class="line">        &#125;//右端点从右往左更新 </span><br><span class="line">        for(int j=2;j&lt;=m;j++)&#123;</span><br><span class="line">            if(maps[i][j-1]!=maps[i][j])</span><br><span class="line">                left[i][j]=left[i][j-1];</span><br><span class="line">        &#125;//左端点从左往右更新 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　2：DP更新 up 数组和 left，right 数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;maps[i][j]!=maps[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">            left[i][j]=max(left[i][j],left[i<span class="number">-1</span>][j]);<span class="comment">//由上更新 </span></span><br><span class="line">            right[i][j]=min(right[i][j],right[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="comment">//左取大，右取小 </span></span><br><span class="line">            up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=right[i][j]-left[i][j]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b=min(a,up[i][j]);</span><br><span class="line">        ans1=max(ans1,b*b);<span class="comment">//正方形做法2 </span></span><br><span class="line">        ans2=max(ans2,a*up[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　思考：该方法的正确性，因为每个点都取到了一次，每次选取最优解，则正解定会取到</p>
<p><strong>完整Code</strong>（附有正方形另类做法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,maps[maxn][maxn],ans1;</span><br><span class="line"><span class="keyword">int</span> f1[maxn][maxn],ans2,up[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> left[maxn][maxn],right[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cube</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=maps[i][j];</span><br><span class="line">            <span class="keyword">if</span>(x==maps[i<span class="number">-1</span>][j]||x==maps[i][j<span class="number">-1</span>]||x!=maps[i][j])&#123;</span><br><span class="line">                f1[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                f1[i][j]=min(f1[i<span class="number">-1</span>][j],min(f1[i][j<span class="number">-1</span>],f1[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans1=max(f1[i][j],ans1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans1*=ans1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maps[i][j]);</span><br><span class="line">            left[i][j]=j,right[i][j]=j;</span><br><span class="line">            up[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cube();<span class="comment">//正方形的做法1 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[i][j]!=maps[i][j+<span class="number">1</span>])<span class="comment">//判断条件 </span></span><br><span class="line">                right[i][j]=right[i][j+<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="comment">//右端点从右往左更新 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[i][j<span class="number">-1</span>]!=maps[i][j])</span><br><span class="line">                left[i][j]=left[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="comment">//左端点从左往右更新 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;maps[i][j]!=maps[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                left[i][j]=max(left[i][j],left[i<span class="number">-1</span>][j]);<span class="comment">//由上更新 </span></span><br><span class="line">                right[i][j]=min(right[i][j],right[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="comment">//左取大，右取小 </span></span><br><span class="line">                up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a=right[i][j]-left[i][j]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b=min(a,up[i][j]);</span><br><span class="line">            ans1=max(ans1,b*b);<span class="comment">//正方形做法2 </span></span><br><span class="line">            ans2=max(ans2,a*up[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结与反思；正确灵活使用，可以快速解决问题；</p>
]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/2019/10/25/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>。。。。</p><p>有点懒；</p><p>需要先理解几个概念：</p><ol>
<li><p>LCA</p>
</li>
<li><p>线段树（熟练，要不代码能调一天）</p>
</li>
<li><p>图论的基本知识（dfs序的性质）</p>
</li>
</ol><p>这大概就好了；</p><p><strong>定义</strong>：</p><p>　　1.重儿子：一个点所连点树size最大的，这个son被称为这个点的重儿子；</p><p>　　2.轻儿子：一个点所连点除重儿子以外的都是轻儿子；</p><p>　　3.重链：从一个轻儿子或根节点开始沿重儿子走所成的链；</p><a id="more"></a>








<p><strong>步骤</strong>：</p>
<p>　　在代码里，结合代码更清晰。。。（其实是太懒了）</p>
<p>　有重点需要注意的东西在code中有提到，仔细看。。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,root,mod,a[maxn],head[maxn],fa[maxn],son[maxn],cnt,tag[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//a：原始点值，fa：父亲节点，son：重儿子，tag：懒标记 </span></span><br><span class="line"><span class="keyword">int</span> top[maxn],sz[maxn],id[maxn],dep[maxn],w[maxn],cent,tr[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//top：所在重链的头结点，sz：子树大小，id：dfs序，dep：深度 </span></span><br><span class="line"><span class="comment">//w：dfs序所对应的值（建线段树），tr：线段树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------------线段树红色预警 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[p]=tr[le(p)]+tr[re(p)];</span><br><span class="line">    tr[p]%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[p]=w[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p));</span><br><span class="line">    build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[le(p)]+=k*(mid-l+<span class="number">1</span>),tr[re(p)]+=k*(r-mid);</span><br><span class="line">    tr[le(p)]%=mod,tr[re(p)]%=mod;</span><br><span class="line">    tag[le(p)]+=k,tag[re(p)]+=k;</span><br><span class="line">    tag[le(p)]%=mod,tag[re(p)]%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p]+=k*(r-l+<span class="number">1</span>);tag[p]+=k;</span><br><span class="line">        tr[p]%=mod,tag[p]%=mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) r_add(nl,nr,l,mid,le(p),k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) r_add(nl,nr,mid+<span class="number">1</span>,r,re(p),k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">r_query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r) <span class="keyword">return</span> tr[p];</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=r_query(nl,nr,l,mid,le(p)),ans%=mod;</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=r_query(nl,nr,mid+<span class="number">1</span>,r,re(p)),ans%=mod;</span><br><span class="line">    push_up(p);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------线段树结束</span></span><br><span class="line"><span class="comment">//-----------------------------------------------------开始预处理 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;<span class="comment">//sz初始化 </span></span><br><span class="line">    <span class="keyword">int</span> max_part=<span class="number">-1</span>;<span class="comment">//max_part更新寻找重儿子 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x,dep[y]+=dep[x]+<span class="number">1</span>;<span class="comment">//更新子节点，准备开始继续dfs1 </span></span><br><span class="line">        dfs1(y);sz[x]+=sz[y];<span class="comment">//更新自身的sz数组 </span></span><br><span class="line">        <span class="keyword">if</span>(max_part&lt;sz[y]) son[x]=y,max_part=sz[y];<span class="comment">//更新重儿子 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*dfs1功能介绍</span></span><br><span class="line"><span class="comment">1.更新fa数组；</span></span><br><span class="line"><span class="comment">2.更新dep数组；</span></span><br><span class="line"><span class="comment">3.更新sz数组； </span></span><br><span class="line"><span class="comment">4.更新son数组； </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[x]=++cnt,w[cnt]=a[x],top[x]=t;<span class="comment">//更新dfs序，dfs序所对的值，重链头节点 </span></span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*dfs2功能介绍</span></span><br><span class="line"><span class="comment">1.更新id数组；</span></span><br><span class="line"><span class="comment">2.更新w数组；</span></span><br><span class="line"><span class="comment">3.更新top数组</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------预处理结束 </span></span><br><span class="line"><span class="comment">//------------------------------------------------开始主要操作 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实没有说的这么简单，这里重点是理解重链之间的跳跃方式，线段树的优化 </span></span><br><span class="line"><span class="comment">//一个性质：重链上的dfs序是连续的，dfs1在dfs2前的原因就在此 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">road_query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);<span class="comment">//从最下面往上跳 </span></span><br><span class="line">        ans+=r_query(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//更新重链 </span></span><br><span class="line">        ans%=mod;</span><br><span class="line">        x=fa[top[x]];<span class="comment">//跳到重链头的fa </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    ans+=r_query(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//已经在同一条重链上，直接加 </span></span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>)%mod;</span><br><span class="line">&#125;<span class="comment">//一个性质：在同一颗子树上的dfs序是连续的 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">road_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        r_add(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    r_add(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//类比 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//相同的性质 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------树链剖分 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m),scan(root),scan(mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        scan(u),scan(v),add(u,v),add(v,u);</span><br><span class="line">    dfs1(root),dfs2(root,root),build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> type,x,y,z;</span><br><span class="line">        scan(type);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>) scan(x),scan(y),scan(z),</span><br><span class="line">            road_add(x,y,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>) scan(x),scan(y),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,road_query(x,y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>) scan(x),scan(z),</span><br><span class="line">            tree_add(x,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">4</span>) scan(x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tree_query(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，可以开始调代码了</p>
<h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>　　树链剖分，作为一个优秀的暴力结构，以O（n logn logn）的时间复杂度完成路径查询，在子树查询做到了nlogn级别，所以不得不说其优秀；</p>
<p>　　但是，它的作用远不及此：</p>
<h3 id="1-LCA查询："><a href="#1-LCA查询：" class="headerlink" title="　　1.LCA查询："></a>　　1.LCA查询：</h3><p>　　　　与倍增相同，树链剖分可以用logn的时间复杂度完成LCA查询（跳跃性好像更优），而他的初始化是两遍dfs O（n），理论上更优。</p>
<p>　　　　可以猜测，LCA依旧运用重链跳法，然后比较即可，这里给出示范代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">&#125;<span class="comment">//只要看懂树链剖分的基本操作，这个很简单</span></span><br></pre></td></tr></table></figure>
<p>　　　　可以看到，其实代码很短。。。</p>
<h3 id="2-换根操作："><a href="#2-换根操作：" class="headerlink" title="　　2.换根操作："></a>　　2.换根操作：</h3><p>　　　　设现在的根是root，我们可以发现，换根对于路径上的操作并没有影响，但是子树操作就会影响了，所以我们分类讨论</p>
<p>　　　　　　设u为我们要查的子树的根节点</p>
<p>　　　　　　（1）如果root=u，那么子树即为整棵树；</p>
<p>　　　　　　（2）设 lca 为root和u的LCA，这里可以用上面所讲的树链剖分做，如果lca！=u，那么root并不是u的子节点，所以对于查询并不影响，常规操作即可</p>
<p>　　　　　　（3）如果lca=u，那么u节点的子树就是整颗树减去u-root这个路径上与u相挨的节点v的子树即可，这里给出logn求点v的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//前提条件：要求的节点相挨的节点u，必须是root的LCA </span><br><span class="line">int find(int x,int y)&#123;</span><br><span class="line">    while(top[x]!=top[y])&#123;</span><br><span class="line">        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);//从最下往上跳 </span><br><span class="line">        if(fa[top[x]]==y) return top[x];//如果y是x所在重链top的父亲节点，那么就可以返回了 </span><br><span class="line">        x=fa[top[x]];//跳 </span><br><span class="line">    &#125;</span><br><span class="line">    if(dep[x]&lt;dep[y]) swap(x,y);//让y最浅 </span><br><span class="line">    return son[y];// 因为在一条重链上，那么重儿子一定是路径上与要求节点相挨的 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　　　整个操作的代码层次感我写的还是比较清楚了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">            r_add(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,-k);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>)-r_query(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐评测网站<a href="https://loj.ac/problem/139" target="_blank" rel="noopener">LOJ </a>。。。（因为洛谷没有换根操作）</p>
<h3 id="AC代码附上"><a href="#AC代码附上" class="headerlink" title="AC代码附上"></a>AC代码附上</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ol putchar(<span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],cent,dep[maxn],son[maxn],fa[maxn],vis[maxn];</span><br><span class="line"><span class="keyword">int</span> top[maxn],a[maxn],id[maxn],w[maxn],sz[maxn],cnt,ij,root;</span><br><span class="line">ll tr[maxn&lt;&lt;<span class="number">3</span>],tag[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[p]=tr[le(p)]+tr[re(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[le(p)]+=<span class="number">1l</span>l*(mid-l+<span class="number">1</span>)*k,</span><br><span class="line">    tr[re(p)]+=<span class="number">1l</span>l*(r-mid)*k,</span><br><span class="line">    tag[le(p)]+=k,tag[re(p)]+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[p]=w[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p));</span><br><span class="line">    build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p]+=<span class="number">1l</span>l*(r-l+<span class="number">1</span>)*k;</span><br><span class="line">        tag[p]+=<span class="number">1l</span>l*k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) r_add(nl,nr,l,mid,le(p),k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) r_add(nl,nr,mid+<span class="number">1</span>,r,re(p),k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">r_query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r) <span class="keyword">return</span> tr[p];</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=r_query(nl,nr,l,mid,le(p));</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=r_query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;<span class="keyword">int</span> max_part=<span class="number">-1</span>;vis[x]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">        dfs1(y);sz[x]+=sz[y];</span><br><span class="line">        <span class="keyword">if</span>(max_part&lt;sz[y]) son[x]=y,max_part=sz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[x]=++cnt;w[cnt]=a[x];top[x]=t;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==son[x]||fa[x]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">&#125;<span class="comment">//只要看懂树链剖分的基本操作，这个很简单 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前提条件：要求的节点相挨的节点u，必须是root的LCA </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);<span class="comment">//从最下往上跳 </span></span><br><span class="line">        <span class="keyword">if</span>(fa[top[x]]==y) <span class="keyword">return</span> top[x];<span class="comment">//如果y是x所在重链top的父亲节点，那么就可以返回了 </span></span><br><span class="line">        x=fa[top[x]];<span class="comment">//跳 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);<span class="comment">//让y最浅 </span></span><br><span class="line">    <span class="keyword">return</span> son[y];<span class="comment">// 因为在一条重链上，那么重儿子一定是路径上与要求节点相挨的 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">            r_add(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,-k);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>)-r_query(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">road_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        r_add(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    r_add(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">road_query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        ans+=r_query(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    ans+=r_query(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("co.out","w",stdout);</span></span><br><span class="line">    scan(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,v;i&lt;=n;i++) scan(v),add(i,v),add(v,i);</span><br><span class="line">    dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>),build(<span class="number">1</span>,n,<span class="number">1</span>);root=<span class="number">1</span>;</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> type,x,y,z;</span><br><span class="line">        scan(type),scan(x);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>) root=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>) scan(y),scan(z),road_add(x,y,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>) scan(z),tree_add(x,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">4</span>) scan(y),<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,road_query(x,y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tree_query(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队--基于分块的优化</title>
    <url>/2019/10/25/%E8%8E%AB%E9%98%9F-%E5%9F%BA%E4%BA%8E%E5%88%86%E5%9D%97%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="莫队思想浅谈"><a href="#莫队思想浅谈" class="headerlink" title="莫队思想浅谈"></a>莫队思想浅谈</h1><p>莫队，基于分块思想。</p><p>所以说，在学习莫队时可以先了解一下分块的优化原理，这对于莫队的理解会有帮助；</p><p>我们将分层次讲解，难度不断增加，并附有例题。。。（由于博主太烂懒，所以莫队的模板概念知识只会在这里叙述）</p><h2 id="1-莫队："><a href="#1-莫队：" class="headerlink" title="1.莫队："></a><strong>1.莫队：</strong></h2><p>　　基础的莫队是用来解决区间离线查询问题，利用分块原理和排序，将查询时的重叠部分集中以来优化的算法，大多的算法的复杂度为$O(nsqrt(n))$，实际更优；</p><a id="more"></a>



<p>　　莫队代码一般很短，且有套路可言，所以应熟练掌握；</p>
<p>　　表述完毕，开始讲解：</p>
<p>　　<a href="https://www.luogu.org/problem/P1972" target="_blank" rel="noopener">P1972 [SDOI2009]HH的项链</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行：一个整数N，表示项链的长度。</p>
<p>第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。</p>
<p>第三行：一个整数M，表示HH 询问的个数。</p>
<p>接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>M 行，每行一个整数，依次表示询问对应的答案。</p>
<p>　　莫队的一道例题，但是这道题很恶心，数据专门卡了莫队，不过不用担心，我们可以吸口氧，再吸口臭氧，然后再有一些优化就可以A掉（如果实在过不了，后面附上了树状数组代码），然后让我们来讲解；</p>
<p>设第一个查询的区间为[ l1,r1 ] , 第二个查询的区间为[ l2,r2 ]；</p>
<p>既然已经说莫队时暴力结构，那么就能猜到它的统计方式是暴力统计；</p>
<p>引入两个指针 l ，r，首先让 l 移动，让l = l1，移动时进行增加或减去操作，像这道题，是颜色个数的减少或增加，那么暴力统计就可以不说了吧；</p>
<p>在移动到第二个区间时，用同样的操作移动；</p>
<p>但是这个不就是纯暴力了吗，不知道你是否有这样的疑问；</p>
<p>但是当我们将区间分块，再将区间按l，r所在块进行排序，那么每次移动的时间复杂度就变成了sqrt（n）（因为我们分成了sqrt（n）个块）；</p>
<p>这样就应该明白其原理，如果真的还是不懂了话，那么可以看看代码；</p>
<p><strong>Code（带有O2优化，O3优化和排序优化）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="comment">//luogu的O2，NOIP没有 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)<span class="comment">//O3优化，联赛时没有 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ri register int<span class="comment">//指针优化 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,be[maxn],a[maxn],unit,col[maxn*<span class="number">10</span>],ans,l=<span class="number">1</span>,r,prin[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r,id;&#125;q[maxn];<span class="comment">//query的结构体，便于排序 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]^be[b.l]?be[a.l]&lt;be[b.l]:(be[a.l]&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r;</span><br><span class="line">&#125;<span class="comment">//排序小优化 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;col[x]+=d;<span class="keyword">if</span>(d&gt;<span class="number">0</span>)ans+=(col[x]==<span class="number">1</span>);<span class="keyword">if</span>(d&lt;<span class="number">0</span>)ans-=(col[x]==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="comment">//d==1为增加，d==-1为减少 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);unit=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(a[i]),be[i]=i/unit+<span class="number">1</span>;<span class="comment">//分块 </span></span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        scan(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);<span class="comment">//排序 </span></span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(a[l],<span class="number">-1</span>),l++;<span class="comment">//减去l上这个数 </span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(a[l<span class="number">-1</span>],<span class="number">1</span>),l--;<span class="comment">//加上l-1上这个数 </span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(a[r+<span class="number">1</span>],<span class="number">1</span>),r++; </span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(a[r],<span class="number">-1</span>),r--;</span><br><span class="line">        prin[q[i].id]=ans;<span class="comment">//记录答案 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        print(prin[i]),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码至少过了这道题，但是仍然很悬，所以尽可能地优化常数</p>
<p>附上树状数组代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[maxn&lt;&lt;<span class="number">2</span>],a[maxn],cent,col[maxn*<span class="number">10</span>],pre[maxn*<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r,id,ans;&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;<span class="keyword">return</span> a.r==b.r?a.l&lt;b.l:a.r&lt;b.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(query a,query b)</span></span>&#123;<span class="keyword">return</span> a.id&lt;b.id;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x)) tree[x]+=d;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">while</span>(x) ans+=tree[x],x-=lowbit(x);<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(a[i]);</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        scan(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cent&lt;q[i].r)&#123;</span><br><span class="line">            add(++cent,<span class="number">1</span>);</span><br><span class="line">            col[a[cent]]++;</span><br><span class="line">            <span class="keyword">if</span>(col[a[cent]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                add(pre[a[cent]],<span class="number">-1</span>);</span><br><span class="line">                pre[a[cent]]=cent;</span><br><span class="line">                col[a[cent]]--;</span><br><span class="line">            &#125;<span class="keyword">else</span> pre[a[cent]]=cent;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].ans=ask(q[i].r)-ask(q[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        print(q[i].ans),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样应该可以去<a href="https://www.luogu.org/problem/SP3267" target="_blank" rel="noopener">水题</a>了，紫题，不用谢我；</p>
<h2 id="2-带修莫队："><a href="#2-带修莫队：" class="headerlink" title="2.带修莫队："></a><strong>2.带修莫队：</strong></h2><p>例题：<a href="https://www.luogu.org/problem/P1903" target="_blank" rel="noopener">P1903 [国家集训队]数颜色 / 维护队列</a></p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令：</p>
<p>1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p>
<p>2、 R P Col 把第P支画笔替换为颜色Col。</p>
<p>为了满足墨墨的要求，你知道你需要干什么了吗？</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。</p>
<p>第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。</p>
<p>第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p>
<p>　　带修莫队其实没什么，只要查询是离线就别虚，只要加入一个时间指针t即可。</p>
<p>　　但是如果只是单纯的分块了话，可能时间会超，我们看一下分块块数unit，</p>
<p>　　当同l块时，移动需要n<em>unit，当l块之间r携带移动时需要(n^2)/unit，当时间 t 移动时仍然有 l 和 r 块的移动，所以需要 (n^2</em>t)/(unit^2)</p>
<p>　　时间复杂度时三个移动取最大值（因为省略常数），发现如果unit取sqrt（n）时，最坏时间复杂度为n^2，这不是我们所期望的，</p>
<p>　　将t看似为n那么整理第三个为(n^3)/(unit^2)，那么让两两相等，三种情况取最优，发现当unit=n^(2/3)时，时间复杂度最优，为O(n^(5/3))；</p>
<p>　　那么就可以看代码了。。。</p>
<p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ri register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,col[maxn*<span class="number">100</span>],s[maxn],unit,be[maxn],T,l=<span class="number">1</span>,r;</span><br><span class="line"><span class="keyword">int</span> cent,t,ans[maxn],Ans,now[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,Time,id;</span><br><span class="line">&#125;q[maxn];<span class="comment">//查询数组 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">change</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> exfo,New,Old;</span><br><span class="line">&#125;c[maxn];<span class="comment">//change数组 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(be[a.l]!=be[b.l]) <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(be[a.r]!=be[b.r]) <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">    <span class="keyword">return</span> a.Time&lt;b.Time;</span><br><span class="line">&#125;<span class="comment">//不同的排序方式 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;col[x]+=d;<span class="keyword">if</span>(d&gt;<span class="number">0</span>)Ans+=(col[x]==<span class="number">1</span>);<span class="keyword">if</span>(d&lt;<span class="number">0</span>)Ans-=(col[x]==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spe</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;<span class="keyword">if</span>(l&lt;=x&amp;&amp;x&lt;=r) syst(d,<span class="number">1</span>),syst(s[x],<span class="number">-1</span>);s[x]=d;&#125;<span class="comment">//t指针移动方式 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m);unit=<span class="built_in">pow</span>(n,<span class="number">0.666666</span>);<span class="comment">//2/3=0.6666666，6越多越精确 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(s[i]),now[i]=s[i],be[i]=i/unit+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c %d%d"</span>,&amp;type,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="string">'Q'</span>) q[++cent]=(query)&#123;x,y,t,cent&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">'R'</span>) c[++t]=(change)&#123;x,y,now[x]&#125;,now[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+cent,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;    </span><br><span class="line">        <span class="keyword">while</span>(T&lt;q[i].Time) spe(c[T+<span class="number">1</span>].exfo,c[T+<span class="number">1</span>].New),T++;</span><br><span class="line">        <span class="keyword">while</span>(T&gt;q[i].Time) spe(c[T].exfo,c[T].Old),T--;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(s[l],<span class="number">-1</span>),l++;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(s[l<span class="number">-1</span>],<span class="number">1</span>),l--;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(s[r+<span class="number">1</span>],<span class="number">1</span>),r++;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(s[r],<span class="number">-1</span>),r--;</span><br><span class="line">        ans[q[i].id]=Ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-树上莫队："><a href="#3-树上莫队：" class="headerlink" title="3.树上莫队："></a><strong>3.树上莫队：</strong></h2><p>要说树上操作，那么莫队可以操作的有两种类型，第一种是子树统计，第二种是路径统计，那么让我们详细来看；</p>
<p>警告：前方有dfs序和euler序出现；</p>
<h3 id="1-子树统计"><a href="#1-子树统计" class="headerlink" title="1.子树统计"></a><strong>1.子树统计</strong></h3><p>　　这个如果只是一颗子树单纯的统计非常简单，只要一次dfs求出dfs序和子树size即可，你会发现子树上的dfs序时连续的，直接查询一段区间即可；</p>
<p>　　<img src="/images/15.png" alt="alt"></p>
<p>　　有点丑，不要介意，它的dfs序是1 2 3 7 9 4 6 5 8</p>
<p>　　　　2的子树序列即为 2 3 7 9；</p>
<p>　　这个应该不需要再解释了吧。。。</p>
<p>　　但是在两颗子树上统计再加上换根操作是不是很毒瘤，我们在后面会讲到；</p>
<h3 id="2-路径统计"><a href="#2-路径统计" class="headerlink" title="2.路径统计"></a>2.路径统计</h3><p>　　莫队只能维护序列，所以我们将子树转化为dfs序，将其从树中拿出，维护其序列，那么路径上怎么办呢</p>
<p>　　　　我们再拿出这个图（我知道很丑！）</p>
<p>　　　　<img src="/images/16.png" alt="alt"></p>
<p>　　　　不知道euler序？没关系，我解释就行了，euler序将一个数记录两遍，进的时候记录一遍，出的时候记录一遍；</p>
<p>　　　　我们将序列列出来就很清晰了 ： 1 2 3 7 7 9 9 3 4 4 2 6 5 5 8 8 6 1;</p>
<p>　　　　 那么每个数字都出现了两遍，我们设节点 i 在euler序中第一次出现的位置为first [ i ] ，第二次出现的位置为last [ i ] 。</p>
<p>　　　　观察路径2-&gt;9，你会发现路径上first [ 2 ] -&gt; fisrt [ 9 ]：2 3 7 7 9，其中路径上的点都只出现了一次，出现两次的都不在路径上，证明也很简单，这里就不再赘述。</p>
<p>　　　　当然last [ 2 ] -&gt; last [ 9 ]是一样的，只是顺序不一样。</p>
<p>　　　　但是这个只是一种情况——当两个点中有一个点是另一个点子树的一部分，或者问题转换一下一个点是另一个点的LCA，如刚刚的2是9的LCA。</p>
<p>　　　　但是当不在同一颗子树上会发生什么？</p>
<p>　　　　例如3 -&gt; 6：3 7 7 9 9 3 4 4 2 6 5 5 8 8 6，这是3和6出现两次时序列，我们已经发现没有1这个点，我们选取last [ 3 ] -&gt; first [ 6 ]  : 3 4 4 2 6，其中路径上的点3 2 6都出现</p>
<p>　　　　但是1却没有出现，我们可以发现1时LCA（3，6），所以euler序中在这种情况下是没有LCA的，那么我们在统计答案时将其加上，然后再减去。</p>
<p>　　　　两种情况都已经讨论完毕，我们只要在存q数组时做个lca的标记即可。</p>
<p>　　　　这里给出一道　　<strong>例题</strong>　　</p>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个n个节点的树，每个节点表示一个整数，问u到v的路径上有多少个不同的整数。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有两个整数n和m（n＝40000，m＝100000）。</p>
<p>第二行有n个整数。第i个整数表示第i个节点表示的整数。</p>
<p>在接下来的n-1行中，每行包含两个整数u v，描述一条边（u，v）。</p>
<p>在接下来的m行中，每一行包含两个整数u v，询问u到v的路径上有多少个不同的整数。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问，输出结果。</p>
<p> 　　　　</p>
<p>　　　　这是模板测试，只需要分类讨论，直接套莫队；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 40007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ls[maxn],euler[maxn&lt;&lt;<span class="number">1</span>],ans[N],cent,cnt,dep[maxn&lt;&lt;<span class="number">1</span>],num[maxn&lt;&lt;<span class="number">1</span>],l=<span class="number">1</span>,r,now;</span><br><span class="line"><span class="keyword">int</span> first[maxn&lt;&lt;<span class="number">1</span>],last[maxn&lt;&lt;<span class="number">1</span>],b[maxn],fa[maxn&lt;&lt;<span class="number">1</span>][<span class="number">30</span>],be[maxn&lt;&lt;<span class="number">1</span>],vis[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn&lt;&lt;<span class="number">1</span>],unit,col[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,id,lca;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    euler[++cnt]=x;first[x]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][<span class="number">0</span>]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dep[y]+=dep[x]+<span class="number">1</span>;fa[y][<span class="number">0</span>]=x;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">    euler[++cnt]=x;last[x]=cnt;</span><br><span class="line">&#125;<span class="comment">//在完成LCA初始化的同时完成euler序的记录 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">1</span>,fa[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">-1</span>;dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[k][i<span class="number">-1</span>]&lt;<span class="number">0</span>) fa[k][i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> fa[k][i]=fa[fa[k][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,d=dep[x]-dep[y];d;d&gt;&gt;=<span class="number">1</span>,i++)</span><br><span class="line">        <span class="keyword">if</span>(d&amp;<span class="number">1</span>) x=fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">25</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">            y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是倍增求LCA，当然也可以2遍dfs+树剖 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]^be[b.l]?be[a.l]&lt;be[b.l]:(be[a.l]&amp;<span class="number">1</span>?a.r&lt;b.r:a.r&gt;b.r); </span><br><span class="line">&#125;<span class="comment">//排序小优化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] ? now -= (!--num[ls[x]]):now += !num[ls[x]]++;</span><br><span class="line">    <span class="comment">//CASE 1 ：前者减去，而！是为了判断是否应该减取（true=1，false=0） </span></span><br><span class="line">    <span class="comment">//CASE 2 ：后者加上，！同上面所说 </span></span><br><span class="line">    vis[x] ^= <span class="number">1</span>;<span class="comment">//异或操作可以方便的转换出现次数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);unit=<span class="built_in">sqrt</span>(<span class="number">2</span>*n);<span class="comment">//记住euler序是2*n </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ls[i]),b[i]=ls[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> tot=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ls[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+tot,ls[i])-b;</span><br><span class="line">    <span class="comment">//由于数值太大，我们进行离散化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b),add(a,b);</span><br><span class="line">    init();<span class="comment">//初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) be[i]=i/unit+<span class="number">1</span>;<span class="comment">//分块 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,L,R;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;L,&amp;R);</span><br><span class="line">        <span class="keyword">int</span> lca=getlca(L,R);q[i].id=i;</span><br><span class="line">        <span class="keyword">if</span>(first[L]&gt;first[R]) swap(L,R);<span class="comment">//小的在前面哦 </span></span><br><span class="line">        <span class="keyword">if</span>(lca==L)&#123;<span class="comment">//CASE 1 ： </span></span><br><span class="line">            q[i].l=first[L];</span><br><span class="line">            q[i].r=first[R];</span><br><span class="line">            q[i].lca=<span class="number">0</span>;<span class="comment">//不需要考虑LCA </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//CASE 2 ： </span></span><br><span class="line">            q[i].l=last[L];</span><br><span class="line">            q[i].r=first[R];</span><br><span class="line">            q[i].lca=lca;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=q[i].lca;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(euler[l]),l++;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(euler[l<span class="number">-1</span>]),l--;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(euler[r+<span class="number">1</span>]),r++;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(euler[r]),r--;</span><br><span class="line">        <span class="keyword">if</span>(lca) syst(lca);<span class="comment">//判断是否需要考虑LCA </span></span><br><span class="line">        ans[q[i].id]=now;</span><br><span class="line">        <span class="keyword">if</span>(lca) syst(lca);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您已经AC了这几道题，恭喜您已经大概掌握莫队的框架。（这几道题不是小意思嘛，博主太菜了）</p>
<p>由于博主太菜，还没有学回滚莫队，所以这里先不再说（逃ε=ε=ε=┏(゜ロ゜;)┛）</p>
<p>不过这里再留下一道模板题，<a href="https://www.luogu.org/problem/P4074" target="_blank" rel="noopener">糖果公园</a>——带修树上莫队，两种算法相结合，不要虚，虽然是黑题</p>
<p>这里不再附上代码，请原谅。。。</p>
<p><strong>拓展提升</strong></p>
<h2 id="4-双指针莫队"><a href="#4-双指针莫队" class="headerlink" title="4.双指针莫队"></a><strong>4.双指针莫队</strong></h2><p>　　其实这才是莫队的本质，虽然带修莫队是三指针，但是别忘了其时间复杂度还是很难让人接受的（尤其是常数巨大的博主），所以我们还是用双指针的比较多。</p>
<p>　　我们以上看到的莫队是一个区间的查询，一个指针维护l，一个指针维护r，然后再用分块排序；</p>
<p>　　但是当我们遇见了两个区间怎么办？比如说这道题<a href="https://www.luogu.org/problem/P5268" target="_blank" rel="noopener">P5268 [SNOI2017]一个简单的询问</a>，请读者不要被其吓住，这其实只有一个普通莫队的难度，只是需要从原来的思维跳出来</p>
<p>　　真正理解莫队双指针的作用。</p>
<p> <img src="/images/17.png" alt="alt"></p>
<p>　　设该函数为f( l1 , r1 , l2 , r2)，那么可以拆成f（ 1  , l1-1 , 1 , l2-1 ) + f ( 1 , r1, 1 , r2 ) - f (1 , l1-1 , 1 , r2) - f ( 1 , l2 - 1 , 1 , r2 )；</p>
<p>　　这里用到了容斥原理，将区间容斥，那么我们就可以引用莫队，维护两个变量，双指针移动，分块排序（博主太唠叨了）</p>
<p>　　这里附上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],be[maxn],unit,ans[maxn],ol,all;</span><br><span class="line"><span class="keyword">int</span> t[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d,id;</span><br><span class="line">&#125;q[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]==be[b.l]?a.r&lt;b.r:be[a.l]&lt;be[b.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    ol+=t[a[x]][type^<span class="number">1</span>];</span><br><span class="line">    t[a[x]][type]++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    ol-=t[a[x]][type^<span class="number">1</span>];</span><br><span class="line">    t[a[x]][type]--;</span><br><span class="line">&#125;<span class="comment">//简单的操作 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);unit=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]),be[i]=(i<span class="number">-1</span>)/unit+<span class="number">1</span>;</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l1,r1,l2,r2;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(l1),scan(r1),scan(l2),scan(r2);</span><br><span class="line">        q[++all].l=r1,q[all].r=r2,q[all].d=<span class="number">1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l2<span class="number">-1</span>,q[all].r=r1,q[all].d=<span class="number">-1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l1<span class="number">-1</span>,q[all].r=r2,q[all].d=<span class="number">-1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l1<span class="number">-1</span>,q[all].r=l2<span class="number">-1</span>,q[all].d=<span class="number">1</span>,q[all].id=i;</span><br><span class="line">    &#125;<span class="comment">//拆成四个询问 ，id一样 </span></span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+all,cmp);<span class="comment">//排序是一样的 </span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) add(++l,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) del(l--,<span class="number">0</span>);<span class="comment">//两个指针要分开标记用1和0即可（可以异或） </span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) add(++r,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) del(r--,<span class="number">1</span>);</span><br><span class="line">        ans[q[i].id]+=ol*q[i].d;<span class="comment">// 4个询问最后会累加在一起 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Guass初步</title>
    <url>/2019/10/25/Guass%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>Gauss算法，称为高斯消元算法，用来解决n元一次方程，在解决线性方程问题起着重要作用。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h2><p>　　运用高斯消元的方法，我们可以在O(n3)的时间求出n元线性方程，但是由于时间复杂度的原因，请注意题目数据范围的提示。</p><p>　　<strong>高斯消元三大定理（在小学就学过了吧）：</strong></p><p>　　　　1.两个方程互换位置，解不变；</p><p>　　　　2.一个方程进行加减乘除，解不变；</p><a id="more"></a>




<p>　　　　3.一个方程乘上数k加上另一个方程，解不变；</p>
<p>　　这便是我们解决的基础；</p>
<h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a><strong>过程：</strong></h2><p>　　这里给出<a href="https://www.luogu.org/problem/P3389" target="_blank" rel="noopener">luogu例题链接</a>，这样方便寻找；</p>
<p>　　我们这里不用luogu的样例示范（因为不是整数好麻烦），这里给出方程</p>
<p>　　2 x + 3 y - z = 21;</p>
<p>　　x + 2 y + 2 z = 7;</p>
<p>　  3 x + y + 5 z = 8;　</p>
<p>　　我们将系数提出，然后就可以得到一个3 * 3的矩阵，之后将每个方程等号右边放到矩阵的最右边，就得到了：</p>
<p>　　<img src="/images/18.png" alt="alt"></p>
<p>　　这里每个方程的结果与系数我用黑线隔开了，想必也更清楚；</p>
<p>　　有了定理，我们理一下目标：</p>
<p>　　我们如果将每一个方程只留下一个未知数的系数，那么最后就可以求解了，如：</p>
<p>　　<img src="/images/19.png" alt="alt"></p>
<p>　　当然系数不一定只会是1，但是只要除一下就好，根据这个定义，我们将第 i 个未知数的前系数非零而且其他系数都为零，这个系数在矩阵的位置为 i ，i；</p>
<p>　　这样的矩阵称为“简化阶梯矩阵”；</p>
<p>　　我们只要将每个矩阵化成简化阶梯矩阵即可；</p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h2><p>　　1.枚举第 i 个未知数（外循坏）；</p>
<p>　　2.决定在哪一行求解这个未知数：</p>
<p>　　　　这里采用先对每一行 j 第 i 个系数找到最大值，有最大值的这一行定义为第ms行（名字随便起的，没有其他意思），然后将第ms行交换至第 i 行</p>
<p>　　3.判断第i行第i个数的值是否为0，这里由于数学期望和精度问题，我们将这个判断改为这个数的值是否小于我们定义的那个精度，如果小于（那就相当于为0了），</p>
<p>　　　　那么无解（因为这个项的系数是所有中最大的，所以其他的也都为0，一定无解）；</p>
<p>　　4.然后进行消元，就是将其他方程这个项的系数归0，这里有精度问题，但是从期望来讲，是不成问题的；</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a><strong>Code：</strong></h2><p>　　（我才不会说其实我有模拟操作但是太麻烦不想写了。。。）</p>
<p>　　不过我很良心，所以我有输出模拟，运行一下我的代码就行了；</p>
<p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> db cmp=<span class="number">1e-8</span>;</span><br><span class="line">db a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟啦 biu~</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"work %d \n"</span>,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ms=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt;<span class="built_in">fabs</span>(a[ms][i]))</span><br><span class="line">                ms=j;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[ms][i])&lt;cmp)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            swap(a[i][j],a[ms][j]);</span><br><span class="line">        biu(<span class="number">2</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">            db rate=a[j][i]/a[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)</span><br><span class="line">                a[j][k]-=a[i][k]*rate;</span><br><span class="line">        &#125;</span><br><span class="line">        biu(<span class="number">4</span>);<span class="comment">//良心模拟。。。 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,a[i][n+<span class="number">1</span>]/a[i][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong>例题</strong></h2><p>　　<a href="https://www.luogu.org/problem/P4035" target="_blank" rel="noopener">P4035 [JSOI2008]球形空间产生器</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个球形空间产生器能够在 nnn 维空间中产生一个坚硬的球体。现在，你被困在了这个 nnn 维球体中，你只知道球面上 n+1n+1n+1 个点的坐标，你需要以最快的速度确定这个 nnn 维球体的球心坐标，以便于摧毁这个球形空间产生器。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数 nnn (1&lt;=N=10)(1&lt;=N=10)(1&lt;=N=10)。接下来的 n+1n+1n+1 行，每行有 nnn 个实数，表示球面上一点的 nnn 维坐标。每一个实数精确到小数点后 666 位，且其绝对值都不超过 200002000020000。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>有且只有一行，依次给出球心的 nnn 维坐标（ nnn 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 333 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。</p>
<p>　　这个只要构造出矩阵即可；</p>
<p>　　可惜我不会在博客上用数学公式。。。</p>
<p>　　所以就随便写写了；</p>
<p>　　设xi为第i维的坐标；</p>
<p>　　sum(j=1,n) { (a[ i , j ] - x [ j ]) }=r^2;</p>
<p>　　这样的方程共有11个，我们要将r消掉，所以将相邻的两个方程相减，得到11个方程，然后将多项式拆开，合并，移项得到；</p>
<p>　　sum(j=1,n){ 2<em>(a[ i , j ] - a[ i + 1 , j ) </em> x [ j ] } = sum(j=1,n){ a[ i , j ] - a[ i + 1 , j ] };</p>
<p>　　这样就可以将左边的作为方程左边，右边作为结果，列出矩阵，这里还不需要检验，直接上代码。。。</p>
<p>　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">db a[<span class="number">17</span>][<span class="number">17</span>],c[<span class="number">17</span>][<span class="number">17</span>];</span><br><span class="line"><span class="keyword">const</span> db cmp=<span class="number">1e-8</span>;</span><br><span class="line"><span class="function">db <span class="title">calc</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            c[i<span class="number">-1</span>][j]=<span class="number">2</span>*(a[i<span class="number">-1</span>][j]-a[i][j]);</span><br><span class="line">            c[i<span class="number">-1</span>][n+<span class="number">1</span>]+=calc(a[i<span class="number">-1</span>][j])-calc(a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ms=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(c[j][i])&gt;<span class="built_in">fabs</span>(c[ms][i])) ms=j;</span><br><span class="line">        <span class="keyword">if</span>(ms!=i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            swap(c[i][j],c[ms][j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            db rate=c[j][i]/c[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)</span><br><span class="line">                c[j][k]-=c[i][k]*rate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%.3f "</span>,c[i][n+<span class="number">1</span>]/c[i][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有一些拓展内容，到时候再补充。。。</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>manacher</title>
    <url>/2019/10/25/manacher/</url>
    <content><![CDATA[<p>manacher算法的由来不再赘述，自行百度QWQ。。。</p><p>进入正题，manacher算法是一个高效的计算回文串的算法，回文串如果不知道可以给出一个例子：“ noon ”，这样应该就很清晰了；</p><p>其实这个算法虽然名字长，但是实际代码很短，而且理解起来并不难。。。（连我这种蒟蒻都懂了）</p><p>这里给出<a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">模板题</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.</p><a id="more"></a>




<p>字符串长度为n</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一行小写英文字符a,b,c…y,z组成的字符串S</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数表示答案</p>
<p>　　其中n的范围为11000000，很显然，只能是$O(n)$的复杂度，但是为何复杂度这么优秀，这里在讲完算法之后会简述。</p>
<p><strong>定理：</strong></p>
<ul>
<li>　　一个回文串只有一个对称中心，这个中心上可能有字母或者没有（如果没有字母，我们可以再加上一个，再后面会解释），我们暂且定义其为mid；</li>
<li>　　mid两端的区间对称，两边全等（回文串的定义）；</li>
<li>　　如果一个大的回文串一端的区间中有回文串，我们先定义它的中心为 i ，那么大回文串的另一端一定会有相同的回文串；</li>
<li>　　根据上一条，如果我们要更新在右端区间的回文串，那么在左边的回文串半径就可以更新右边的，但是有大回文串的区间限制，所以应当两者取min；</li>
<li>　　结束上面定理的继承之后，直接暴力枚举检查是否两端更新。</li>
</ul>
<p><strong>解释：</strong></p>
<p>　　上面的原理毕竟太过干，只是纯理论，所以制图说明；</p>
<p>　　<img src="/images/14.png" alt="alt"></p>
<p>　　比如说这个区间是一个大回文串，我们我们用r保留其有边界，那么l就可以根据中点坐标公式变形得到mid*2 - r，所以我们只保留右边界 r 即可。</p>
<p>　　那么可以看见，如果我们以 i 为这段区间中一个回文串的中心，那么，与它对称的回文串中心就可以求出（根据中点公式，得2*mid - i ，与上面相同）；</p>
<p>　　那么我们就可以根据定理来继承左边回文串的半径，但是如果左边这个回文串有超过区间的部分怎么办？</p>
<p>　　这里就用到我们所说的取min了，将左边回文串半径和r - i相比取min，这里就得到了 i 的一个半径，但这个半径一定小于或等于真实半径，所以还需暴力枚举；</p>
<p>　　这里就可见manachar算法的核心操作了，就是枚举回文串中心，然后继承半径以来减少枚举的次数；</p>
<p>　　我们用p[ i ]表示以点 i 为中心的回文串的半径，r记录回文串到达的最右边的坐标，mid随之更新，记录这个回文串的中心；</p>
<p><strong>Code</strong></p>
<p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 22000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> dat[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn],r,cnt=<span class="number">1</span>,mid,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s=getchar();</span><br><span class="line">    dat[<span class="number">0</span>]=<span class="string">'~'</span>;<span class="comment">//为了不超出边界的小操作 </span></span><br><span class="line">    dat[<span class="number">1</span>]=<span class="string">'|'</span>;<span class="comment">//这个间隔解决了对称中心没有字母的情况 </span></span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'a'</span>&amp;&amp;s&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">        dat[++cnt]=s;</span><br><span class="line">        dat[++cnt]=<span class="string">'|'</span>;</span><br><span class="line">        s=getchar();</span><br><span class="line">    &#125;<span class="comment">//其实与读入优化没差啦 </span></span><br><span class="line">&#125;<span class="comment">//自定义读入 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;i) p[i]=min(p[<span class="number">2</span>*mid-i],r-i);<span class="comment">//由对称的回文串继承，用r-i限制 </span></span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">1</span>;<span class="comment">//CASE ：无法继承 </span></span><br><span class="line">        <span class="keyword">while</span>(dat[i-p[i]]==dat[i+p[i]]) p[i]++;<span class="comment">//暴力更新 </span></span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;r) r=p[i]+i,mid=i;<span class="comment">// r边界必须是最右 </span></span><br><span class="line">        ans=max(ans,p[i]);<span class="comment">//更新答案 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans<span class="number">-1</span>);<span class="comment">//这个减一可以自己模拟一下，数学推了话好麻烦的说 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是manachar算法的简述了，当然这里解释一下为什么复杂度为O（n）：</p>
<p>　　我感觉这和KMP复杂度有些类似，因为这里因为继承的缘故，所以每个点更新次数较少，然后均摊到每个循环，那么复杂度就变成了$O(n)$了；</p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2019/10/25/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>先存代码</p><h2 id="AC自动机（简单版）"><a href="#AC自动机（简单版）" class="headerlink" title="AC自动机（简单版）"></a>AC自动机（简单版）</h2><p>　　</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> tr[maxn][<span class="number">28</span>],val[maxn],cnt,fail[maxn];</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;</span><br><span class="line">&#125;<span class="comment">//建树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);<span class="comment">//26个字母跑 </span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);<span class="comment">//调取指针 </span></span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];<span class="comment">//建立“虚边”——指向失配指针的i边</span></span><br><span class="line">            <span class="comment">//这里已经改变了trie图 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ol=<span class="number">0</span>,u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)&#123;</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=u;j&amp;&amp;val[j]!=<span class="number">-1</span>;j=fail[j])</span><br><span class="line">            ol+=val[j],val[j]=<span class="number">-1</span>;<span class="comment">//fail跳（这样其实很慢） </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("co.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod),build(mod);</span><br><span class="line">    AC();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);ans=query(tx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="AC自动机（加强版）"><a href="#AC自动机（加强版）" class="headerlink" title="AC自动机（加强版）"></a>AC自动机（加强版）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,ans;</span><br><span class="line"><span class="keyword">char</span> mod[maxn][<span class="number">100</span>],tx[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC&#123;</span><br><span class="line">    <span class="keyword">int</span> tr[maxn][<span class="number">27</span>],fail[maxn],tot;</span><br><span class="line">    <span class="keyword">int</span> cnt,val[maxn],num[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span>(tr));</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(fail,<span class="number">0</span>,<span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">        cnt=ans=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tr[now][s[i]-<span class="string">'a'</span>]) tr[now][s[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">            now=tr[now][s[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[now]=id;<span class="comment">//记录id，这个不怕覆盖 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">                <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),<span class="built_in">cerr</span>&lt;&lt;fail[tr[u][i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)&#123;</span><br><span class="line">            u=tr[u][t[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=u;j;j=fail[j])</span><br><span class="line">                <span class="keyword">if</span>(val[j]) num[val[j]]++,ans=max(ans,num[val[j]]);</span><br><span class="line">        &#125;<span class="comment">//还是跳，不过记录的不一样而已 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(ans==num[i]) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,mod[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        AC::Init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod[i]),AC::insert(mod[i],i);</span><br><span class="line">        AC::build();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);</span><br><span class="line">        AC::query(tx);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机（二次加强版）"><a href="#AC自动机（二次加强版）" class="headerlink" title="AC自动机（二次加强版）"></a>AC自动机（二次加强版）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn];</span><br><span class="line"><span class="keyword">int</span> fail[maxn],tr[maxn][<span class="number">27</span>],val[maxn],num[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn],cnt,in[maxn],to[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;id[idx]=now;<span class="comment">//记录 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),in[fail[tr[u][i]]]++;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>],num[u]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v=fail[u];q.pop();</span><br><span class="line">        num[v]+=num[u];--in[v];</span><br><span class="line">        <span class="keyword">if</span>(!(in[v])) q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这里是跟题解学的topu,效率也挺高 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod),insert(mod,i);</span><br><span class="line">    build();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);query(tx);</span><br><span class="line">    topu(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num[id[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> fail[maxn],tr[maxn][<span class="number">28</span>],val[maxn],num[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn],cnt,in[maxn],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;id[idx]=now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),in[fail[tr[u][i]]]++;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>],num[u]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v=fail[u];q.pop();</span><br><span class="line">        num[v]+=num[u];--in[v];</span><br><span class="line">        <span class="keyword">if</span>(!(in[v])) q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(a),len2=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len1;i&lt;len1+len2;i++)</span><br><span class="line">        a[i]=b[i-len1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c),work(mod,c),</span><br><span class="line">        tot=<span class="built_in">strlen</span>(mod),insert(c,i),mod[tot++]=<span class="string">'&#123;'</span>;</span><br><span class="line">    build();</span><br><span class="line">    query(mod);topu();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num[id[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>math collect</title>
    <url>/2019/10/25/math-collect/</url>
    <content><![CDATA[<h2 id="EXGCD"><a href="#EXGCD" class="headerlink" title="EXGCD"></a>EXGCD</h2><p>　　我们在遇见不定方程的时候，总会一筹莫展，但是EXGCD为我们提供了方法，如同</p><p>　　$ a x + b y = c $   </p><p>　　那么我们先从这个这个式子出发：</p><p>　　$ax+by=gcd(a,b)$ 　　 $(1)$</p><p>　　我们不妨设出另一个式子</p><p>　　$ b x_{0}+(a \% b)y_{0}=gcd(b,a \% b)$ 　　 $(2)$</p><a id="more"></a>





<p>　　Because $gcd(a,b)= gcd ( b , a \% b ) $ ,thus:</p>
<p>　　(a x+b y=bx_{0}+a \% b y_{0})</p>
<p>　　(a x+b y=bx_{0} +(x-a/b \times y_{0}))</p>
<p>　　(a x+b y=ay_{0} +b(x-a/b \times y_{0}))</p>
<p>　　根据乘法等式，相对应系数的未知数相等，那么就可以得到：</p>
<p>　　$x=y_{0}　　y=x-a/b*y_{0}$　　</p>
<p> 　　那么在求gcd的过程中，我们可以在其中不断求解，但是递归到底时返回的x，y值是多少？</p>
<p>　　我们令在b=0时，带入（1）式，那么得到</p>
<p>　　$ax = a$,我们令x=1,y=0即可。</p>
<p>　　然后思考如何求解一开始的那个式子：</p>
<p>　　若有$ax+by=c$，则设$ax_{0}+by_{0}=c$,</p>
<p>　　两式相减：$a(x-x_{0})+b(y-y_{0})=0$</p>
<p>　　移项，除以gcd(a,b):$\frac{a}{gcd(a,b)}(x-x_{0})= - \frac{b}{gcd(a,b)}(y-y_{0})$</p>
<p>　　因为$gcd(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1$</p>
<p>　　所以$\frac{b}{gcd(a,b)}$可以整除$(x-x_{0})$</p>
<p>　　即 $\frac{b}{gcd(a,b)} \times t=(x-x_{0}), t \in Z$</p>
<p>　　对于任意x，都可以表示为</p>
<p>　　$x=x_{0}+\frac{b}{gcd(a,b)}$</p>
<p>　　那么根据exgcd求出的特解且$t \in Z$，我们可以这样求出最小解：</p>
<p>　　$x_{min}=x \%(\frac{b}{gcd(a,b)})$</p>
<p>　　在代码中的写法可以是</p>
<p>　　</p>
<p>　mod=b/gcd(a,b),ans=(x%mod+mod)%mod</p>
<p>　　那么这样我们就解决了$ax+by=gcd(a,b)$最小解问题。</p>
<p>　　如果是$ax+bx=c$，只需要两边乘上$\frac{c}{gcd(a,b)}$即可；</p>
<p> 　　这里附上 <a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">例题</a> </p>
<p>　　并给出模板Code：</p>
<p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,L,t1,t2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="comment">//更新特解 </span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> t=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=t-(a/b)*y;<span class="comment">//公式迭代 </span></span><br><span class="line">    <span class="keyword">return</span>  d;<span class="comment">//return gcd  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;t1,&amp;t2,&amp;n,&amp;m,&amp;L);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;n) swap(m,n),swap(t1,t2);<span class="comment">//由于exgcd函数默认a，b为正整数，所以要换一下 </span></span><br><span class="line">    <span class="keyword">int</span> gcd=exgcd(m-n,L,x,y);</span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;x*((t1-t2)/gcd)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">if</span>((t1-t2)%gcd!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>); <span class="comment">//根据推论，应当满足等式两端成立 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(<span class="number">1l</span>l*x*((t1-t2)/gcd)%(L/gcd)+L/gcd)%(L/gcd));<span class="comment">//正负处理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><p>　　这里给出定理的内容，我大概描述一下：</p>
<p>　　对于$a,b$两个整数,且$gcd(a,b)=d$，那么对于任意的$x,y ,ax+by$是d的倍数。</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>euler</title>
    <url>/2019/10/25/euler/</url>
    <content><![CDATA[<h2 id="euler函数"><a href="#euler函数" class="headerlink" title="euler函数"></a>euler函数</h2><p>euler函数是表示从1~n中与n互质的个数，互质的定义简单提一下，$gcd(a,b)=1$。</p><p>那么如何求一个数的euler函数？</p><p>我们可以将每个数与n求gcd一下，如果gcd为1，则贡献加1，时间复杂度为 $O(n logn)$，极其优秀（雾）</p><p>那么来思考更加优秀的算法（为什么一定要求euler函数($\varphi(n)$函数)呢QAQ）</p><a id="more"></a>



<h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><p>在算法基本定理中，$N=p1^{c1}<em>p2^{c2}</em>p3^{c3}…$，其中pi为质因数，那么：</p>
<script type="math/tex; mode=display">
\varphi(N)=N*\frac{p1-1}{p1}*\frac{p2-1}{p2}...=\frac{pn-1}{pn}=N*\prod_{p|n} \frac{p-1}{p}</script><p>简单证明：</p>
<p>设p是N的质因子，那么显然p的倍数与N不互质，这些数分别是$p<em>1,p</em>2…p*N/p$，</p>
<p>显然有N/p个，那么我们可以减去这N/p个。设q是N的质因子，那么同理，q的倍数的个数有N/q个，那么在这N/p和N/q个当中有同时是p和q的倍数的，而我们多减了一次，我们容斥一下可以得到：</p>
<script type="math/tex; mode=display">
\varphi(N)=N-N/p-N/q+N/pq=N*(q-1)/q*(p-1)/p</script><p>那么推广到全部即可；</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们可以枚举其质因数，不用素数筛，当中我们可以直接用自然数筛，将N中所有的该数倍数筛掉，那么之后的合数必然是之前质因数的组合乘积，但是我们已经筛掉，所以不可能筛到合数，并且我们只用筛到$\sqrt{n}$即可，这个证明较简单，不再赘述。</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,lim,ans;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	lim=sqrt(n),ans=n;</span><br><span class="line">	for(int i=2;i&lt;=lim;i++)</span><br><span class="line">		if(!(n%i))&#123;</span><br><span class="line">			ans=ans/i*(i-1);</span><br><span class="line">			while(!(n%i)) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	if(n&gt;1) ans=ans/n*(n-1);//质因数大于sqrt(n) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote>
<p>1.如果n&gt;1，1~n中与n互质的数的和为$n*\varphi(n)/2$</p>
</blockquote>
<p>简单证明：</p>
<p>根据更相减损术可得，$gcd(a,b)=gcd(a,a-b)$，那么与n互质的数成对出现，则平均数为n/2，那么易得到结论；</p>
<p>2.如果a,b互质,$\varphi(ab)=\varphi(a)\varphi(b)$</p>
<p>简单证明：</p>
<p>根据euler函数的计算公式可得：</p>
<script type="math/tex; mode=display">
\varphi(ab)=ab*\prod_{p|ab}(p-1)/p=a*\prod_{p|a}(p-1)/p *b*\prod_{p|b}(p-1)/p=\varphi(a)*\varphi{b}</script><p>==定义：满足性质2的为积性函数==</p>
<p>3.如果$f(n)$为积性函数，$n=\prod_{i=1}^{m}p_{i}^{c_{i}}$，那么$f(n)=\prod_{i=1}^{m}f(pi^{c_{i}})$</p>
<p>简单证明：</p>
<p>类比积性函数的定义和定义式可以得到</p>
<p>4.设p为质数,p|n且$p^{2}|n$,那么$\varphi(n)=varphi(n/p)*p$</p>
<p>简单证明:</p>
<p>这个就很好证了,显然p和n/p的质因数相同,那么定义式中只有N是不同的,那么拆开再合并定义式就可以得到结论;</p>
<p>5.设p为质数,p|n但$p^{2}\not\mid n$,那么$\varphi(n)=\varphi(n/p)*(p-1)$</p>
<p>简单证明:</p>
<p>显然,p与n/p互质,那么根据积性函数$\varphi(n)=\varphi(n/p)*\varphi(p)$,当中$\varphi(p)=p-1$(因为p是质数),那么结论显然;</p>
<p>==以上性质4,5可以用来线性求euler函数,在后面会提到==</p>
<p>6.$\sum_{d|n}\varphi(d)=n$</p>
<p>证明忽略(雾</p>
<h3 id="euler函数的线性筛法"><a href="#euler函数的线性筛法" class="headerlink" title="euler函数的线性筛法"></a>euler函数的线性筛法</h3><p>如果要求1~n的euler函数,那么如何求解?</p>
<p>暴力解法,对每一个数进行求解,那么可以得到一个$O(n\sqrt{n})$的算法;</p>
<p>如何更优?</p>
<p>运用性质4,5即可,在素数筛的过程中进行性质4,5的判断,然后统计;</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100008</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,prim[maxn],vis[maxn],euler[maxn],m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			vis[i]=i;prim[++m]=i;</span><br><span class="line">			euler[i]=i<span class="number">-1</span>;<span class="comment">//这个很好理解 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(prim[j]&gt;vis[i]||prim[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">			vis[prim[j]*i]=prim[j];</span><br><span class="line">			<span class="comment">//素数筛 </span></span><br><span class="line">			euler[prim[j]*i]=euler[prim[j]]*(i%prim[j]?(prim[j]<span class="number">-1</span>):(prim[j]));</span><br><span class="line">			<span class="comment">//性质4,5的判断 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><h5 id="简述"><a href="#简述" class="headerlink" title="简述:"></a>简述:</h5><script type="math/tex; mode=display">
gcd(a,b)=1,a^{\varphi(b)}\equiv1(\mod b)</script><p>证明略(不会(雾</p>
<h4 id="拓展欧拉定理"><a href="#拓展欧拉定理" class="headerlink" title="拓展欧拉定理"></a>拓展欧拉定理</h4><h5 id="简述-1"><a href="#简述-1" class="headerlink" title="简述;"></a>简述;</h5><p>$gcd(a,n)=1,则a^{b}\equiv a^{b\% \varphi(n)}(mod n)$    </p>
<p>简单证明:</p>
<p>设$b=p*\varphi(n)+r$,那么$r= b(mod \varphi(n))$,由欧拉定理可得:</p>
<script type="math/tex; mode=display">
a^{b}=a^{p*\varphi(n)+r}=(a^{\varphi(n)})^p*a^{r} \equiv 1^{p}*a^{r} \equiv a^{r} \equiv a^{b \%\ \varphi(n)}</script>]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树初步</title>
    <url>/2019/10/25/%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>　　1.线段树。。。</p><p>　　（好像没了</p><p>　　2.（可知可不知，可能会有帮助）动态开点线段树</p><h2 id="主席树-可持久化线段树"><a href="#主席树-可持久化线段树" class="headerlink" title="主席树(可持久化线段树)"></a>主席树(可持久化线段树)</h2><p>　　一看可持久化,我们总会想到一些恐怖的算法.但是其实理解并不难,而这里我只是将主席树的思想讲清楚(尽量),题还是自己刷(虽然我就没刷几道</p><p>　　先看一道 <a href="https://www.luogu.org/problem/P3834" target="_blank" rel="noopener">模板题</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如题，给定N个整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。</p><a id="more"></a>





<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个正整数N、M，分别表示序列的长度和查询的个数。</p>
<p>第二行包含N个整数，表示这个序列各项的数字。</p>
<p>接下来M行每行包含三个整数l,r,k l, r, kl,r,k , 表示查询区间[l,r][l, r][l,r]内的第k小值。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出包含k行，每行1个整数，依次表示每一次查询的结果</p>
<p>　　我们发现这道题很难处理,因为我们没有学过什么数据结构可以维护区间第k大;</p>
<p>　　那么如何处理这个数组是一个关键;</p>
<p>　　回顾一下,我们在求前缀和时,如何求一个区间的和?用一个前缀和去减另一个前缀和.</p>
<p>　　类比一下,我们是否可以用一个区间减去另一个区间得到第k大?</p>
<p>　　是可以的.这里引入平衡树中一个操作,<strong>平衡树左子树维护比这个节点值小的子树,右子树维护比这个节点值大的子树</strong>;</p>
<p>　　平衡树是如何操作的呢?</p>
<p>　　<strong>保存每个节点的子树大小,比较排名k与左子树的大小,排名k小于左子树大小,那么我们要找的点一定在左子树上,那么走左子树;</strong></p>
<p>　　<strong>如果排名比左子树大,那么将排名减去左子树大小和自身,走右子树</strong></p>
<p>　　<strong><img src="\images\6.png" alt="alt"></strong></p>
<p>　　注意,这个一定要看懂!</p>
<p>　　这个概念如果理解了话,那么就简单了.考虑线段树也是一颗二叉树,与平衡树一个性质,并且线段树本质维护的就是区间,那么我们考虑维护一个值域线段树.</p>
<p>　　那么就可以初略的定义,主席树是维护一颗值域线段树,将每一个位置作为一个时间点,继承前一个点,并添加自己的值.</p>
<p>　　如果要求区间 l 到 r 第k大,那么就可以用 r 时间点的线段树减去 l - 1 时间点的线段树,然后得到这个区间中某个值域中有多少个数,然后用上面所说类似于平衡树的做法,</p>
<p>　　(图我是真的画不出来了QAQ)</p>
<p>　　为了补偿,在代码中会有详细解释</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="　　Code"></a>　　Code</h3><p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 400007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,a[maxn],b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    node tr[maxn*<span class="number">20</span>];<span class="keyword">int</span> t[maxn&gt;&gt;<span class="number">1</span>]; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        rt=++tot;<span class="comment">//建一个点保存新的信息 </span></span><br><span class="line">        tr[rt]=tr[pre],tr[rt].sum++;</span><br><span class="line">        <span class="comment">//继承前面节点,并且添加自身 </span></span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="comment">//这里需要注意,l和r是表示值域 </span></span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=x) add(tr[rt].l,tr[pre].l,l,mid,x);</span><br><span class="line">        <span class="keyword">else</span> add(tr[rt].r,tr[pre].r,mid+<span class="number">1</span>,r,x);</span><br><span class="line">        <span class="comment">//这里就可以看出主席树的优越性,每一次建logn个点 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从此可以看出来,每次加的只有一条从根到叶子的新边(其他边是继承前面的 </span></span><br><span class="line">    <span class="comment">//因此空间复杂度nlogn,注意一下数组 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;<span class="comment">//返回位置 </span></span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x=tr[tr[v].l].sum-tr[tr[u].l].sum;</span><br><span class="line">        <span class="comment">//用时间靠后的减去时间靠前的,</span></span><br><span class="line">        <span class="comment">//得到区间信息 </span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;=x) <span class="keyword">return</span> query(tr[u].l,tr[v].l,l,mid,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(tr[u].r,tr[v].r,mid+<span class="number">1</span>,r,k-x);</span><br><span class="line">        <span class="comment">//类似于平衡树操作 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(a[i]),b[i]=a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> ol=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+ol,a[i])-b;</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        t.add(t.t[i],t.t[i<span class="number">-1</span>],<span class="number">1</span>,ol,a[i]);</span><br><span class="line">        <span class="comment">//注意建立新的节点时,要继承前一个时间段的 </span></span><br><span class="line">    &#125;<span class="comment">//不用建树,直接上 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r,k;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(l,r,k);</span><br><span class="line">        <span class="keyword">int</span> pos=t.query(t.t[l<span class="number">-1</span>],t.t[r],<span class="number">1</span>,ol,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结　　"></a>总结　　</h2><p>　　这样大概就讲完了思想,这里介绍一道 <a href="https://www.luogu.org/problem/P2633" target="_blank" rel="noopener">水题</a> ,不过对于加深主席树的思想有重大帮助(将主席树看成一颗前缀线段树)</p>
<p>　　我会附上我的代码(因为码风大家都不太相同,如果与我的码风相似了话,看起来就会很享受)</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="　　Code"></a>　　Code</h3><p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fa[maxn],head[maxn],son[maxn],sz[maxn],ol;</span><br><span class="line"><span class="keyword">int</span> T[maxn],tot,a[maxn],top[maxn],dep[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> lastans,cent;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ML</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    ML tr[maxn*<span class="number">20</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        rt=++tot;</span><br><span class="line">        tr[rt]=tr[pre],tr[rt].sum++;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) add(tr[rt].l,tr[pre].l,l,mid,x);</span><br><span class="line">        <span class="keyword">else</span> add(tr[rt].r,tr[pre].r,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> lca,<span class="keyword">int</span> flca,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x=tr[tr[u].l].sum+tr[tr[v].l].sum-tr[tr[lca].l].sum-tr[tr[flca].l].sum;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=x) <span class="keyword">return</span> query(tr[u].l,tr[v].l,tr[lca].l,tr[flca].l,l,mid,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(tr[u].r,tr[v].r,tr[lca].r,tr[flca].r,mid+<span class="number">1</span>,r,k-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;t.add(T[x],T[fa[x]],<span class="number">1</span>,ol,a[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">        dfs1(y);sz[x]+=sz[y];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]]&lt;sz[y]) son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[x]=tp;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]),b[i]=a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    ol=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+ol,a[i])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        scan(u,v),add(u,v);</span><br><span class="line">    dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,k;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(u,v,k);u^=lastans;</span><br><span class="line">        <span class="keyword">int</span> lca=get_lca(u,v);</span><br><span class="line">        <span class="keyword">int</span> pos=t.query(T[u],T[v],T[lca],T[fa[lca]],<span class="number">1</span>,ol,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[pos]);lastans=b[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你看完了这篇博客并想骂博主讲的太简单,说明你已经超越博主了QAQ</p>
<p><strong>end</strong> </p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>dsu on tree</title>
    <url>/2019/10/25/dsu-on-tree/</url>
    <content><![CDATA[<p>这篇博客只是简单叙述思想(因为ML太弱了),具体例题请转其他博客.</p><hr><p>dsu on tree,许多OI将其归于启发式合并,当然如果你能理解更好,这只是一个理解方式罢了.</p><h2 id="思想简述"><a href="#思想简述" class="headerlink" title="思想简述"></a>思想简述</h2><p>　　顾名思义,这个算法是处理树上问题,将子树分开求解,如果暴力了话是枚举每个子树,然后dfs;</p><p>　　这里将每次dfs完的清空操作重新定义,并且规定dfs顺序,以来优化成log解法.</p><a id="more"></a>




<p>　　这里我们引入一个 <a href="https://www.luogu.org/problem/CF600E" target="_blank" rel="noopener">例题</a></p>
<blockquote>
<p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。</p>
</blockquote>
<p>　　仔细读题我们可以先想到暴力解法,分别从一个点进行dfs,肯定会爆;</p>
<p>　　那么我们思考一下,一颗子树上的点dfs结果是否可以被该子树根节点利用?</p>
<p>　　当然可以,但是我们只能保留一个点的结果,所以我们就面临一个选择,留哪一个?</p>
<p>　　我们想到树剖,那么我们保留重儿子就可以较好的保留信息,时间复杂度也会大幅降低.</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>　　1.dfs1找到重儿子和轻儿子;</p>
<p>　　2.dfs2递归处理每一个点,先扫描轻儿子,再扫描重儿子.</p>
<p>　　3.设计calc函数,用来处理轻重儿子,可以将add和del分开写,也可以合在一起;</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[maxn],a[maxn],sz[maxn],son[maxn],cent;</span><br><span class="line"><span class="keyword">int</span> fa[maxn],vis[maxn];</span><br><span class="line">ll col,max_part,num[maxn],ans[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dfs1(y);sz[x]+=sz[y];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]]&lt;sz[y]) son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    num[a[x]]+=p;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;<span class="number">0</span>&amp;&amp;num[a[x]]==max_part) col+=a[x];</span><br><span class="line">    <span class="keyword">if</span>(p&gt;<span class="number">0</span>&amp;&amp;num[a[x]]&gt;max_part) col=a[x],max_part=num[a[x]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        calc(y,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) dfs2(son[x],<span class="number">1</span>),vis[son[x]]=<span class="number">1</span>;</span><br><span class="line">    calc(x,<span class="number">1</span>);ans[x]=col;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) vis[son[x]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!id) calc(x,<span class="number">-1</span>),max_part=col=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        scan(u),scan(v),add(u,v);</span><br><span class="line">    dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) print(ans[i]),<span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论入门</title>
    <url>/2019/10/25/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>说实话,我真的对这个游戏看得是一脸懵逼,因为(我太弱了)我没有明白一些变量的意思,所以一直很懵,现在才明白,这让我明白博弈论(还可以骗钱)博大精深;</p><p>以下是我自己思考的过程,也许不严谨,但是最终明白了.</p><p>这里只是粗略地介绍Nim游戏,一个入门博客,以来更好地进入SG函数(因为我才刚学</p><h2 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h2><p>　　背景故事我就不说了,直接介绍游戏规则.</p><a id="more"></a>



<p>　　有n堆物品,每堆有$a_{i}$个物品,两个玩家每次可以任选一堆挑出任意整数个物品(可以整堆取完),但不能不取,取走最后一个物品的为胜者.</p>
<p>　　这个游戏历史久远,曾用来赌钱,但是被一位数学家用二进制求解,得到了先手必胜和先手必败理论,于是这个游戏也就GG了;</p>
<h2 id="游戏套路"><a href="#游戏套路" class="headerlink" title="游戏套路"></a>游戏套路</h2><p>　　假如有3堆物品,它们的个数分别是6,4,2,那么两个玩家都选择最优策略,那么先手胜还是后手胜? <a href="https://www.luogu.org/problem/P2197" target="_blank" rel="noopener">(例题(竟然还蓝了))</a></p>
<p>　　答案是后手胜.(这个可以自己推一下)</p>
<p>　　这里引入一个概念:有向图游戏;</p>
<h3 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="　　有向图游戏"></a>　　有向图游戏</h3><p>　　　　我们定义一个游戏的初始状态为起点,向所能到达的所有状态连边,通过不断向下延展,得到必胜点(就是到这个点是胜利的情况)和必败点(这其实是我自己的理解)</p>
<p>　　考虑将${6,4,2}$这个集合作为起点,然后向所有状态连边;但是显然状态太多,我们无法完全枚举;</p>
<p>　　考虑终点,必然是${0,0,0}$,此时集合的异或和显然是0.</p>
<p>　　那么我们定义每一堆剩余的个数为$A_{i}$,我们通过推论可以得到:初始状态集合异或和为0时必败,反之必胜.</p>
<p>　　为什么会得到这个结论?</p>
<h2 id="游戏思考"><a href="#游戏思考" class="headerlink" title="游戏思考"></a>游戏思考</h2><p>　　考虑将开始时集合中的数换成二进制,即${110,100,010}$,最后状态也换成二进制,我就不再写出来了.</p>
<p>　　我们倒着推,最终解异或和为0,那么必然是从异或和非0的状态转移过来的.</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="　　证明"></a>　　证明</h3><p>　　　　如果$A_{1} Xor A_{2} Xor A_{3} …Xor A_{i}… Xor  A_{n}=0$,那么其中$A_{i}$是从$A_{i}^{‘}$转移过来的,假设$A_{1} Xor A_{2} Xor A_{3} …Xor A_{i}^{‘}… Xor  A_{n}=0$,</p>
<p>　　　　根据异或运算得到,$A_{i}=A_{i}^{‘}$,根据游戏规则,每个玩家必然至少要取1个物品,与规则矛盾,假设不成立,结论成立.</p>
<p>　　所以考虑采取这样一个策略,如果我们开始时异或和不为0,那么我们策略是轮到对手时,让他得到$A_{1} Xor A_{2} Xor A_{3} …Xor A_{i}… Xor  A_{n}=0$.</p>
<p>　　那么必败节点必定到对方手中,我们需要证明一下我们一定能实现这个策略</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="　　证明"></a>　　证明</h3><p>　　　　假设此时集合异或和为x,此时最大数为$A_{i}$,那么我们可以让$A_{i}$变成$A_{i} Xor x$,这样异或和就又为0了.</p>
<p>　　　　显然,$A_{i} &gt; A_{i} Xor x$,所以我们可以让$A_{i}$变成$A{i}Xor即可,那么一定可以实现这个策略.</p>
<p>　　但是如果我们开始时异或和为0,对方也可以反过来利用这个策略,让我们陷入必败场面.</p>
<p>　　结论再次强调一遍:初始状态集合异或和为0时必败,反之必胜.</p>
<p>　　(以上证明单纯自己类似口述,没有按照严格的证明格式,请多谅解)</p>
<h2 id="游戏反思"><a href="#游戏反思" class="headerlink" title="游戏反思"></a>游戏反思</h2><p>　　我们学习的是思维方式,而不单单是结论,所以我们反思一下我们做了什么</p>
<p>　　1.首先分析了模型,概括出每种情况的集合,构造了一个有向图游戏;</p>
<p>　　2.我们思考了每个点的转移方式.并分析了必败点的特点,发现一些特别的转移情况.</p>
<p>　　3.我们更加深入的思考了转移情景,并证明了策略的正确性.</p>
<p>　　4.算法实现(这里没有摆出);</p>
<p>　　根据这个思路,也许会对以后有帮助,SG函数和Mex运算将会在之后讲到(博主还在努力的学T_T)</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流初步</title>
    <url>/2019/10/25/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>其实网络流很久之前已经学过,但是因为一些原因搁置了很久,于是想再系统地复习一下.</p><p>由于博主能力有限,所以关于网络流知识也是了解个大概,这里只是简单介绍,并且说一下博主的感性理解</p><hr><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="EK増广路算法"><a href="#EK増广路算法" class="headerlink" title="　　EK増广路算法"></a>　　EK増广路算法</h2><p>　　　　很容易理解的一个算法,也就是我们不断地bfs找出一条増广路然后更新剩余容量,直到更新完毕,类似于SPFA做法.时间复杂度$O(nm^{2})$;</p><a id="more"></a>



<p>　　　　这里不再附上代码,因为后面的费用流就要用EK+SPFA,而只是求最大流,推荐Dinic.</p>
<h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="　　Dinic算法"></a>　　Dinic算法</h2><p>　　　　与EK不同的是,Dinic算法增加了一些优化,这里引进了深度这个概念,通过在同一深度图中増广,一个点可以向多个点进行多流増广,并有减枝;</p>
<p>　　　　于是Dinic就可以达到$O(n^{2}m)$的优秀时间复杂度,可以代替匈牙利算法跑二分图匹配,时间复杂度$O(n\sqrt{n})$;</p>
<p>　　　　PS:关于二分图匹配时间复杂度可以这么想,由于一个点多流推进,同时増广多个点,而且深度小,所以时间复杂度就十分优秀;</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="　　　　Code:"></a>　　　　Code:</h3><p>　　　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10008</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],s,t,cent=<span class="number">1</span>,d[maxn],maxflow;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u,<span class="number">0</span>&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">    q.push(s),d[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].w&amp;&amp;!d[y])&#123;</span><br><span class="line">                q.push(y);d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(y==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rest=flow,k,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].w&amp;&amp;d[y=edge[i].to]==d[x]+<span class="number">1</span>)&#123;</span><br><span class="line">            k=Dinic(y,min(rest,edge[i].w));</span><br><span class="line">            edge[i].w-=k;</span><br><span class="line">            edge[i^<span class="number">1</span>].w+=k;</span><br><span class="line">            rest-=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,w;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        add(a,b,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())</span><br><span class="line">        <span class="keyword">while</span>(flow=Dinic(s,inf)) maxflow+=flow;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,maxflow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h1><p>　　费用流应该是我们见得最多的,而费用流跑二分图最大带权匹配极其优秀,费用流采用EK算法,不过每一次要跑一次SPFA,时间复杂度上升,如果要卡图了话,可能会崩;</p>
<p>　　但是由于图一般比较小,而且Dijkstra处理负权值问题有些复杂(要牵扯到势的辅助),所以还是普遍用SPFA求费用流;</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="　　Code"></a>　　Code</h2><p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2139062143</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,incf[N],head[N],cent=<span class="number">1</span>,dis[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],maxflow,mincost,pre[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w,cost;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w,c&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u,<span class="number">0</span>,-c&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre)); </span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    q.push(s);dis[s]=<span class="number">0</span>;vis[s]=<span class="number">1</span>;</span><br><span class="line">    incf[s]=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],y;i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!edge[i].w) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[y=edge[i].to]&gt;dis[x]+edge[i].cost)&#123;</span><br><span class="line">                dis[y]=dis[x]+edge[i].cost;</span><br><span class="line">                incf[y]=min(incf[x],edge[i].w);</span><br><span class="line">                pre[y]=i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y]) q.push(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[t]==<span class="number">2139062143</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=t;</span><br><span class="line">    <span class="keyword">while</span>(x!=s)&#123;</span><br><span class="line">        <span class="keyword">int</span> i=pre[x];</span><br><span class="line">        edge[i].w-=incf[t];</span><br><span class="line">        edge[i^<span class="number">1</span>].w+=incf[t];</span><br><span class="line">        x=edge[i^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    maxflow+=incf[t];</span><br><span class="line">    mincost+=dis[t]*incf[t];</span><br><span class="line"><span class="comment">//    cerr&lt;&lt;mincost&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c,d;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        add(a,b,c,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(spfa()) update();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,maxflow,mincost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>猫树</title>
    <url>/2019/10/25/%E7%8C%AB%E6%A0%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 　　猫树,由猫锟发明,以简单的构造以及优秀的离线复杂度而出名,可以优秀地处理区间和问题;</p><p> 　　前置知识:无;</p><h2 id="简单思想"><a href="#简单思想" class="headerlink" title="简单思想"></a>简单思想</h2><p> 　　运用分治的思想,分别处理中点两边的信息,之后分类讨论,合并区间得出结果;</p><p> 　　保存数据时运用完全二叉树的思想,逐层保存信息,有一定的层次性;</p><p> 　　<a href="https://www.luogu.org/problem/SP1043" target="_blank" rel="noopener">例题</a></p><p> 　　简单意思即求区间最大和;</p><a id="more"></a>





<p> 　　考虑上面所说的,处理中点两端的信息,即将区间的两个端点置于一个中点中间,而这个中点两边的信息我们已经处理过,所以可以分类讨论;</p>
<p>　　<img src="/images/2.png" alt="alt"></p>
<p>　　这个是一个简单的图形解释(图画歪了)　　</p>
<p> 　　蓝色的查询区间左端点和右端点,红色的是当前区间中点,然后我们将其断开;</p>
<p>　　<img src="/images/4.png" alt="alt"></p>
<p> 　　我们发现查询端点还不在中点两端,那么继续断开;</p>
<p>　　<img src="/images/5.png" alt="alt"></p>
<p>　　此时我们查询端点就在区间两端了;</p>
<p>　　那么考虑怎么查询,<strong>我们可以提前处理出这个区间左半边和右半边的最大区间和,并一起处理出左半边的最大后缀和和右半边的最大前缀和,</strong></p>
<p>　　由于我们的目标区间一定是在左区间或右区间或跨区间,那么如何求出答案就很显然了;</p>
<p> 　　根据上面的预处理,我们可以将一个大区间分层,每层分别处理上一层一半的区间,可以分为$logn$层;</p>
<p>　　关于具体操作,这里简述,即从中点向左扫描,向右扫描,<strong>求出这个区间左半边和右半边的最大区间和,并一起处理出左半边的最大后缀和和右半边的最大前缀和,</strong></p>
<p>　　</p>
<p>　　<strong>关于具体查询</strong></p>
<p> 　　如果我们能快速找到这一层,那么就可以$O(1)$更新出结果;</p>
<p>　　很容易发现,左端点(单个点,因为最后我们将区间划分到一个点)和右端点在树中的位置的LCA就是我们想找的那一层;</p>
<p>　　我们很简单可以向上暴力寻找,时间复杂度$O(logn)$;</p>
<p>　　考虑优化,我们可以用倍增或树剖求LCA,这样,我们就可以将时间复杂度优化到$O(loglogn)$的时间复杂度;</p>
<p>　　但是有些不同的是,还记得我在前面说它是一颗完全二叉树,那么每个节点都是上一个节点二进制左移得到的,那么考虑到这一点,我们可以继续优化;</p>
<p>　　例如,$(10011)_2$和$(10101)_2$,这两个节点的LCA是$(10)_2$,很容易发现它就是两点的公共前缀,那么,我们将其异或,就可以将其前缀去掉;</p>
<p>　　那么剩下的$(110)_2$$log2$得到二进制位数,然后原来节点也将其$log2$,得到二进制位数,那么,LCA所在层即为两者相减;</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>　　上面已经简述了思想,那么代码中我也会有注释,应该很快就能明白,码量较小;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cut[<span class="number">25</span>][maxn&lt;&lt;<span class="number">2</span>],cat[<span class="number">25</span>][maxn&lt;&lt;<span class="number">2</span>],dep[maxn&lt;&lt;<span class="number">2</span>],a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pos[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//cut是记录左区间和右区间最大区间和,cat是记录最大前缀和最大后缀 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> pos[l]=p,<span class="keyword">void</span>();<span class="comment">//记录二进制位置 </span></span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="keyword">int</span> pre,con;<span class="comment">//pre,con是辅助变量 </span></span><br><span class="line">    cut[d][mid]=cat[d][mid]=pre=con=a[mid];con=max(con,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid<span class="number">-1</span>;i&gt;=l;i--)&#123;</span><br><span class="line">        pre+=a[i],con+=a[i];cat[d][i]=max(cat[d][i+<span class="number">1</span>],pre);</span><br><span class="line">        cut[d][i]=max(cut[d][i+<span class="number">1</span>],con),con=max(con,<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="comment">//记录最大后缀, 和左区间的最大区间和 </span></span><br><span class="line">    cut[d][mid+<span class="number">1</span>]=cat[d][mid+<span class="number">1</span>]=pre=con=a[mid+<span class="number">1</span>];con=max(con,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">2</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        pre+=a[i],con+=a[i];cat[d][i]=max(cat[d][i<span class="number">-1</span>],pre);</span><br><span class="line">        cut[d][i]=max(cut[d][i<span class="number">-1</span>],con),con=max(con,<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="comment">//记录最大前缀,和右区间的最大区间和 </span></span><br><span class="line">    Init(le(p),l,mid,d+<span class="number">1</span>),Init(re(p),mid+<span class="number">1</span>,r,d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="keyword">int</span> d=dep[pos[l]]-dep[pos[l]^pos[r]];<span class="comment">//找到深度,即LCA二进制位数 </span></span><br><span class="line">    <span class="keyword">return</span> max(max(cut[d][l],cut[d][r]),cat[d][l]+cat[d][r]);</span><br><span class="line">&#125;<span class="comment">//分类讨论,比较出结果 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);<span class="keyword">int</span> len=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;n) len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    Init(<span class="number">1</span>,<span class="number">1</span>,len,<span class="number">1</span>);<span class="comment">//注意,猫树必须是完全二叉树,所以区间长度必须是2的倍数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,l=len&lt;&lt;<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        dep[i]=dep[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;<span class="comment">//预处理深度,即二进制位数 </span></span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(l),scan(r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用与拓展"><a href="#应用与拓展" class="headerlink" title="应用与拓展"></a>应用与拓展</h2><p>　　猫树限制性比较大,因为它只是支持区间查询,并且查询的东西也有所限制,所以一定要谨慎选择,遇见修改直接改用线段树;</p>
<p>　　有些题线段树优化DP时,可以选择用猫树加快速度,当然也可以根据猫树构造进行一定拓展,这样对分治也有更好地理解.</p>
<h3 id="推荐例题"><a href="#推荐例题" class="headerlink" title="推荐例题"></a>推荐例题</h3><p>　　<a href="https://www.luogu.org/problem/SP2916" target="_blank" rel="noopener">GSS5</a>,同系列的,可以练一练</p>
<p>　　</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵树</title>
    <url>/2019/10/25/%E7%9F%A9%E9%98%B5%E6%A0%91/</url>
    <content><![CDATA[<h2 id="必备知识："><a href="#必备知识：" class="headerlink" title="必备知识："></a>必备知识：</h2><p>　　高斯消元，图论基本知识（好像就这。。。（雾）） </p><p>这里是无向图部分，请不要走错场。。。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>　　我们将邻接矩阵定义为矩阵$A(u,v)$，我想邻接矩阵就不用再多说了；</p><p>　　我们将每个点的度数矩阵定义为矩阵$D(u,v)$，这里再加上数学表示；</p><p>　　$D(u,u)=u$这个点的度数，$D(u,v)=0（u!=v)$；</p><a id="more"></a>




<p>　　我们将矩阵Laplace（或Kirchhoff）定义为$L(u,v)=D(u,v)-A(u,v)$</p>
<p>　　我们将生成树的个数定义为 $t$；</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>　　这里将讲述行列式，如果dalao已经学过，请直接跳过这个环节；</p>
<p>　　这里引入的是$N*N$方阵行列式（因为邻接矩阵是方形），例如</p>
<p>　　<img src="/images/1.png" alt="alt"></p>
<p>　　行列式的公式是<script type="math/tex">D=|A|=\sum(-1)^v a_{1,l_1}a_{2,l_2}a_{3,l_3}...a_{n,l_n}</script>.</p>
<p>　　PS：其中v是 $l_1 , l_2 , l_3 … l_n$的逆序对个数；</p>
<p>　　行列式有几个性质：</p>
<ul>
<li>行行交换，结果相反；</li>
<li>行行叠加，结果不变；</li>
<li>矩阵行伸长，结果等比例增加；</li>
</ul>
<p>　　PS：</p>
<p>　　性质1的简单证明：</p>
<p>　　　　由行列式的公式可知，行行交换，必然会出现逆序对的变化，变化为1，那么此时结果符号一定会改变；</p>
<p>　　性质2的补充：</p>
<p>　　　　可以让其他行乘上k叠加到这一行，结果不变；</p>
<p>　　根据这些，我们就可以发现，高斯消元可以很好的利用这些性质，那么高斯消元后矩阵对角线的乘积即为结果；</p>
<p>　　我从其他位置挖来了一个矩阵L的优化证明，说实话，我有点蒙</p>
<p>　　<img src="/images/3.png" alt="alt"></p>
<p>　　我们根据这个性质可以少算一行一列，这应该也算优化吧（心虚~</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>　　这样思路就十分清晰了，这里的矩阵L行列式值即为生成树个数，那么我们就有了步骤：</p>
<ol>
<li>首先构造矩阵L，根据公式$L=D - A$，我们可以很方便地求出矩阵L，当然，在读入边时就可以直接操作，如边 $u$  -&gt; $v$，我们不妨让$f [ u ] [ v ]=f [ v ] [ u ] - -,f [ u ] [ u ]++,f [ v ] [ v ]++$.</li>
<li>然后将矩阵高斯消元，并求出对角线的乘积。</li>
<li>有时因为必须是整数，我们可以采用类似于辗转相除法的减去方法，下面将详细介绍。</li>
</ol>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>　　模板题：<a href="https://www.luogu.org/problem/P4111" target="_blank" rel="noopener">小Z的房间</a></p>
<p>　　思路清晰，只要将一个点和上下左右建边，构造矩阵L，用高斯消元求解；</p>
<p>　　不过高斯消元一般求其小数形式，这里是不行的，因为是方案数（不可能是小数啊QWQ）；</p>
<p>　　这里就应用了类似于辗转相除的方法，回顾辗转相除，将两个数取$mod$，然后交换位置，直到一个为0为止；</p>
<p>　　高斯消元同样是将另一个数消为0，那么我们将函数改一下，如下（看注释）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;n=cent<span class="number">-1</span>;<span class="comment">//定理 1 的应用 ,cent为总点数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(f[j][i])&#123;<span class="comment">//类辗转相除法 ，直到一个为0 </span></span><br><span class="line">                <span class="keyword">int</span> t=f[i][i]/f[j][i];</span><br><span class="line">                <span class="comment">//注意是int类型（向下取整），没减完，但是减后f[i][i]&lt;f[j][i] </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                    f[i][k]=(f[i][k]-f[j][k]*t%mod+mod)%mod;</span><br><span class="line">                swap(f[i],f[j]);<span class="comment">//交换位置辗转减 </span></span><br><span class="line">                <span class="comment">//交换位置是因为上面所说的 f[i][i]&lt;f[j][i] </span></span><br><span class="line">                ans=-ans;<span class="comment">//交换位置要取反 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans*f[i][i]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　应该解释的还算清楚，类似辗转相除的复杂度大约多了一个$log n$，总复杂度$O(n^{3}log n)$我将整个代码放在这里，算一个模板吧：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">100</span>][<span class="number">100</span>],cent;</span><br><span class="line">ll f[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    f[u][u]++,f[u][v]--;</span><br><span class="line">&#125;<span class="comment">//由于矩阵对称，所以加减一次就好。。。 </span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;n=cent<span class="number">-1</span>;<span class="comment">//定理 1 的应用 ,cent为总点数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(f[j][i])&#123;<span class="comment">//类辗转相除法 ，直到一个为0 </span></span><br><span class="line">                <span class="keyword">int</span> t=f[i][i]/f[j][i];</span><br><span class="line">                <span class="comment">//注意是int类型（向下取整），没减完，但是减后f[i][i]&lt;f[j][i] </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                    f[i][k]=(f[i][k]-f[j][k]*t%mod+mod)%mod;</span><br><span class="line">                swap(f[i],f[j]);<span class="comment">//交换位置辗转减 </span></span><br><span class="line">                <span class="comment">//交换位置是因为上面所说的 f[i][i]&lt;f[j][i] </span></span><br><span class="line">                ans=-ans;<span class="comment">//交换位置要取反 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans*f[i][i]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> s=getchar();</span><br><span class="line">            <span class="keyword">while</span>(s!=<span class="string">'.'</span>&amp;&amp;s!=<span class="string">'*'</span>)</span><br><span class="line">                s=getchar();<span class="comment">//防止输入出错 </span></span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">'.'</span>) a[i][j]=++cent;<span class="comment">//命名 </span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> now,rou;</span><br><span class="line">            <span class="keyword">if</span>(!(now=a[i][j])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(rou=a[i<span class="number">-1</span>][j]) add(now,rou);</span><br><span class="line">            <span class="keyword">if</span>(rou=a[i][j<span class="number">-1</span>]) add(now,rou);</span><br><span class="line">            <span class="keyword">if</span>(rou=a[i+<span class="number">1</span>][j]) add(now,rou);</span><br><span class="line">            <span class="keyword">if</span>(rou=a[i][j+<span class="number">1</span>]) add(now,rou);<span class="comment">//构建L矩阵 </span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(Gauss()+mod)%mod);<span class="comment">//不能是负数。。。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><p>　　懂了模板当然是不够的，我们应该见识一些技巧：</p>
<h3 id="SDOI2014-重建"><a href="#SDOI2014-重建" class="headerlink" title="[SDOI2014]重建"></a><a href="https://www.luogu.org/problem/P3317" target="_blank" rel="noopener">[SDOI2014]重建</a></h3><p>　　题目不再粘贴，我们直接叙述；</p>
<p>　　这里同样是生成树个数，不过不同的是，这里具有边权值，不过这里并不碍事，我们将叙述有点权值将如何应对。</p>
<p>　　根据高中概率的基本知识，两个没有交集的事件$A,B$，概率分别为$P(A),P(B)$，那么$P(AB)=P(A)*P(B)$，这个应该都懂。</p>
<p>　　那么每条边联通的概率为$P(u,v)$，那么不连通的概率是$1-P(u,v)$，这个应该很显然。</p>
<p>　　那么一个生成树的概率$P(G)= P(u,v)*(1 - P（x，y))$，其中u，v的边属于生成树$G$，而$x,y$这条边不属于。</p>
<p>　　那么，$\sum P(G)$即为总概率，我们将式子改造。</p>
<p>​    <script type="math/tex">\sum_{G} \prod_{(u,v)\in G,(x,y)\notin G} P(u,v)*(1-P(x，y))</script></p>
<p>​    <script type="math/tex">=\sum_G \prod_{(u,v)\in G,(x,y)\notin G} P（u，v）*(1-\frac{P(G)}{P（u，v)})</script></p>
<p>​    <script type="math/tex">=\sum_G (1 - P(G))\prod_{(u,v)\in G,(x,y)\notin G} \frac{P(u,v)}{1-P(u,v)}</script></p>
<p>　　解释一下，由于属于树$G$的边和不属于树$G$的边互为补集，所以就可以利用这个性质，我直接表达这个式子</p>
<p>　　$sum=\sum(1-P(G)) \prod_{(u,v)\in G,(x,y)\notin G} \frac{P(u,v)}{1-P(u,v)}$</p>
<p>　　这样就很显然了，将<script type="math/tex">\frac{P[u][v]}{1-P[u][v]}</script>作为边权值，不过如何处理边权，这里给出步骤：</p>
<p>　　1.我们将矩阵读入，重新定义边权；</p>
<p>　　2.将边权当作度数加在对角线上，然后当作邻接矩阵中边的个数减去即可；</p>
<p>　　3.高斯消元；</p>
<p>　　介绍完毕，$Code$：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">db f[maxn][maxn],ans=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">const</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n--;db ol=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sp=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(f[j][i])&gt;<span class="built_in">fabs</span>(f[sp][i])) sp=j;</span><br><span class="line">        <span class="keyword">if</span>(i!=sp) swap(f[i],f[sp]),ans=-ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            db t=f[j][i]/f[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                f[j][k]-=f[i][k]*t;</span><br><span class="line">        &#125;</span><br><span class="line">        ol*=f[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ol;</span><br><span class="line">&#125;<span class="comment">//这里是小数，所以操作就没有那么鬼畜了。。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sum = sigma P(G) Π(P[u][v]/(1-P[u][v]));</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;f[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            db t=max((<span class="number">1.0</span>-f[i][j]),eps);<span class="comment">//小心 0 哦 </span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;j) ans*=t;<span class="comment">//累加，得出 1-P(G) </span></span><br><span class="line">            f[i][j]/=t;<span class="comment">//步骤1 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                f[i][i]+=f[i][j]; </span><br><span class="line">                f[i][j]=-f[i][j];</span><br><span class="line">            &#125;<span class="comment">//步骤2 ,构图 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf"</span>,<span class="built_in">fabs</span>(Gauss()*ans));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SHOI2016-黑暗前的幻想乡"><a href="#SHOI2016-黑暗前的幻想乡" class="headerlink" title="[SHOI2016]黑暗前的幻想乡"></a><a href="https://www.luogu.org/problem/P4336" target="_blank" rel="noopener">[SHOI2016]黑暗前的幻想乡</a></h3><p>　　这里用到了容斥原理，二进制枚举等技巧，容斥我就不再叙述，自己不会可以<a href="https://baike.baidu.com/item/容斥原理/10146840?fr=aladdin" target="_blank" rel="noopener">yy一下</a>（逃~</p>
<p>　　直接上代码了（有良心注释）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; &gt;a[maxn];</span><br><span class="line">ll f[maxn][maxn],ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=n<span class="number">-1</span>;ll ol=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(f[j][i])&#123;</span><br><span class="line">                <span class="keyword">int</span> t=f[i][i]/f[j][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=m;k++)</span><br><span class="line">                    f[i][k]=(f[i][k]-f[j][k]*t%mod+mod)%mod;</span><br><span class="line">                swap(f[i],f[j]);ol=-ol;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ol=ol*f[i][i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ol+mod)%mod;</span><br><span class="line">&#125;<span class="comment">//唉，方案数。。。 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    f[u][u]++,f[v][v]++;</span><br><span class="line">    f[u][v]--,f[v][u]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,t,u,v;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            a[i].push_back(make_pair(u,v));<span class="comment">//存图 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lim=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));<span class="comment">//暴力建图 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n<span class="number">-1</span>;k++)&#123;<span class="comment">//二进制枚举 </span></span><br><span class="line">            <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;k)&amp;i)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a[k+<span class="number">1</span>].size();j++)</span><br><span class="line">                    add(a[k+<span class="number">1</span>][j].first,a[k+<span class="number">1</span>][j].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((n-cnt)&amp;<span class="number">1</span>) ans=(ans+Gauss())%mod;</span><br><span class="line">        <span class="comment">//容斥原理。。。其实就是奇数和偶数分别加减 。。。 </span></span><br><span class="line">        <span class="keyword">else</span> ans=(ans-Gauss()+mod)%mod;<span class="comment">//防止负数。。。 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　其实还有一些内容，但是由于赶着复习，就没再说了。</p>
<p>　　我们做的这几道题，无非是建图，统计答案，高斯消元时设下关卡，导致题目难度的跃升。</p>
<p>　　但既然已经知道要考哪里，就往哪个地方想，就像专题训练一样，然后找出特点，从而在综合题中找到这个算法的影子；</p>
<p>　　这个算法特点主要就是生成树的计数，所以应该很好看出来，记住特点和处理方法，培养数学思维才是做题目的；</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
