<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tarjan初步-强联通分量</title>
    <url>/2019/11/13/strongly-connected/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    发现我又咕咕了一篇早就应该写的博客,唉,真是的;</p><p>​    强联通分量常用于缩点,重建图去跑其他算法;</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>​    强联通分量存在于有向图,简单的概念即有向图中一个块中的点可以彼此到达,这个块被称为分量,而两点彼此能到到达称为强联通,那么强联通分量的概念就出来了;</p><p>​    同样用的时间戳(dfn)与返祖标记(low)这个概念,如果不知道,请看本博客中的点双边双;</p><a id="more"></a>



<p>​    与点双相同的是当一个点dfn=low时,那么其栈中的点到这个点,即这个搜索子树就是就是一个强联通分量;</p>
<h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>​    有一定基础,或者已经理解了话可以跳过该过程,这里不再给出严谨证明;</p>
<p> <img src="/images/0`7]J}2U(`1" alt="alt">SUJ[B`RCUTE.png) </p>
<p><img src="/images/1573611715606.png" alt="alt"></p>
<p><img src="/images/1573611747760.png" alt="alt"></p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>​    <a href="https://www.luogu.org/problem/P2341" target="_blank" rel="noopener">P2341 [HAOI2006]受欢迎的牛</a></p>
<p>模版题;</p>
<blockquote>
<p>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶</p>
<p>牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜</p>
<p>欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你</p>
<p>算出有多少头奶牛可以当明星。</p>
</blockquote>
<p>​    如果没有环,那么就是一个没有出度的点,如果有强联通分量,那么只要统计每个强联通分量的出度即可;</p>
<p>​    答案就是那个出度为0强联通分量中点的个数,记住特判一下有多个出度为0的强联通分量,这样答案会是0;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d 10000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[<span class="number">20007</span>],cent,low[<span class="number">20007</span>],dfn[<span class="number">20007</span>],t,stackk[<span class="number">20007</span>];</span><br><span class="line"><span class="keyword">int</span> top,temp,col[<span class="number">20007</span>],vis[<span class="number">20007</span>],cnt;</span><br><span class="line"><span class="keyword">int</span> out[<span class="number">10007</span>],tot[<span class="number">10007</span>],fu[<span class="number">10007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	low[x]=dfn[x]=++t;vis[x]=<span class="number">1</span>;</span><br><span class="line">	stackk[++top]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">			Tarjan(y);</span><br><span class="line">			low[x]=min(low[x],low[y]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y])&#123;</span><br><span class="line">			low[x]=min(low[x],dfn[y]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			temp=stackk[top--];</span><br><span class="line">			vis[temp]=<span class="number">0</span>;</span><br><span class="line">			col[temp]=cnt;</span><br><span class="line">			tot[cnt]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(temp!=x);<span class="comment">//注意特判条件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">		add(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j;j=edge[j].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[j].to;</span><br><span class="line">			<span class="keyword">if</span>(col[y]!=col[i])&#123;</span><br><span class="line">				fu[col[i]]++;<span class="comment">//统计出度</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!fu[i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag)&#123;<span class="built_in">printf</span>(<span class="string">"0"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">			flag=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,tot[flag]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>​    <a href="https://www.luogu.org/problem/P2746" target="_blank" rel="noopener">P2746 校园网</a></p>
<blockquote>
<p>求一个有向图入度为0的点的个数,和连多少条边能使图互相连通;</p>
</blockquote>
<p>​    <del>我怎么又放了一道模版题</del></p>
<p>​    缩点一下,求出入度为0的点即可,下一问,我们可以将入度为0的点和出度为0的点两两配对,如果不够,将多出来的随便接在一个上面即可(因为已经匹配完的是一个强联通分量)</p>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[<span class="number">1007</span>],cent,dfn[<span class="number">1007</span>],low[<span class="number">1007</span>],t,cnt;</span><br><span class="line"><span class="keyword">int</span> stackk[<span class="number">1007</span>],top,col[<span class="number">1007</span>],tot[<span class="number">1007</span>],vis[<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> ans1,ans2,out[<span class="number">1007</span>],in[<span class="number">1007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[<span class="number">10000007</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++t;vis[x]=<span class="number">1</span>;</span><br><span class="line">	stackk[++top]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">			Tarjan(y);</span><br><span class="line">			low[x]=min(low[x],low[y]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y])&#123;</span><br><span class="line">			low[x]=min(low[x],dfn[y]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">		cnt++;<span class="keyword">int</span> z;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			z=stackk[top--];</span><br><span class="line">			col[z]=cnt;</span><br><span class="line">			vis[z]=<span class="number">0</span>;</span><br><span class="line">			tot[cnt]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(z!=x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,s;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">		<span class="keyword">while</span>(s) add(i,s),<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(col[y]==col[x]) <span class="keyword">continue</span>;</span><br><span class="line">			out[col[x]]++;in[col[y]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!out[i]) ans2++;</span><br><span class="line">		<span class="keyword">if</span>(!in[i]) ans1++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"1\n0"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,ans1,max(ans1,ans2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p><a href="https://www.luogu.org/problem/P3627" target="_blank" rel="noopener">P3627 抢掠计划</a></p>
<blockquote>
<p>Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。</p>
<p>Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心 出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆 祝他的胜利。</p>
<p>使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希 望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可 以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机 里面就不会再有钱了。</p>
</blockquote>
<p>​    Tarjan+SPFA(Dij);</p>
<p>​    我们可以发现题目中给了我们提示;</p>
<blockquote>
<p>他可以经过同一路口或道路任意多次;</p>
</blockquote>
<p>​    那么就是强联通分量缩点,一个强联通分量中的钱是可以全部拿走的,直接在缩点的图SPFA就行了;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],dfn[maxn],low[maxn],val[maxn],stk[maxn],col[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn],cent,a[maxn],s,op[maxn],tot,cnt,top,p,dis[maxn],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,from,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],u,v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++tot;vis[x]=<span class="number">1</span>;</span><br><span class="line">	stk[++top]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">			Tarjan(y);</span><br><span class="line">			low[x]=min(low[x],low[y]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y]) low[x]=min(low[x],dfn[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">		cnt++;<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			temp=stk[top--];</span><br><span class="line">			vis[temp]=<span class="number">0</span>;</span><br><span class="line">			col[temp]=cnt;</span><br><span class="line">			val[cnt]+=a[temp];</span><br><span class="line">		&#125;<span class="keyword">while</span>(temp!=x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	dis[s]=val[s];vis[s]=<span class="number">1</span>;q.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front();q.pop();vis[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[y]&lt;dis[x]+val[y])&#123;</span><br><span class="line">				dis[y]=dis[x]+val[y];</span><br><span class="line">				<span class="keyword">if</span>(!vis[y]) q.push(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("cin.in","r",stdin);</span></span><br><span class="line">	scan(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++) scan(u,v),add(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">	<span class="keyword">int</span> lim=cent;cent=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(col[x]!=col[y]) add(col[x],col[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	scan(s,p);dis[col[s]]=val[col[s]];</span><br><span class="line">	spfa(col[s]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++) scan(op[i]),ans=max(ans,dis[col[op[i]]]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h4><p>​    <a href="https://www.luogu.org/problem/P3119" target="_blank" rel="noopener">P3119 草鉴定</a></p>
<blockquote>
<p>约翰有n块草场，编号1到n，这些草场由若干条单行道相连。奶牛贝西是美味牧草的鉴赏家，她想到达尽可能多的草场去品尝牧草。</p>
<p>贝西总是从1号草场出发，最后回到1号草场。她想经过尽可能多的草场，贝西在通一个草场只吃一次草，所以一个草场可以经过多次。因为草场是单行道连接，这给贝西的品鉴工作带来了很大的不便，贝西想偷偷逆向行走一次，但最多只能有一次逆行。问，贝西最多能吃到多少个草场的牧草。</p>
</blockquote>
<p>​    显然一个强联通分量中的点可以互相到达,缩点即可;</p>
<p>​    之后我们可以枚举逆行的边,求逆行边的两个点到1号草场所在强联通分量的路即可,其路的权值即所经过强联通分量的全权值和;</p>
<p>​    如何求最长路?正向建边反向建边跑SPFA最长路即可;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],cent,dfn[maxn],low[maxn],stk[maxn],cnt,ans;</span><br><span class="line"><span class="keyword">int</span> col[maxn],tot,k,vis[maxn],num[maxn],dis1[maxn],dis2[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,from;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan &gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tops,<span class="keyword">typename</span>... Tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(tops &amp;x,Tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v,u&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x]=++cnt,low[x]=cnt;</span><br><span class="line">	stk[++k]=x;vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">			Tarjan(y);</span><br><span class="line">			low[x]=min(low[x],low[y]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y]) low[x]=min(low[x],dfn[y]);<span class="comment">//是vis[y]而不是vis[x] </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">		tot++;<span class="keyword">int</span> z;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			z=stk[k--];</span><br><span class="line">			col[z]=tot;</span><br><span class="line">			vis[z]=<span class="number">0</span>;</span><br><span class="line">			num[tot]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(z!=x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">	vis[col[<span class="number">1</span>]]=<span class="number">1</span>;dis1[col[<span class="number">1</span>]]=num[col[<span class="number">1</span>]];</span><br><span class="line">	q.push(col[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis1[y]&lt;dis1[x]+num[y])&#123;</span><br><span class="line">				dis1[y]=dis1[x]+num[y];</span><br><span class="line">				<span class="keyword">if</span>(!vis[y]) q.push(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">	vis[col[<span class="number">1</span>]]=<span class="number">1</span>;dis2[col[<span class="number">1</span>]]=num[col[<span class="number">1</span>]];</span><br><span class="line">	q.push(col[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis2[y]&lt;dis2[x]+num[y])&#123;</span><br><span class="line">				dis2[y]=dis2[x]+num[y];</span><br><span class="line">				<span class="keyword">if</span>(!vis[y]) q.push(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//	freopen("cout.out","w",stdout);</span></span><br><span class="line">	scan(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)</span><br><span class="line">		scan(u,v),add(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!col[i]) Tarjan(i);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);cent=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(col[x]!=col[y]) add(col[x],col[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	spfa1();<span class="keyword">int</span> ol=cent;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);cent=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ol;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line">		add(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	spfa2();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ol;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(dis1[x]&amp;&amp;dis2[y]) ans=max(ans,dis1[x]+dis2[y]);</span><br><span class="line">		<span class="keyword">if</span>(dis1[y]&amp;&amp;dis2[x]) ans=max(ans,dis1[y]+dis2[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans-num[col[<span class="number">1</span>]]);</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=tot;i++) cout&lt;&lt;dis1[i]&lt;&lt;" "&lt;&lt;dis2[i]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h4><p>​    <a href="https://www.luogu.org/problem/P2515" target="_blank" rel="noopener">P2515 [HAOI2010]软件安装</a></p>
<p>​    Tarjan+树形背包;</p>
<p>​    每次缩点,重新建图,然后跑个树形DP(蓝书上有);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 107</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],val[maxn],cost[maxn],low[maxn],dfn[maxn],sz[maxn];</span><br><span class="line"><span class="keyword">int</span> col[maxn],cent,stk[maxn],tot,top,cnt,vis[maxn],w[maxn],in[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn&lt;&lt;<span class="number">3</span>],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,from,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],u,v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++tot;vis[x]=<span class="number">1</span>;</span><br><span class="line">	stk[++top]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">			Tarjan(y);</span><br><span class="line">			low[x]=min(low[y],low[x]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y]) low[x]=min(low[x],dfn[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">		cnt++;<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			temp=stk[top--];</span><br><span class="line">			vis[temp]=<span class="number">0</span>;</span><br><span class="line">			col[temp]=cnt;</span><br><span class="line">			sz[cnt]+=cost[temp];</span><br><span class="line">			w[cnt]+=val[temp];</span><br><span class="line">		&#125;<span class="keyword">while</span>(temp!=x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x) <span class="keyword">for</span>(<span class="keyword">int</span> t=m;t&gt;=sz[x];t--) f[x][t]=w[x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		dfs(y);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> t=m-sz[x];t&gt;=<span class="number">0</span>;t--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=t;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">				f[x][t+sz[x]]=max(f[x][t+sz[x]],f[x][t+sz[x]-j]+f[y][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(cost[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(val[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++) &#123;</span><br><span class="line">		scan(x);</span><br><span class="line">		<span class="keyword">if</span>(x) add(x,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">	<span class="keyword">int</span> lim=cent;cent=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(col[x]!=col[y]) add(col[x],col[y]),in[col[y]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) add(<span class="number">0</span>,i);</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) ans=max(ans,f[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 10</span></span><br><span class="line"><span class="comment">5 5 6</span></span><br><span class="line"><span class="comment">2 3 4</span></span><br><span class="line"><span class="comment">0 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="TO-BE-CONTINUE"><a href="#TO-BE-CONTINUE" class="headerlink" title="TO BE CONTINUE"></a>TO BE CONTINUE</h5>]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列</title>
    <url>/2019/11/11/DP-queue/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    单调队列并不是太难的东西,不应其应用到的题目困难而觉得单调队列困难.</p><p>​    我第一次遇见单调队列时是在学图论时,遇到了Island这道题(见基环树专题),当时的我对单调队列一无所知,而对其优化更是懵,所以当时就懵着将题解半抄半写地打了出来,但还是不懂.现在来看,单论单调队列,它是不难的,难的是与其他算法的结合;</p><a id="more"></a>

<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h4 id="限制与应用"><a href="#限制与应用" class="headerlink" title="限制与应用"></a>限制与应用</h4><p>​    对于单调队列,有两个操作,入队和出队;</p>
<p>​    有两个限制,队首元素满足区间条件,队列中数满足单调;</p>
<p>​    应用限制,转移DP时应满足区间取max-min操作,即让单调有其发挥作用的空间;</p>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​    推荐这道<a href="https://www.luogu.org/problem/P2698" target="_blank" rel="noopener">例题</a>理解一下单调队列思想;</p>
<blockquote>
<p>老板需要你帮忙浇花。给出N滴水的坐标，y表示水滴的高度，x表示它下落到x轴的位置。</p>
<p>每滴水以每秒1个单位长度的速度下落。你需要把花盆放在x轴上的某个位置，使得从被花盆接着的第1滴水开始，到被花盆接着的最后1滴水结束，之间的时间差至少为D。</p>
<p>我们认为，只要水滴落到x轴上，与花盆的边沿对齐，就认为被接住。给出N滴水的坐标和D的大小，请算出最小的花盆的宽度W。</p>
</blockquote>
<p>​    我们首先考虑到答案是具有单调性的,宽度W满足条件,那么大于W的也会满足条件,那么我们可以二分答案;</p>
<p>​    二分答案后,我们可以得到一个区间,我们想要的即所有区间中是否存在 $max-min&gt;=D$ ;</p>
<p>​    这里就引入了单调队列,单调队列的队首表示区间 $i-mid-1$ ~ $i$ 最大值或者最小值,其限制条件即 $q[l]&gt;=i-mid-1$ ,不满足条件时弹出.</p>
<p>​    入队时,比较队尾元素和要加入元素值,比较方式是 “比我小的人还比我强,那我就要退役了” ,即未来会更新到我们要加入值,存在时间肯定比队尾元素长,而队尾元素又比要加入的值小,那么队尾元素的贡献就可以被要加入的值代替,故直接弹出;</p>
<p>​    那么这里我们限制一下区间,求出区间最大值与最小值,更新最大差值即可;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,d,lim,q[maxn],f[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,x=<span class="number">1</span>,y=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> maxx=<span class="number">-1</span>,minx=inf;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r&amp;&amp;a[q[l]].x&lt;=a[i].x-mid<span class="number">-1</span>) l++;<span class="comment">//限制区间弹出,注意区间大小为mid+1 </span></span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r&amp;&amp;a[q[r]].y&lt;=a[i].y) r--;<span class="comment">//根据原则弹出 </span></span><br><span class="line">		q[++r]=i;maxx=max(a[q[l]].y,maxx);<span class="comment">//更新,下面是一样的 </span></span><br><span class="line">		<span class="keyword">while</span>(x&lt;=y&amp;&amp;a[f[x]].x&lt;=a[i].x-mid<span class="number">-1</span>) x++;</span><br><span class="line">		<span class="keyword">while</span>(x&lt;=y&amp;&amp;a[f[y]].y&gt;=a[i].y) y--;</span><br><span class="line">		f[++y]=i;minx=min(a[f[x]].y,minx);</span><br><span class="line">		ans=max(maxx-minx,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans&gt;=d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n),scan(d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i].x),scan(a[i].y),lim=max(a[i].x,lim);</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);<span class="comment">//排序 </span></span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=lim;</span><br><span class="line">	<span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!check(l)) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    另一道<a href="https://www.luogu.org/problem/P2564" target="_blank" rel="noopener">例题</a> ,主要是依靠单调队列原则进行;</p>
<blockquote>
<p>求一段最短的区间,其区间中包含了所有类型的颜色;</p>
</blockquote>
<p>​    根据题目中区间的信息,我们可以隐约地想到单调队列,但是并没有单调性.</p>
<p>​    考虑队首弹出条件,当一个颜色在一个区间多次出现时,有贡献的只会是一个,那么当队首颜色重复时,其贡献已经被之后的颜色代替,也就没用了,那么既可以弹出;</p>
<p>​    队尾弹出就不再需要了,我们直接更新满足条件的区间即可;</p>
<p>​    那么思路即,对每种颜色计数,当队首元素颜色个数&gt;=2时,将其弹出;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,num;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">1000007</span>],ans=<span class="number">2147483647</span>,vis[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id,sp;	</span><br><span class="line">&#125;a[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.sp&lt;b.sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>,to;k&lt;=m;k++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;to);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=to;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[++cnt].sp),a[cnt].id=k;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[a[i].id]) vis[a[i].id]++;</span><br><span class="line">		<span class="keyword">if</span>(!vis[a[i].id]) vis[a[i].id]++,num++;</span><br><span class="line">		<span class="keyword">while</span>(vis[a[q[l]].id]&gt;<span class="number">1</span>) vis[a[q[l]].id]--,l++;<span class="comment">//超过一个,弹出</span></span><br><span class="line">		q[++r]=i;</span><br><span class="line">		<span class="keyword">if</span>(num==m) ans=min(ans,a[q[r]].sp-a[q[l]].sp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>​    二维单调队列,在一个固定矩形中,求其中最大值和最小值.</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>​    <a href="https://www.luogu.org/problem/P2216" target="_blank" rel="noopener"> [HAOI2007]理想的正方形 </a></p>
<blockquote>
<p>在一个 $a<em>b$ 的矩形中,求一个最大值与最小值差值最小的 $n</em>n$ 的正方形,输出其差值;</p>
</blockquote>
<p>​    首先求出横向一维区间最大值,之后在原有横向区间最大值中求纵向一维区间最大值,这里由于用到了横向一维的值,使其变成了二维,那么思路就很显然了,注意区间大小和边界限制;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,n,maps[<span class="number">1007</span>][<span class="number">1007</span>],work1[<span class="number">1007</span>][<span class="number">1007</span>],qmax[<span class="number">1007</span>],qmin[<span class="number">1007</span>],ans1[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">100007</span>],work2[<span class="number">1007</span>][<span class="number">1007</span>],ans2[<span class="number">1007</span>][<span class="number">1007</span>],ans=<span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maps[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=a;x++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,k=n;</span><br><span class="line">		<span class="built_in">memset</span>(qmax,<span class="number">0</span>,<span class="keyword">sizeof</span>(qmax));</span><br><span class="line">		<span class="built_in">memset</span>(qmin,<span class="number">0</span>,<span class="keyword">sizeof</span> qmin);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmax[l]) l++;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;maps[x][qmax[r]]&lt;=maps[x][i]) r--;</span><br><span class="line">			qmax[++r]=i;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=n) work1[x][i-k+<span class="number">1</span>]=maps[x][qmax[l]];</span><br><span class="line">		&#125;</span><br><span class="line">		l=<span class="number">1</span>,r=<span class="number">0</span>,k=n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmin[l]) l++;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;maps[x][qmin[r]]&gt;=maps[x][i]) r--;</span><br><span class="line">			qmin[++r]=i;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=n) work2[x][i-k+<span class="number">1</span>]=maps[x][qmin[l]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//横向区间最大最小值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=b;x++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,k=n;</span><br><span class="line">		<span class="built_in">memset</span>(qmax,<span class="number">0</span>,<span class="keyword">sizeof</span>(qmax));</span><br><span class="line">		<span class="built_in">memset</span>(qmin,<span class="number">0</span>,<span class="keyword">sizeof</span> qmin);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmax[l]) l++;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;work1[qmax[r]][x]&lt;=work1[i][x]) r--;</span><br><span class="line">			qmax[++r]=i;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=n) ans1[i-k+<span class="number">1</span>][x]=work1[qmax[l]][x];</span><br><span class="line">		&#125;</span><br><span class="line">		l=<span class="number">1</span>,r=<span class="number">0</span>,k=n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmin[l]) l++;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;work2[qmin[r]][x]&gt;=work2[i][x]) r--;</span><br><span class="line">			qmin[++r]=i;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=n) ans2[i-k+<span class="number">1</span>][x]=work2[qmin[l]][x];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//纵向区间最大最小值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b-n+<span class="number">1</span>;j++)</span><br><span class="line">			ans=min(ans,ans1[i][j]-ans2[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>​    <a href="https://www.luogu.org/problem/P2219" target="_blank" rel="noopener"> [HAOI2007]修筑绿化带 </a>,</p>
<blockquote>
<p>如果把公园看成一个 $M <em> N$ 的矩形，那么花坛可以看成一个 $C</em>D$ 的矩形，绿化带和花坛一起可以看成一个 $A*B$ 的矩形。</p>
<p>如果将花园中的每一块土地的“肥沃度”定义为该块土地上每一个小块肥沃度之和，那么， </p>
<p>绿化带的肥沃度= $A<em>B$ 块的肥沃度 $- C</em>D$块的肥沃度 </p>
<p>为了使得绿化带的生长得旺盛，我们希望绿化带的肥沃度最大。</p>
</blockquote>
<p>​    <del>震惊!某HA省竟在同一年考了两道相同算法的题</del> </p>
<p>​    这道题看起来是求最大区间值和,但是如果我们先用二维前缀和预处理出 $C<em>D$ 矩形的权值和,然后再限制在 $A</em>B$ 的矩形中,即上面那道题,有些不同的是,花坛不能触碰边界,注意边界的划分.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m,n,c,d,a,b,maps[<span class="number">1007</span>][<span class="number">1007</span>],num[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> qmin[<span class="number">1007</span>],mms[<span class="number">1007</span>][<span class="number">1007</span>];</span><br><span class="line"><span class="keyword">int</span> work2[<span class="number">1007</span>][<span class="number">1007</span>],ans2[<span class="number">1007</span>][<span class="number">1007</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;m,&amp;n,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maps[i][j]);</span><br><span class="line">			num[i][j]=maps[i][j]+num[i<span class="number">-1</span>][j]+num[i][j<span class="number">-1</span>]-num[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=c;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=d;j&lt;=n;j++)&#123;</span><br><span class="line">			maps[i-c+<span class="number">1</span>][j-d+<span class="number">1</span>]=num[i][j]-num[i-c][j]-num[i][j-d]+num[i-c][j-d];</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=a&amp;&amp;j&gt;=b) mms[i-a+<span class="number">1</span>][j-b+<span class="number">1</span>]=num[i][j]-num[i-a][j]-num[i][j-b]+num[i-a][j-b];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m<span class="number">-1</span>;x++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,k=b-d<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(qmin,<span class="number">0</span>,<span class="keyword">sizeof</span> qmin);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmin[l]) l++;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;maps[x][qmin[r]]&gt;=maps[x][i]) r--;</span><br><span class="line">			qmin[++r]=i;</span><br><span class="line">			<span class="keyword">if</span>(i-k+<span class="number">1</span>&gt;=<span class="number">0</span>) work2[x][i-k+<span class="number">1</span>]=maps[x][qmin[l]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n<span class="number">-1</span>;x++)&#123;</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,k=a-c<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(qmin,<span class="number">0</span>,<span class="keyword">sizeof</span> qmin);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;i-k&gt;=qmin[l]) l++;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;work2[qmin[r]][x]&gt;=work2[i][x]) r--;</span><br><span class="line">			qmin[++r]=i;</span><br><span class="line">			<span class="keyword">if</span>(i-k+<span class="number">1</span>&gt;<span class="number">0</span>) ans2[i-k+<span class="number">1</span>][x]=work2[qmin[l]][x];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m-a+<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-b+<span class="number">1</span>;j++)&#123;</span><br><span class="line">			ans=max(ans,mms[i][j]-ans2[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DP与单调队列"><a href="#DP与单调队列" class="headerlink" title="DP与单调队列"></a>DP与单调队列</h3><p>​    <a href="https://www.luogu.org/problem/P2569" target="_blank" rel="noopener"> [SCOI2010]股票交易 </a>;</p>
<blockquote>
<p>通过一段时间的观察，$\text{lxhgww}$  预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$ ，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i &gt; BP_i$ ），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。</p>
<p>另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\text{MaxP}$。</p>
<p>在第 $1$ 天之前，$\text{lxhgww}$  手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？</p>
</blockquote>
<p>​    首先推出DP式子,设 $f[i][j]$ 为第 $i$ 天手持 $j$ 个股票是的最大收入,那么分类转移;</p>
<p>​    CASE1: 没有买股票, $f[i][j]=f[i-1][j]$ </p>
<p>​    CASE2: 买了股票,但是有 $W$ 天的限制,所以转移应为 $f[i][j]=max(f[i-w-1][j-k] - k*AP_i ,f[i][j])$ ;</p>
<p>​    CASE3:  卖了股票, $f[i][j]=max(f[i-w-1][j+k]+k*BP_i , f[i][j])$ ;</p>
<p>​    那么 $k$ 的枚举我们可以用单调队列优化掉,时间复杂度 $O(tm)$ .</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,m,w,f[<span class="number">2007</span>][<span class="number">2007</span>],q[<span class="number">2007</span>],ans=-INT_MAX;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;m,&amp;w);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">128</span>,<span class="keyword">sizeof</span>(f));<span class="comment">//初始化最小值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,ap,bp,as,bs;i&lt;=t;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;ap,&amp;bp,&amp;as,&amp;bs);</span><br><span class="line">		<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span> q);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=as;j++) f[i][j]=-ap*j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++) f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j]);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=w) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;j-as) l++;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;f[i-w<span class="number">-1</span>][q[r]]+q[r]*ap&lt;=f[i-w<span class="number">-1</span>][j]+j*ap) r--;</span><br><span class="line">			q[++r]=j;</span><br><span class="line">			<span class="keyword">if</span>(l&lt;=r) f[i][j]=max(f[i][j],f[i-w<span class="number">-1</span>][q[l]]+q[l]*ap-j*ap);</span><br><span class="line">		&#125;<span class="comment">//买的时候从比自己股票少的转移,正序枚举 </span></span><br><span class="line">		<span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span> q);</span><br><span class="line">		l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&gt;j+bs) l++;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r&amp;&amp;f[i-w<span class="number">-1</span>][q[r]]+q[r]*bp&lt;=f[i-w<span class="number">-1</span>][j]+j*bp) r--;</span><br><span class="line">			q[++r]=j;</span><br><span class="line">			<span class="keyword">if</span>(l&lt;=r) f[i][j]=max(f[i][j],f[i<span class="number">-1</span>-w][q[l]]+q[l]*bp-j*bp);</span><br><span class="line">		&#125;<span class="comment">//卖的时候从比自己股票多的转移,倒序枚举 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,f[t][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    单调队列可以有效处理区间最大最小值信息,这在DP方程转移过程中有重要意义,但在应用时应注意其应用范围,而不是盲目的套;</p>
<p>​    应用时要注意细节问题,区间范围应卡好,出队时注意判断范围;</p>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><p>​    <a href="https://www.luogu.org/problem/P2254" target="_blank" rel="noopener">P2254 [NOI2005]瑰丽华尔兹</a> ;</p>
<h5 id="TO-BE-CONTINUE"><a href="#TO-BE-CONTINUE" class="headerlink" title="TO BE CONTINUE"></a>TO BE CONTINUE</h5>]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>D-DP</title>
    <url>/2019/11/10/D-DP/</url>
    <content><![CDATA[<h4 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h4><p>​    树链剖分,最大权独立集(即没有上司的舞会(树上DP)),矩阵乘法;</p><h2 id="D-DP"><a href="#D-DP" class="headerlink" title="D-DP"></a>D-DP</h2><h3 id="模版简述"><a href="#模版简述" class="headerlink" title="模版简述"></a>模版简述</h3><p>​    <a href="https://www.luogu.org/problem/P4719" target="_blank" rel="noopener">模板</a> </p><p>​    关于动态DP,其实是关于一类动态修改点权的问题,但是很难去处理;</p><p>​    我们平常的DP经常是离线DP,而当在线时,就会出现事故;</p><p>​    D-DP是关于求最大权独立集的,支持动态修改点值,其思想即DP的通项递推式改为矩阵乘的形式进行递推,而树上问题就可以使用树链剖分提前处理出区间矩阵乘;</p><a id="more"></a>




<p>​    大家肯定都会 $O(nm)$ 做法,即暴力修改点值进行DP.</p>
<p>​    求最大权独立集的DP式子为 $f[x][1]=\sum f[y][0] , f[x][0]=\sum max(f[y][1],f[y][0])$ ,如果我们将其改成矩阵乘的形式,就变成了下面这样;</p>
<script type="math/tex; mode=display">
[^{f[y][0]}_{f[y][1]}] * [^{0,0}_{v[x],-inf}]=[^{f[x][0]}_{f[x][1]}]</script><p>​    这个式子并不完整,这只是从一个点的矩阵乘,这个式子只是类似于矩阵乘,我们可以重新定义一下矩阵乘的定义,即将加法改为 $max$ ,将乘法改为加法,那么就可以通项递推了;</p>
<p>​    但是这个式子只限于从一个点递推过来,那么其他点怎么办?</p>
<p>​    没有办法…但是这是一个思路,这个式子用线段树维护,可以让我们可以快速处理出链上信息.</p>
<p>​    既然在树上,我们不如将重链看成这个链,而将链上的轻儿子的信息提前处理出来,在重链上的点的信息通过进行矩阵速推.</p>
<script type="math/tex; mode=display">
[^{f[y][0]}_{f[y][1]}]*[^{f'[x][0],f'[x][0]}_{f'[x][1],-inf}]=[^{f[x][0]}_{f[x][1]}]</script><p>​    (注: $f’[x][0]$ 是点 $x$ 只处理轻儿子和自己信息时的值)</p>
<p>​    那么如何修改?</p>
<p>​    同一条重链上点的修改对于这条链上的点是没有影响的,因为重链每个点只保存其轻儿子的信息,有影响的是对于这条链 $top$ 的父亲节点,那么我们的思路就出来了,修改点时,修改链 $top$ 父亲的矩阵信息即可;</p>
<p>​    总结一下思路: 首先将DP式子化为通项矩阵乘的形式,先处理出每个节点轻儿子的信息,在树上用树链剖分维护链上矩阵乘信息,修改时,每次修改链首父亲的矩阵值,修改至树根重链.修改细节即修改点信息,之后从链尾到链首矩阵乘,与之前的值作差修改.最后求答案时直接处理链上信息即可;</p>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(p) p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(p) p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],son[maxn],top[maxn],bot[maxn],fl[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn],id[maxn],cent,tot,a[maxn],sz[maxn],f[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">	ll g[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">	matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> matrix x) <span class="keyword">const</span>&#123;</span><br><span class="line">		matrix ans;</span><br><span class="line">		ans.g[<span class="number">0</span>][<span class="number">0</span>]=max(g[<span class="number">0</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">0</span>],g[<span class="number">0</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		ans.g[<span class="number">0</span>][<span class="number">1</span>]=max(g[<span class="number">0</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">1</span>],g[<span class="number">0</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		ans.g[<span class="number">1</span>][<span class="number">0</span>]=max(g[<span class="number">1</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">0</span>],g[<span class="number">1</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		ans.g[<span class="number">1</span>][<span class="number">1</span>]=max(g[<span class="number">1</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">1</span>],g[<span class="number">1</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;<span class="comment">//矩阵乘 </span></span><br><span class="line">&#125;tr[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">matrix ori[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">	edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树链剖分预处理 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	sz[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[y]=x,dfs1(y);</span><br><span class="line">		sz[x]+=sz[y];</span><br><span class="line">		<span class="keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">	id[x]=++tot,fl[tot]=x;top[x]=tp;</span><br><span class="line">	<span class="keyword">if</span>(son[x]) dfs2(son[x],tp),bot[x]=bot[son[x]];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> bot[x]=x,<span class="keyword">void</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(y,y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树上DP </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	f[x][<span class="number">0</span>]=<span class="number">0</span>;f[x][<span class="number">1</span>]=a[x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs3(y);</span><br><span class="line">		f[x][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">		f[x][<span class="number">1</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	tr[p]=tr[le(p)]*tr[re(p)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树时每个点只保存自己和轻儿子的信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tr[p].g[<span class="number">0</span>][<span class="number">0</span>]=tr[p].g[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;tr[p].g[<span class="number">1</span>][<span class="number">1</span>]=-inf;</span><br><span class="line">		tr[p].g[<span class="number">1</span>][<span class="number">0</span>]=a[fl[l]];<span class="keyword">int</span> x=fl[l];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">			tr[p].g[<span class="number">0</span>][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">			tr[p].g[<span class="number">1</span>][<span class="number">0</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		tr[p].g[<span class="number">0</span>][<span class="number">1</span>]=tr[p].g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		ori[fl[l]]=tr[p];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(l,mid,le(p));build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">	push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[p]=ori[fl[l]],<span class="keyword">void</span>();</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) add(x,l,mid,le(p));</span><br><span class="line">	<span class="keyword">else</span> add(x,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">	push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tr[p];</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(nl&lt;=mid&amp;&amp;mid&lt;nr) <span class="keyword">return</span> query(nl,nr,l,mid,le(p))*query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(nl&lt;=mid) <span class="keyword">return</span> query(nl,nr,l,mid,le(p));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> query(id[top[x]],id[bot[x]],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	ori[x].g[<span class="number">1</span>][<span class="number">0</span>]+=k-a[x];a[x]=k;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		matrix old,news;</span><br><span class="line">		old=query(top[x]);<span class="comment">//没修改的</span></span><br><span class="line">		add(id[x],<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//change </span></span><br><span class="line">		news=query(top[x]);<span class="comment">//修改过的 </span></span><br><span class="line">		x=fa[top[x]];<span class="keyword">if</span>(!x) <span class="keyword">break</span>;</span><br><span class="line">		ori[x].g[<span class="number">0</span>][<span class="number">0</span>]+=max(news.g[<span class="number">0</span>][<span class="number">0</span>],news.g[<span class="number">1</span>][<span class="number">0</span>])-max(old.g[<span class="number">0</span>][<span class="number">0</span>],old.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		ori[x].g[<span class="number">0</span>][<span class="number">1</span>]=ori[x].g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		ori[x].g[<span class="number">1</span>][<span class="number">0</span>]+=news.g[<span class="number">0</span>][<span class="number">0</span>]-old.g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> query(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">		scan(u),scan(v),add(u,v);</span><br><span class="line">	dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>),dfs3(<span class="number">1</span>);build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,k;</span><br><span class="line">		scan(x,k);</span><br><span class="line">		matrix ans=solve(x,k);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(ans.g[<span class="number">0</span>][<span class="number">0</span>],ans.g[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>​    [NOIP2018]保卫王国;</p>
<p>​    有两个点,强制选点或强制不选,求最小覆盖集;</p>
<p>​    最小覆盖集=全集-最大权独立集;</p>
<p>​    强制选点或不选可以通过将其改为 $-inf$ 和 $inf$ ,之后就是D-DP模板了;</p>
<h5 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fa[maxn],id[maxn],fl[maxn],sz[maxn],head[maxn];</span><br><span class="line"><span class="keyword">int</span> son[maxn],top[maxn],cent,tot,bot[maxn];</span><br><span class="line">ll f[maxn][<span class="number">2</span>],a[maxn],sum,ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;to[maxn];</span><br><span class="line"><span class="keyword">char</span> type[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">	ll g[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">	matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> matrix x) <span class="keyword">const</span>&#123;</span><br><span class="line">		matrix ans;</span><br><span class="line">		ans.g[<span class="number">0</span>][<span class="number">0</span>]=max(g[<span class="number">0</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">0</span>],g[<span class="number">0</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		ans.g[<span class="number">0</span>][<span class="number">1</span>]=max(g[<span class="number">0</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">1</span>],g[<span class="number">0</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		ans.g[<span class="number">1</span>][<span class="number">0</span>]=max(g[<span class="number">1</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">0</span>],g[<span class="number">1</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		ans.g[<span class="number">1</span>][<span class="number">1</span>]=max(g[<span class="number">1</span>][<span class="number">0</span>]+x.g[<span class="number">0</span>][<span class="number">1</span>],g[<span class="number">1</span>][<span class="number">1</span>]+x.g[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tr[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line">matrix ori[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">	edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">	to[u].push_back(v),to[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	sz[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[y]=x;dfs1(y);</span><br><span class="line">		sz[x]+=sz[y];</span><br><span class="line">		<span class="keyword">if</span>(sz[y]&gt;sz[son[x]]) son[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">	id[x]=++tot,fl[tot]=x,top[x]=tp;</span><br><span class="line">	<span class="keyword">if</span>(son[x]) dfs2(son[x],tp),bot[x]=bot[son[x]];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> bot[x]=x,<span class="keyword">void</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(y,y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	f[x][<span class="number">1</span>]=a[x],f[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs3(y);</span><br><span class="line">		f[x][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">		f[x][<span class="number">1</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	tr[p]=tr[le(p)]*tr[re(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tr[p].g[<span class="number">0</span>][<span class="number">0</span>]=tr[p].g[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;<span class="keyword">int</span> x=fl[l];</span><br><span class="line">		tr[p].g[<span class="number">1</span>][<span class="number">0</span>]=a[fl[l]];tr[p].g[<span class="number">1</span>][<span class="number">1</span>]=-inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">			tr[p].g[<span class="number">0</span>][<span class="number">0</span>]+=max(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">			tr[p].g[<span class="number">1</span>][<span class="number">0</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		tr[p].g[<span class="number">0</span>][<span class="number">1</span>]=tr[p].g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		ori[fl[l]]=tr[p];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	build(l,mid,le(p)),build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">	push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[p]=ori[fl[l]],<span class="keyword">void</span>();</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) add(x,l,mid,le(p));</span><br><span class="line">	<span class="keyword">else</span> add(x,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">	push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tr[p];</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(nl&lt;=mid&amp;&amp;mid&lt;nr) <span class="keyword">return</span> query(nl,nr,l,mid,le(p))*query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(nl&lt;=mid) <span class="keyword">return</span> query(nl,nr,l,mid,le(p));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> query(id[top[x]],id[bot[x]],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,ll k)</span></span>&#123;</span><br><span class="line">	ori[x].g[<span class="number">1</span>][<span class="number">0</span>]+=k-a[x];a[x]=k;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		matrix old,news;</span><br><span class="line">		old=query(top[x]);add(id[x],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">		news=query(top[x]);</span><br><span class="line">		x=fa[top[x]];<span class="keyword">if</span>(!x) <span class="keyword">break</span>;</span><br><span class="line">		ori[x].g[<span class="number">0</span>][<span class="number">0</span>]+=max(news.g[<span class="number">0</span>][<span class="number">0</span>],news.g[<span class="number">1</span>][<span class="number">0</span>])-max(old.g[<span class="number">0</span>][<span class="number">0</span>],old.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		ori[x].g[<span class="number">0</span>][<span class="number">1</span>]=ori[x].g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		ori[x].g[<span class="number">1</span>][<span class="number">0</span>]+=news.g[<span class="number">0</span>][<span class="number">0</span>]-old.g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n,m);<span class="built_in">cin</span>&gt;&gt;type;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]),sum+=a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">		scan(u),scan(v),add(u,v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sort(to[i].begin(),to[i].end());</span><br><span class="line">	dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>),dfs3(<span class="number">1</span>),build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> f1,f2,g1,g2,t1,t2;</span><br><span class="line">		scan(f1,f2,g1,g2);</span><br><span class="line">		<span class="keyword">if</span>(f2==g2&amp;&amp;!f2)&#123;</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pos=lower_bound(to[f1].begin(),to[f1].end(),g1);</span><br><span class="line">			<span class="keyword">if</span>(pos!=to[f1].end()&amp;&amp;(*pos)==g1)&#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">continue</span>;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		t1=a[f1],t2=a[g1];</span><br><span class="line">		modify(f1,f2?-inf:inf);</span><br><span class="line">		modify(g1,g2?-inf:inf);</span><br><span class="line">		matrix ol=query(<span class="number">1</span>);</span><br><span class="line">		ans=max(ol.g[<span class="number">0</span>][<span class="number">0</span>],ol.g[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span>(!f2) ans=ans-inf+t1;</span><br><span class="line">		<span class="keyword">if</span>(!g2) ans=ans-inf+t2;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum-ans);</span><br><span class="line">		modify(f1,t1),modify(g1,t2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    当然还有倍增做法,但这里不再讲述,D-DP中一个重要思想就是讲DP式子变成矩阵乘的形式,用数据结构进行维护,其高效并支持拓展;</p>
]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>折半搜索</title>
    <url>/2019/11/08/meet-in-the-middle/</url>
    <content><![CDATA[<h2 id="折半搜索-meet-in-the-middle"><a href="#折半搜索-meet-in-the-middle" class="headerlink" title="折半搜索(meet in the middle)"></a>折半搜索(meet in the middle)</h2><p>​    我们经常会遇见一些暴力枚举的题目,但是由于时间复杂度太过庞大不得不放弃.</p><p>​    由于子树分支是指数性增长,所以我们考虑将其折半优化;</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    这个知识点曾经在模拟赛中出现过,所以这里稍微提一下;</p><p>​    讲的很浅显,但是不要D讲者;</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​    dfs搜索树是指数性增长,如果将指数减少一半,就将会有量的飞跃,所以在遇见暴力枚举太大时,我们可以考虑这种算法;</p><a id="more"></a>




<p>​    总体思想即,dfs搜素通常从一个点出发,遍历所有深度,那么我们考虑将深度减半,从两个点出发,然后分别统计两边dfs时的信息,整合即可;</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>​    该算法能否使用的关键是整合,两个深度是否能整合在一起需要思考;</p>
<h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>​    我们通过一道例题来讲解;</p>
<blockquote>
<p>​    有一个体积为 $m$ $(m&lt;=1e18)$ 的背包,有 $n$ $(n&lt;=40)$ 个物品,问装背包有多少种方案.</p>
</blockquote>
<p>​    若 $m$ 较小时,该题即一个裸的背包,但本题 $m&lt;=1e18$ 背包就会不可做 (我不会) ;</p>
<p>​    那么考虑最基础的方法,暴力枚举每一种情况,然后统计即可.</p>
<p>​    直接枚举会导致超时,我们可以考虑双向搜索,将物品截半,将第一次搜索时的情况存下来,排序,第二次搜索时,找到一个结果,二分查找第一次的情况,计数即可;</p>
<p>​    </p>
<blockquote>
<p>给 $n$ $(n&lt;=20)$ 个数，从中任意选出一些数，使这些数能分成和相等的两组。</p>
<p>求方案数.</p>
</blockquote>
<p>​    我们同样考虑两遍dfs,分别整理出两次搜索的结果,但是整合时有些麻烦;</p>
<p>​    整合时,我们可以暴力计数,考虑到这些数的随机性,所以期望得分 $100$ ,但是如果出题人精心手造数据,就会有些凉凉;</p>
<p>​    考虑每种情况只会有 $1$ 的贡献,那么我们将 $2^{20}$ 种情况分别跑出来,用两次dfs储存的结果判断是否可行即可;</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    我们面对一些其他算法很难处理的问题,要留住我们的本心 <del>(根)</del> ,优化暴力搜索,也许也会得到一个不错的复杂度.</p>
]]></content>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>关于爆搜</title>
    <url>/2019/11/08/DFS-BFS/</url>
    <content><![CDATA[<h2 id="关于爆搜"><a href="#关于爆搜" class="headerlink" title="关于爆搜"></a>关于爆搜</h2><p>​    <del>(这还用说,讲者太菜了)</del> </p><p>​    爆搜通常是没有思路时一个 <del>优秀</del> 玄学的解题方法,但同样是搜索,我们所的分数却相差甚远,即搜索的优化问题;</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    这是很基础的东西,这里只作为回顾.</p><p>​    讲着实力不足,请不要D讲者;</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>​    BFS,广度优先搜索,用于逐层拓展的工具,可以有效地通过比较同一层之间的结果进行有效地减枝,而相比之下DFS的减枝就比较玄学,故能用BFS时,BFS的时间复杂度一般比DFS要低很多;</p><a id="more"></a>




<p>​    BFS也是SPFA的实现基础 <del>虽然SPFA已经死了</del> .</p>
<p>​    BFS有双重BFS,常用于两个物品有关联地移动.</p>
<p>​    BFS还包括双向BFS,通常用于两个物品移动的相遇问题.</p>
<p>​    <del>例题就不再找了,自行搜索吧</del>;</p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>​    DFS,深度优先搜索,用于寻找单个情况,有着很玄学的时间复杂度.</p>
<p>​    DFS常用于图的遍历和搜索情况,但是在搜索每种情况时,DFS的搜索树会成指数型增长,即爆炸性增长,那么减枝是极其重要的;</p>
<p>​    此时解决这种情况的一种方法是迭代加深,限制深度,多次搜索.虽然看起来极其浪费,但是当答案所在层很浅时,这种算法的时间复杂度比起DFS的搜索树的爆炸性增长,极度优秀;</p>
<p>​    当然迭代加深是有许多限制,我们常用的还是减枝,常用的减枝有贪心减枝,<del>显然错误</del>减枝,以及一些玄学优化;</p>
<p>​    更加高级的还有IDA*优化,最优解减枝;</p>
<p>​    </p>
<p>​    为了增加一些体验感受<del>(讲不动了)</del>,我们加入一些水题;</p>
<p>​    [NOIP2004]虫食算</p>
<blockquote>
<p>给你 $n$ 个字母构成的的 $3$ 行 $n$ 列的 $n$ 进制加法式子,请求出各个字母的一个解.</p>
</blockquote>
<p>​    这是我在搜索入门时写的题目,然后…..<del>炸了</del>.于是我就放弃了,现在再来看这道题,其实还好<del>(还是那么毒瘤)</del></p>
<p>​    正解是什么逆矩阵,我不会啊QWQ(交给数论组吧OAO)</p>
<p>​    那么考虑爆搜,我们暴力枚举每个字母的值,然后求出第 $3$ 行的值,检验即可;</p>
<p>​    但是复杂度会爆炸,怎么办?</p>
<p>​    优化1: 暴力检验第三行<del>(废话)</del></p>
<p>​    优化2:将矩阵扫一遍,检查是否合法;</p>
<p>​    优化3:检验第 $1$ 列,查看是否符合性质;</p>
<p>​    这样应该就可以过了;</p>
<p>​    </p>
<p>​    除了以上这些优化,DFS优化方式还有更加玄学的随机搜索,期望得分较高,实际得分玄学;</p>
]]></content>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>记忆化搜索</title>
    <url>/2019/11/08/mem-dfs/</url>
    <content><![CDATA[<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>​    记忆化搜索,属于DP的分支,但是其实现更加简单,依靠于DFS,所以在一些方面更具优越性;</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    记忆化可以作为DP难以实现时一个简易的方法<del>(我知道你们都秒切DP,就我一个蒟蒻不会QWQ)</del>.</p><p>​    讲的很浅显,但是不要D讲者;</p><h3 id="浅谈"><a href="#浅谈" class="headerlink" title="浅谈"></a>浅谈</h3><p>​    记忆化搜素,顾名思义,是通过储存一个状态的最优信息,减少DFS的搜索树;</p><a id="more"></a>



<p>​    记忆化搜索的几个条件,状态可以储存,而且没有层次的限制(若是一层一层了话,BFS?)</p>
<p>​    它具有几个DP所不具有的优点:</p>
<p>​        1.状态更少;</p>
<p>​        2.可以减枝;</p>
<p>​        3.实现更加简单;</p>
<p>​    但是似乎在状压DP中用的是最多的;</p>
<p>​    [NOIP2016]愤怒的小鸟</p>
<blockquote>
<p>就是让你定几个抛物线(过原点),去砸小猪,看最少用几个小鸟;</p>
</blockquote>
<p>​    思路显然,我们知道两点定一个抛物线,那么考虑直接枚举小猪,定抛物线,二进制记录已经打过的小猪即可,时间复杂度 $O(n^2 log n)$ ;</p>
<p>​    当然我们还可以优化,枚举两个小猪优化到定一个小猪枚举另一个小猪,时间复杂度 $O(n logn)$ ;</p>
<p>​    [NOIP2017]逛公园</p>
<p>​    思路即,先跑个最短路,然后跑个最短路DP即可;</p>
<p>​    但是这里要判 0 环,有两种方法,拓扑和DFS,拓扑就很显然了,但是有许多人写炸;</p>
<p>​    DFS判环我们曾经在SPFA判负环中见过,做法高效;</p>
<p>​    那么我们可以采用DFS记忆化搜索,储存两维状态 $f[x][k]$ ,第一维表示在哪个点,第二维表示与最短路的差值;</p>
<p>​    如果我们跑了正向最短路,那么我们就可以反向建边,跑DFS,用 $dis[y]-dis[x]+edge[i].w$ 求出差值,储存状态即可,而0环的判断,只要记录每个点是否访问过,如果在一次访问过之后再次访问,即得到0环;</p>
<h4 id="话外题"><a href="#话外题" class="headerlink" title="话外题"></a>话外题</h4><p>​    状态压缩是我们常用储存状态的方式,而DFS与状压的结合更加完美,其减枝之后甚至比正解状压DP更快一步.</p>
<p>​    [NOIP2017]宝藏</p>
<blockquote>
<p>有 $n$ 个点和 $m$ 条道路,我们可以选择一个点出发,开拓道路的代价是 $L*K$ (L代表这条道路的长度，K代表从起点到这条道路起点所经过的点的数量)</p>
</blockquote>
<p>​    <del>我们既然是搜索专题,怎么能想正解DP呢</del> ;</p>
<p>​    我们可以暴力枚举起点,然后搜索道路,时间复杂度 $O( 玄学 )=O( 超时 )$ ;</p>
<p>​    考虑优化;</p>
<p>​        1.我们可以在记录状态时用二进制维护</p>
<p>​        2.贪心地从较小边搜索,这样可以较快的解出较优解去减枝;</p>
<p>​        3.每次将一个点的边枚举完之后再去枚举下一个点;</p>
<p>​        4.在同一点,记录枚举到哪条边,避免重复枚举;</p>
<p>​        5.进行最优解减枝,类似于IDA*的做法,我们记录一个当前点之后的价值,加上当前价值,进行减枝,最直接的做法是直接记录所有没有探寻的点的最小出边,然后乘上当前点的K即可;</p>
<p>​    </p>
<p>​    这种减枝速度极快,甚至比正解还快上几分…</p>
<h5 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h5><p>​    有的时候,正解很难得到,我们可以选择搜索,进行合理化减枝(注意,不要减枝错误),<del>也许你就AK了</del>;</p>
]]></content>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>trie浅谈</title>
    <url>/2019/10/30/trie/</url>
    <content><![CDATA[<h2 id="关于trie"><a href="#关于trie" class="headerlink" title="关于trie"></a>关于trie</h2><p>​    其实字典树和以上两种算法有很大不同,但是hash由于其优秀的应用,导致有些字符串查找用hash也是可行的.</p><p>​    字典树中支持添加,查找,区间查询(可持久化字典树),而且在异或操作上有更加好的操作;</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    树的基本构造;</p><h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    字典树是通过动态建点,而形成的树,基本数组有两维, $tr[x][to]$ 中第一维存的是节点标号,而第二维存的是当字符为 $to$ 时通向的节点;</p><a id="more"></a>



<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>​    我当时入门是学的是<a href="https://www.luogu.org/problem/P2580" target="_blank" rel="noopener">这道题</a>;</p>
<blockquote>
<p>给你一些初始字符串,询问,给你一个字符串,这个字符串在这个初始字符串中是否存在</p>
</blockquote>
<p>​    当时使用hash写的,但是没过;</p>
<p>​    现在我们可以用字典树先存一下初始字符串,然后在树上匹配,单次时间复杂度 $O(n)$ ;</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,trie[<span class="number">300007</span>][<span class="number">27</span>],num[<span class="number">300007</span>],sz;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">300007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!trie[now][a[i]-<span class="string">'a'</span>]) trie[now][a[i]-<span class="string">'a'</span>]=++sz;</span><br><span class="line">		now=trie[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	num[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exam</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(a);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!trie[now][a[i]-<span class="string">'a'</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		now=trie[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!num[now]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(vis[now]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	vis[now]=<span class="number">1</span>; <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">60</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">		build(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">60</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">		<span class="keyword">int</span> x=exam(a);</span><br><span class="line">		<span class="keyword">switch</span>(x)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"WRONG\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"REPEAT\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="另"><a href="#另" class="headerlink" title="另"></a>另</h4><p>​    我在hash中介绍了map,这里其实也可以用map存字符串,但是其时间复杂度比原来的多了一个 $logn$ ,写法虽然简单但是时间并不优秀;</p>
<h5 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		p[s]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="keyword">if</span>(p[s]==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"OK"</span>),p[s]=<span class="number">2</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[s]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"WRONG"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[s]==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"REPEAT"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>​    异或,是我们经常会见到的,但是如何高效的处理异或信息是一个让人头痛的事,而字典树为我们提供了策略.    </p>
<h3 id="0-1串树"><a href="#0-1串树" class="headerlink" title="0/1串树"></a>0/1串树</h3><p>​    $0/1$ 串树,常用来储存一个2进制数字,我们知道异或正是与二进制有关,那么我们是否可以找在字典树上操作序列呢?</p>
<p>​    显然是可以的,我们在一个节点,分别走0通向的节点和1通向的节点,那么贪心地操作,这样一定是异或对最大值,反之,都走0或者1可以有效地得到最小值,</p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>​    <a href="https://www.luogu.org/problem/P4551" target="_blank" rel="noopener">最长异或路径</a> ,这个例题应该比较合适;</p>
<blockquote>
<p>给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $N$ 。寻找树中找两个结点，求最长的异或路径。</p>
<p>异或路径指的是指两个结点之间唯一路径上的所有边权的异或。</p>
</blockquote>
<p>​    显然,我们可以将每个点到根root的异或和保存一下,然后将其加入字典树,现在我们要求的就是最大的异或数对,跟上面说的一样,我们只要从字典树顶端开始BFS,就可以得到最大异或数对.</p>
<h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y,z,w) (nd)&#123;x,y,z,w&#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[maxn],dis[maxn],tr[maxn*<span class="number">32</span>][<span class="number">2</span>],ed[maxn*<span class="number">32</span>],val[maxn*<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> tot,cent,ans[<span class="number">34</span>],ol;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,val,dep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">	edge[++cent]=(node)&#123;head[v],u,w&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">		dis[y]=dis[x]^edge[i].w;</span><br><span class="line">		dfs(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//求异或和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">int</span> pos=!!(x&amp;(<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">		<span class="keyword">if</span>(!tr[now][pos]) tr[now][pos]=++tot;</span><br><span class="line">		now=tr[now][pos];</span><br><span class="line">	&#125;</span><br><span class="line">	ed[tot]=id,val[tot]=x;</span><br><span class="line">&#125;<span class="comment">//树中保存</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;nd&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	q.push(mp(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front().x,y=q.front().y,d=q.front().dep;</span><br><span class="line">		<span class="keyword">int</span> val=q.front().val;q.pop();</span><br><span class="line">		<span class="keyword">if</span>(d&gt;<span class="number">30</span>) <span class="keyword">return</span> ans[d];<span class="comment">//到底层了,此时一定是最优解</span></span><br><span class="line">		<span class="keyword">if</span>(ans[d]&gt;val) <span class="keyword">continue</span>;<span class="comment">//减支</span></span><br><span class="line">		<span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">1</span>])&#123;</span><br><span class="line">			q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">			ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">0</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(x!=y) q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">0</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">			ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!tr[x][<span class="number">0</span>]||!tr[y][<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">0</span>])&#123;</span><br><span class="line">					q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">0</span>],val&lt;&lt;<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">					ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">1</span>])&#123;</span><br><span class="line">					q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>,d+<span class="number">1</span>));</span><br><span class="line">					ans[d+<span class="number">1</span>]=max(ans[d+<span class="number">1</span>],val&lt;&lt;<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//分类讨论</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=n<span class="number">-1</span>;i++) scan(u,v,w),add(u,v,w);</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) insert(dis[i],i),ol=max(ol,dis[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(ol,bfs()));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>​    <a href="https://www.luogu.org/problem/CF888G" target="_blank" rel="noopener">CF888G Xor-MST</a> </p>
<blockquote>
<p>已知一个 $n$ 个节点的无向完全图,每个节点的编号为 $a_i$ , $i$ 与 $j$ 的边的权值是 $a_i$ ^ $a_j$ ,求该图的 $MST$ 的权值;</p>
</blockquote>
<p>​    我们可以想一下 $kruskal$ 算法的过程,那么我们也可以每次寻找最小值,可以通过在trie上BFS得到;</p>
<p>​    值得注意的是,所有分叉点的个数为建边个数(去掉两点权值相同),那么其实直接寻找即可;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y,z,w) (node)&#123;x,y,z,w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],tr[maxn*<span class="number">33</span>][<span class="number">2</span>],ed[maxn*<span class="number">33</span>],tot;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];<span class="keyword">bool</span> vis[maxn*<span class="number">33</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dep[<span class="number">34</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,d,ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--,d++)&#123;</span><br><span class="line">		<span class="keyword">int</span> pos=(!(x&amp;(<span class="number">1</span>&lt;&lt;i)));</span><br><span class="line">		<span class="keyword">if</span>(!tr[now][pos]) tr[now][pos]=++tot;</span><br><span class="line">		<span class="keyword">if</span>(tr[now][pos^<span class="number">1</span>]&amp;&amp;!vis[now]) vis[now]=<span class="number">1</span>,dep[d].push_back(now);</span><br><span class="line">		now=tr[now][pos];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ed[now]) fa[ed[now]]=id;</span><br><span class="line">	ed[now]=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> d,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f1=tr[now][<span class="number">0</span>],f2=tr[now][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">	<span class="keyword">int</span> ans[<span class="number">32</span>];</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">127</span>,<span class="keyword">sizeof</span> ans);ans[d]=<span class="number">1</span>;</span><br><span class="line">	q.push((node)&#123;f1,f2,d,<span class="number">1</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		x=q.front().x,y=q.front().y;</span><br><span class="line">		<span class="keyword">int</span> dx=q.front().d,ans1=q.front().ans;q.pop();</span><br><span class="line">		<span class="keyword">if</span>(ed[x]&amp;&amp;ed[y])&#123;</span><br><span class="line">			x=ed[x],y=ed[y];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans1&gt;ans[dx])  <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(tr[x][<span class="number">0</span>]&amp;&amp;tr[y][<span class="number">0</span>]) q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">0</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">1</span>]) q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">1</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!tr[x][<span class="number">0</span>]||!tr[y][<span class="number">0</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(tr[x][<span class="number">1</span>]&amp;&amp;tr[y][<span class="number">0</span>])</span><br><span class="line">				q.push(mp(tr[x][<span class="number">1</span>],tr[y][<span class="number">0</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(tr[y][<span class="number">1</span>]&amp;&amp;tr[x][<span class="number">0</span>])</span><br><span class="line">				q.push(mp(tr[x][<span class="number">0</span>],tr[y][<span class="number">1</span>],dx+<span class="number">1</span>,ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)),ans[dx+<span class="number">1</span>]=min(ans[dx+<span class="number">1</span>],ans1&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans[<span class="number">30</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=get(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen("tree.in","r",stdin);</span></span><br><span class="line"><span class="comment">// 	freopen("tree.out","w",stdout);</span></span><br><span class="line">	scan(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		scan(a[i]);add(a[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dep[i].size()) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dep[i].size();j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x,y,f;</span><br><span class="line">			f=find(dep[i][j],i,x,y);</span><br><span class="line">			<span class="keyword">if</span>(get(x)==get(y)) <span class="keyword">continue</span>;</span><br><span class="line">			fa[get(x)]=get(y);ans+=<span class="number">1l</span>l*f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 2 3 4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="可持久化串树"><a href="#可持久化串树" class="headerlink" title="可持久化串树"></a>可持久化串树</h3><p>​    可持久化串树,即可在区间中查询的串树,与可持久数组有些类似,只是前者用trie,后者用主席树罢了.</p>
<p>​    建树时,我们可以再建一个节点,然后继承上一个节点的信息,然后再建一个新节点去保存自己的信息.</p>
<p>​    区间查询时,我们进入右端点的trie节点,为了限制左边界,我们可以在建图时将其序号标上,在搜索到小于左端点编号时跳过,去寻找另一个节点即可.</p>
<h4 id="建树-0-1trie"><a href="#建树-0-1trie" class="headerlink" title="建树(0/1trie)"></a>建树(0/1trie)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> last,<span class="keyword">int</span> &amp;f,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now;now=f=++tot;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">		trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];<span class="comment">//继承</span></span><br><span class="line">		last=trie[last][ol];</span><br><span class="line">		trie[now][ol]=++tot;<span class="comment">//开拓新节点</span></span><br><span class="line">		mark[tot]=pos;<span class="comment">//记录序号</span></span><br><span class="line">		now=trie[now][ol];<span class="comment">//向下拓展</span></span><br><span class="line">	&#125;</span><br><span class="line">	ending[now]=x;<span class="comment">//结尾数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询-0-1trie"><a href="#查询-0-1trie" class="headerlink" title="查询(0/1trie)"></a>查询(0/1trie)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ending[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这里的查询是在一段区间中查询异或k的最大值;</p>
<h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><p>​    <a href="https://www.luogu.org/problem/P4735" target="_blank" rel="noopener">最大异或和</a>,模版题;</p>
<p>​    我们就按照上面的步骤即可;</p>
<h5 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1200007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,trie[maxn*<span class="number">10</span>][<span class="number">2</span>],a[maxn],sum[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> ending[maxn*<span class="number">10</span>],mark[maxn*<span class="number">10</span>],lim,id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> last,<span class="keyword">int</span> &amp;f,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now;now=f=++tot;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">		trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];</span><br><span class="line">		last=trie[last][ol];</span><br><span class="line">		trie[now][ol]=++tot;</span><br><span class="line">		mark[tot]=pos;</span><br><span class="line">		now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	ending[now]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now=f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ending[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 	freopen("cin.in","r",stdin);</span></span><br><span class="line">	scan(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		scan(a[i]),sum[i]=sum[i<span class="number">-1</span>]^a[i];</span><br><span class="line">		lim=max(sum[i],lim);</span><br><span class="line">	&#125;</span><br><span class="line">	lim=(<span class="keyword">int</span>)log2(<span class="number">1e7</span>)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		build(sum[i],id[i<span class="number">-1</span>],id[i],i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r,x;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">char</span> s=getchar();</span><br><span class="line">		<span class="keyword">while</span>(s!=<span class="string">'A'</span>&amp;&amp;s!=<span class="string">'Q'</span>) s=getchar();</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="string">'A'</span>) scan(x),n++,sum[n]=sum[n<span class="number">-1</span>]^x,build(sum[n],id[n<span class="number">-1</span>],id[n],n);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">'Q'</span>)&#123;</span><br><span class="line">			scan(l,r,x); </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(sum[n]^x)^dfs((sum[n]^x),id[r<span class="number">-1</span>],l<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h4><p>​    <a href="https://www.luogu.org/problem/P5283" target="_blank" rel="noopener">异或粽子</a>,可持久化trie查询区间最大异或值;</p>
<p>​    这道题的思路可以从 <a href="https://www.luogu.org/problem/P2048" target="_blank" rel="noopener">超级钢琴</a> 中得到.</p>
<p>​    超级钢琴的思路是将权值处理出来,与区间信息一起保存在优先队列中,然后每次取出最大值,再更新左右区间即可;</p>
<p>​    而这道题与其不同的是,这里将权值处理出来的方式不同,这里运用可持久化trie,然后在区间查询最大异或值,其他的与超级钢琴几乎一致;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n,k,trie[maxn*<span class="number">23</span>][<span class="number">2</span>],mark[maxn*<span class="number">23</span>],val[maxn*<span class="number">23</span>];</span><br><span class="line">ll sum[maxn],ans,tot,lim=<span class="number">33</span>,a[maxn],id[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	ll val,l,r,pos,ori;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll x,ll last,ll &amp;f,ll pos)</span></span>&#123;</span><br><span class="line">	ll now;now=f=++tot;</span><br><span class="line">	<span class="keyword">for</span>(ll i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		trie[now][<span class="number">0</span>]=trie[last][<span class="number">0</span>];</span><br><span class="line">		trie[now][<span class="number">1</span>]=trie[last][<span class="number">1</span>];</span><br><span class="line">		last=trie[last][ol];</span><br><span class="line">		trie[now][ol]=++tot;</span><br><span class="line">		mark[tot]=pos;</span><br><span class="line">		now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	val[now]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x,ll f,ll op,ll &amp;pos)</span></span>&#123;</span><br><span class="line">	ll now=f;</span><br><span class="line">	<span class="keyword">for</span>(ll i=lim,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i;i&gt;=<span class="number">0</span>;i--,ol=(x&amp;(<span class="number">1</span>&lt;&lt;i))&gt;&gt;i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(trie[now][ol^<span class="number">1</span>]&amp;&amp;mark[trie[now][ol^<span class="number">1</span>]]&gt;=op) now=trie[now][ol^<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> now=trie[now][ol];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pos=mark[now],val[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("xor.in","r",stdin);</span></span><br><span class="line"><span class="comment">//	freopen("xor.out","w",stdout);</span></span><br><span class="line">	scan(n,k);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		scan(a[i]),sum[i]=sum[i<span class="number">-1</span>]^a[i];</span><br><span class="line">		build(sum[i],id[i<span class="number">-1</span>],id[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ll ol,pos;</span><br><span class="line">		ol=query(sum[i<span class="number">-1</span>],id[n],i,pos);</span><br><span class="line">		q.push((node)&#123;ol^sum[i<span class="number">-1</span>],i,n,pos,sum[i<span class="number">-1</span>]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q.empty()) <span class="keyword">continue</span>;</span><br><span class="line">		node x=q.top();ans+=x.val;q.pop();</span><br><span class="line">		ll ol,pos;</span><br><span class="line">		<span class="keyword">if</span>(x.l&lt;x.pos)&#123;</span><br><span class="line">			ol=query(x.ori,id[x.pos<span class="number">-1</span>],x.l,pos);</span><br><span class="line">			q.push((node)&#123;ol^x.ori,x.l,x.pos<span class="number">-1</span>,pos,x.ori&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x.pos&lt;x.r)&#123;</span><br><span class="line">			ol=query(x.ori,id[x.r],x.pos+<span class="number">1</span>,pos);</span><br><span class="line">			q.push((node)&#123;ol^x.ori,x.pos+<span class="number">1</span>,x.r,pos,x.ori&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>​    这里只是总结了一下trie的用法,我见到的主要还是0/1trie,以后见到还会再加入;</p>
<h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>hash应用</title>
    <url>/2019/10/30/hash/</url>
    <content><![CDATA[<h2 id="关于HASH"><a href="#关于HASH" class="headerlink" title="关于HASH"></a>关于HASH</h2><p>​    这应该是经常使用的一个算法,因为其预处理后,优秀的$O(1)$处理出子串,并且$O(1)$比较,大快人心,而且写法简单,令人心情愉悦;</p><p>​    但是其空间复杂度较高,并且有玄学模数以及哈希冲突,以至于如果想hack,其实可以hack掉;</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    关于进制,模数,hash就用到了重构进制,取模稀疏,所以哈希表又叫稀疏表;</p><a id="more"></a>


<h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    hash很好理解,而且匹配非常方便,<del>不容易写炸,对于萌新十分友好</del>,</p>
<h3 id="HASH查询"><a href="#HASH查询" class="headerlink" title="HASH查询"></a>HASH查询</h3><p>​    我们知道数字匹配复杂度为 $O(1)$ ,数字匹配速度快,而字符串却只能一个一个匹配, <del>这不公平</del> .那么我们考虑将字符串变成数字.</p>
<p>​    想一下数字有进制,那么我们定义一下字母的进制,不一定是26,我们可以随便取一个数,习惯性取质数;</p>
<p>​    但是数字太长,爆 $long$ $long$ 我们没办法存怎么办,我们考虑字符串很少,但是空间很大,我们考虑将数字安排入一个位置,其实这个位置是随机的,但是我们可以推出,这就够了;</p>
<p>​    那么我们可以模一个数字,将数字限制在一个范围之内,然后储存下来,而这个模数一般是一个质数,因为质数的特殊性质,可以造成更好地将数字稀疏;</p>
<h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll base=<span class="number">133</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">19491001</span>;</span><br><span class="line"><span class="function">ll <span class="title">id</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);ll ol=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">		ol=(ol*base+s[i]-<span class="string">'a'</span>+<span class="number">1</span>)%mod;</span><br><span class="line">	<span class="keyword">return</span> ol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    处理复杂度 $O(n)$ 然后开个数组储存即可;</p>
<h3 id="HASH子串匹配"><a href="#HASH子串匹配" class="headerlink" title="HASH子串匹配"></a>HASH子串匹配</h3><p>​    我们知道,如果每次都处理出一个串的子串,那么时间复杂度 $O(n^2)$ ,这是我们不能接受的,但是考虑一下我们存的是数字,数字有进制,那么一定可以通过加减操作得到其子串,那么,就简单很多了;</p>
<p>​    我们可以先预处理出 $HASH$ 前缀和,之后通过加减得到一段区间的子串;</p>
<p>​    但是直接开数组了话,有可能开不下,或者加大hash冲突的可能(即两个字符串hash值相同),那么我们可以考虑在不超时的情况下,加入一个map储存hash值,这样不需再担心空间问题,但是每次查询时间会多一个 $logn$ ,请谨慎使用;</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>​    我不再直接附上模版,而是引入一个 <a href="https://www.luogu.org/problem/P5546" target="_blank" rel="noopener">例题</a>;</p>
<blockquote>
<p>给出几个由小写字母构成的单词，求它们最长的公共子串的长度。</p>
</blockquote>
<h5 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h5><p>​    我们可以二分枚举公共子串长度,因为公共子串长度一定是满足单调性质的.</p>
<p>​    那么我们选择枚举第一个串的子串,然后将其他串中相同长度的子串储存起来,那么就可以匹配了;</p>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ll base=<span class="number">133</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt;ha[<span class="number">6</span>];</span><br><span class="line">ll sum[<span class="number">6</span>][maxn],ad[maxn];</span><br><span class="line"><span class="keyword">int</span> n,lim=maxn,len[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">6</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sum[pos][r+<span class="number">1</span>]-sum[pos][l]*ad[r-l+<span class="number">1</span>]%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ha[i].clear();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+l<span class="number">-1</span>&lt;len[i];j++)</span><br><span class="line">			ha[i][id(i,j,l+j<span class="number">-1</span>)]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+l<span class="number">-1</span>&lt;len[<span class="number">1</span>];i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=id(<span class="number">1</span>,i,i+l<span class="number">-1</span>),cnt=n<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ha[j][temp]) cnt--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!cnt) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ad[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2001</span>;i++) ad[i]=ad[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len[i];j++)&#123;</span><br><span class="line">			sum[i][j+<span class="number">1</span>]=(sum[i][j]*base+(c[i][j]-<span class="string">'a'</span>))%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,c[i]),lim=min(len[i]=<span class="built_in">strlen</span>(c[i]),lim);</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=lim;init();</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP浅谈</title>
    <url>/2019/10/30/KMP/</url>
    <content><![CDATA[<h2 id="关于KMP"><a href="#关于KMP" class="headerlink" title="关于KMP"></a>关于KMP</h2><p>​    KMP其实是三个人名字的缩写,因为是他们同时发现的<del>(大佬惹不起)</del>;</p><p>​    KMP作为CSP考点,主要亮点是其优秀的匹配复杂度,而且消耗空间小,比起hash虽然有些局限性,但是因为其正确率高,所以经常被人使用.</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>​    关于字符串的读取,以及字符串相关操作的基础了解,这里涉及字符串匹配以及子串;</p><a id="more"></a>


<h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>​    其实KMP并不困难,只是让人难受的是它比较抽象的数组跳跃,我想这个并不需要过多解释;</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>​    KMP常用于一个字符串是否出现在另一个字符串中.我们知道,如果暴力匹配了话,每次失配时就必须重新开始(不能贪心地从失配位置匹配),这样造成很大的浪费,那么我们想从已经匹配过的字符串中提取一些信息,以至于让我们不跳那么远,那这怎么办?</p>
<p>​    KMP算法就由此诞生了,它通过记录模式串的内部信息,为匹配时提供信息,可以节省大量时间.</p>
<h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,nxt[maxn],l1,l2,ans;</span><br><span class="line"><span class="keyword">char</span> s1[maxn],s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nxt</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	nxt[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l2;i++)&#123;</span><br><span class="line">		t=nxt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span>(s2[i]!=s2[t+<span class="number">1</span>]&amp;&amp;t&gt;=<span class="number">0</span>) t=nxt[t];</span><br><span class="line">		<span class="keyword">if</span>(s2[t+<span class="number">1</span>]==s2[i]) nxt[i]=t+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> nxt[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;l1)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">			i++,j++;</span><br><span class="line">			<span class="keyword">if</span>(j==l2)</span><br><span class="line">				ans++,j=nxt[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">0</span>) i++;</span><br><span class="line">			<span class="keyword">else</span> j=nxt[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;s2&gt;&gt;s1;ans=<span class="number">0</span>;</span><br><span class="line">		l1=<span class="built_in">strlen</span>(s1),l2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">		<span class="built_in">memset</span>(nxt,<span class="number">0</span>,<span class="keyword">sizeof</span> nxt);</span><br><span class="line">		get_nxt();KMP();</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于next数组的几个性质"><a href="#关于next数组的几个性质" class="headerlink" title="关于next数组的几个性质"></a>关于next数组的几个性质</h3><p>​    因为next与stl冲突所以命名为nxt数组;</p>
<p>​    next数组有一些性质:</p>
<p>​    $next[l]$ 到 $l$ 为模式串的最小循环节,当然必须满足一个条件,即最小循环节长度是整个串长度的因数,如果不是了话,那么一定是开头的字符串有残余,而残余字符串为循环节的后缀;</p>
<p>​    那么考虑一下,如果我们想要找最小循环节,直接初始化后,找 $next[l]$ 即可,当然还要判断一下;</p>
<p>​    想象一下 $next$ 数组的跳跃,我们能找到什么?即从 $1$ ~ $next [ l ] $ 既是前缀又是后缀,那么我们可以找到子串中的最大前缀和后缀相同的;</p>
<h3 id="匹配时需要注意的细节"><a href="#匹配时需要注意的细节" class="headerlink" title="匹配时需要注意的细节"></a>匹配时需要注意的细节</h3><p>​    我们常常会遇到让我们求出循环次数,以及不重叠循环次数,其区别只是判断 $j==l2$ 时 $j$ 是否要跳回 $next[j]$ ;</p>
<p>​    或者是直接判断是否有这个模式串,直接 $return$ 即可;</p>
<h3 id="关于题目变形"><a href="#关于题目变形" class="headerlink" title="关于题目变形"></a>关于题目变形</h3><p>​    主要是应该看出匹配方式,以及字符串的重构问题;</p>
<h5 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h5>]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>基环树初步</title>
    <url>/2019/10/26/Base-ring-tree/</url>
    <content><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>​    说实话,基环树一般比较综合,所以一般只要就要具有图论基本知识便可以开始学习.</p><h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>​    博主实力不足,如果出错,<del>请用力D他</del> .</p><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>​    基环树,原体是树,有树上任意连一条边,就成了一个环,即基环树,一般特征,$n$个点$n$条边;</p><p>​    由于有树的特征,所以经常会用一些树的算法来计算基环树;</p><a id="more"></a>



<h2 id="基础的知识"><a href="#基础的知识" class="headerlink" title="基础的知识"></a>基础的知识</h2><h3 id="找环"><a href="#找环" class="headerlink" title="找环"></a>找环</h3><p>​    寻找环,这是基环树的基础,也很简单.</p>
<p>​    考虑记录每个点是否访问过,当再次经过这个点时,那么这个点就能找出这个环了.</p>
<p>​    我们只要在dfs时记录点的前继即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cir</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=x;stk[++tot]=x;id[x]=tot;w[y]=f;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		temp=pre[temp];</span><br><span class="line">		stk[++tot]=temp;</span><br><span class="line">		id[temp]=tot;</span><br><span class="line">	&#125;<span class="keyword">while</span>(temp!=y);</span><br><span class="line">	sum[<span class="number">1</span>]=w[y];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+w[stk[i<span class="number">-1</span>]];</span><br><span class="line">&#125;<span class="comment">//记录环 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!vis[y]) &#123;</span><br><span class="line">			pre[y]=x,w[y]=edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dfs1(y,x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			get_cir(x,y,edge[i].w);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//返回值为是否找到环</span></span><br></pre></td></tr></table></figure>
<p>​    这个是根据原理自己构造的,需要注意的是,环处理出来的前缀和终点不是该点,即$sum[i]$为从0点到$i+1$点的距离,所以记录环中第2个for循环就是讲$sum$数组循环移动一次,当然这是我自己构造而导致的$bug$,不过也并不碍事;</p>
<h3 id="子树DP找直径以及最大深度"><a href="#子树DP找直径以及最大深度" class="headerlink" title="子树DP找直径以及最大深度"></a>子树DP找直径以及最大深度</h3><p>​    这里应该是比较基础的,确实,两遍bfs或dfs理解很容易,但是相比之下,DP有更优的时间以及优秀的代码长度,所以DP找直径是必要的;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	ll other=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa||id[y]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(y,x);</span><br><span class="line">		f=max(f,root[x]+root[y]+edge[i].w);</span><br><span class="line">		f=max(f,other+root[y]+edge[i].w);<span class="comment">//更新直径 </span></span><br><span class="line">		other=max(other,root[y]+edge[i].w);</span><br><span class="line">		dep[x]=max(dep[x],dep[y]+edge[i].w);<span class="comment">//深度更新 </span></span><br><span class="line">	&#125;</span><br><span class="line">	root[x]+=other;</span><br><span class="line">&#125;<span class="comment">//DP找直径以及最大深度</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶结合"><a href="#进阶结合" class="headerlink" title="进阶结合"></a>进阶结合</h2><p>​    基环树,最终都是在环上处理问题,通常处理路径长度问题,因为博主实力不足,目前见过两种,都总结下来;</p>
<h3 id="set维护"><a href="#set维护" class="headerlink" title="set维护"></a>set维护</h3><p>​    <strong><a href="https://www.luogu.org/problem/CF835F" target="_blank" rel="noopener">Roads in the Kingdom</a></strong></p>
<blockquote>
<p>​    王国有$n$座城市与$n$条有长度的街道，保证所有城市直接或间接联通，我们定义王国的直径为所有点对最短距离中的最大值，现因财政危机需拆除一条道路并同时要求所有城市仍然联通，求所有拆除方案中王国直径的最小值</p>
</blockquote>
<p>​    显然,这是一道有基环树特征的题,考虑枚举拆除道路,即环上道路(不在环上就不连通了),那么如何快速求出直径是我们所需要的;</p>
<p>​    我们可以先考虑直径不过环,那么可以先DP预处理出子树上直径,并同时处理出最大深度$dep$(后面要用).</p>
<p>​    之后考虑环上直径,我们可以维护环上前缀和,注意前缀和$sum[i]$必须以点$i$结尾;那么,直径公式就很显然了;</p>
<script type="math/tex; mode=display">
max_{i<j}(sum[j]+dep[j]-sum[i]+dep[i])</script><p>​    那么,我们可以用两个set维护$sum[i]+dep[i]$和$-sum[i]+dep[i]$,每次取出最大值,相加即可;</p>
<p>​    还有一些细节问题需要注意:</p>
<blockquote>
<p>1.显然$i\not =j$,如果相等,我们可以取次小值最大的更新.</p>
<p>2.万一不在一个环上怎么办,我们知道,环上有两种求直径, $sum[j]-sum[i]$ 和 $sum[tot]-sum[j]+sum[i]$,那么我们如何保证一定是第一个公式呢.考虑我们在存前缀和时,$sum[1]$是点$1$与点$tot$之间的距离,那么我们可以先枚举这条边,那么,此时一定是第一个公式,这个可以想一想环上前缀和的特点;那么我们就可以在枚举点,枚举的边即为它与$i-1$之间的边,每次到下一个点,使我们这个点的$sum$加上$sum[tot]$,即相当于变成了前缀和最后一个点,然后在set中加入,并删除以前的;</p>
<p>3.如何保证$j&gt;i$,考虑一下,如果 $j<i$ ,但是前缀和中 $sum[i]>sum[j]$ ,那么显然</i$></p>
<script type="math/tex; mode=display">
sum[j]+dep[j]-sum[i]+dep[i]<sum[i]+dep[i]-sum[j]+dep[j]</script><p>而我们求出的是最优的,所以一定是后者,所以只要注意一下第一条所说的$i=j$的情况,其他情况下$i&lt;j$.</p>
</blockquote>
<p>这样应该就能解决了,对了,multiset的结构体删除请注意一下,重载运算符可能会出差错;</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 400007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x,y) (d)&#123;x,y&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st multiset<span class="meta-string">&lt;d&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[maxn],pre[maxn],stk[maxn],id[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> cent,vis[maxn],w[maxn];</span><br><span class="line">ll sum[maxn],ans,dep[maxn],root[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">	edge[++cent]=(node)&#123;head[v],u,w&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cir</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=x;stk[++tot]=x;id[x]=tot;w[y]=f;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		temp=pre[temp];</span><br><span class="line">		stk[++tot]=temp;</span><br><span class="line">		id[temp]=tot;</span><br><span class="line">	&#125;<span class="keyword">while</span>(temp!=y);</span><br><span class="line">	sum[<span class="number">1</span>]=w[y];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+w[stk[i<span class="number">-1</span>]];</span><br><span class="line">&#125;<span class="comment">//记录环 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	vis[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!vis[y]) &#123;</span><br><span class="line">			pre[y]=x,w[y]=edge[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dfs1(y,x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			get_cir(x,y,edge[i].w);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//返回值为是否找到环 </span></span><br><span class="line"></span><br><span class="line">ll f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	ll other=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==fa||id[y]) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(y,x);</span><br><span class="line">		f=max(f,root[x]+root[y]+edge[i].w);</span><br><span class="line">		f=max(f,other+root[y]+edge[i].w);<span class="comment">//更新直径 </span></span><br><span class="line">		other=max(other,root[y]+edge[i].w);</span><br><span class="line">		dep[x]=max(dep[x],dep[y]+edge[i].w);<span class="comment">//深度更新 </span></span><br><span class="line">	&#125;</span><br><span class="line">	root[x]+=other;</span><br><span class="line">&#125;<span class="comment">//DP找直径以及最大深度 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d</span>&#123;</span></span><br><span class="line">	ll val,pos;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> d &amp;x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val&gt;x.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;d&gt;a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n);ans=<span class="number">2305843009213693652</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=n;i++) scan(u,v,w),add(u,v,w);</span><br><span class="line">	dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) dfs2(stk[i],<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">		a.insert(mp(sum[i]+dep[stk[i]],i)),b.insert(mp(-sum[i]+dep[stk[i]],i));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">		st x=a.begin(),y=b.begin();</span><br><span class="line">		ll ol=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x-&gt;pos==y-&gt;pos)&#123;</span><br><span class="line">			st dir=a.begin();dir++;</span><br><span class="line">			ol=dir-&gt;val+y-&gt;val;</span><br><span class="line">			dir=b.begin();dir++;</span><br><span class="line">			ol=max(ol,dir-&gt;val+x-&gt;val);</span><br><span class="line">		&#125;<span class="keyword">else</span> ol=x-&gt;val+y-&gt;val;</span><br><span class="line">		ans=min(ans,ol);</span><br><span class="line">		x=a.find(mp(sum[i]+dep[stk[i]],i)),y=b.find(mp(-sum[i]+dep[stk[i]],i));</span><br><span class="line">		a.erase(x),b.erase(y);</span><br><span class="line">		a.insert(mp(sum[i]+sum[tot]+dep[stk[i]],i)),b.insert(mp(-sum[i]-sum[tot]+dep[stk[i]],i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,max(f,ans));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>​    <strong><a href="https://www.luogu.org/problem/P4381" target="_blank" rel="noopener">P4381 [IOI2008]Island</a></strong></p>
<blockquote>
<p>你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为$L_i$的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：</p>
<ul>
<li><p>可以自行挑选一个岛开始游览。</p>
</li>
<li><p>任何一个岛都不能游览一次以上。</p>
</li>
<li><p>无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$</p>
<p> 有如下方法： </p>
<ul>
<li>步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。</li>
<li>渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。</li>
</ul>
</li>
</ul>
<p>注意，你不必游览所有的岛，也可能无法走完所有的桥。</p>
</blockquote>
<p>​    我们很容易分析出这是一个基环树森林,分别计算每一个基环树上的直径,但是我们不能排除环的干扰,难道要暴力枚举环上边,博主并没有尝试,<del>决定口胡</del>;</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>​    以下为博主口胡部分(并不是主流的正解做法):</p>
<p>​    根据公式$d=sum[j]-sum[i]+dep[i]+dep[j]$;</p>
<p>​    我们可以用上面的方法枚举断边,然后用set维护,求出最大直径,之后对于每一个基环树进行操作,累加和即可.</p>
<p>​    总时间复杂度$O(nlongn)$,估计可以通过此题,但是因为这道题时间太过久远,博主在之前写过单调队列,已经不想再写一遍了,不过这种方法预测可行<del>(还挺具有普适性的)</del>;</p>
<h4 id="主流的单调队列"><a href="#主流的单调队列" class="headerlink" title="主流的单调队列"></a>主流的单调队列</h4><p>​    显然,我们可以枚举点$i,j$,不过这样会$T$,</p>
<p>​    但是考虑当$i&lt;j$时,我们可以用单调队列维护$-sum[i]+dep[i]$的最大值,然后断环成链,更新即可</p>
<p>​    至于出队条件,即为$pos[j]-pos[front]&gt;len$($len$为环长度).时间复杂度$O(n)$.</p>
<p>​    这里不再附上代码,因为当时代码太丑,有很大一部分是与他人代码雷同(因为当时不会写),为了防止误导,就不再附上代码;</p>
<p>ps:当遇到这类题时会再次update.</p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>一维以及二维的差分的简述</title>
    <url>/2019/10/25/one-two-difference/</url>
    <content><![CDATA[<p>　　差分，也就是数与数之间的差值。拿一维差分来举例子，将差分设为c[ ]数组，原数为a[ ],那么</p><p>　　$c[i]=a[i]-a[i-1]$</p><p>　　这便是简单的差分数组；</p><p>　　那么要他何用？</p><p>　　最为主要的作用就是区间的修改，那么在修改之前，我们先明白如何将原数求出。很显然，$c[1]$~$c[i]$差分数组求和即可得到$a[i]$。</p><a id="more"></a>




<p>　　那区间修改呢？</p>
<p>　　如我们将从l到r的区间加上s（减去也一样），那么由差分数组的定义得，观察数组，发现只有c[l]和c[r+1]变化了。</p>
<p>　　具体证明可以手动模拟，而中间的不变是因为i项与i-1项都加上了s，差值不变;</p>
<p>　　那么这样就能得到</p>
<p>　　$a[l]$~$a[r]+=s$—&gt;$c[l]+s,c[r+1]+s$</p>
<p>　　这样就实现了$O(1)$修改；</p>
<p>　　当然还有区间求和，这里给出证明</p>
<p><img src="\images\7.png" alt="alt"></p>
<p>　　这样我们可以发现一个规律，即第二个多项式的系数为i-1</p>
<p>　　那么我们用c2[ ]来维护这个数组，那么</p>
<script type="math/tex; mode=display">
c2[i]=(i-1)*c[i]</script><p>　　并且在修改时维护$c2[ i]$数组，即</p>
<script type="math/tex; mode=display">
c[l]+(l-1)*s,c[r+1]-(r+1-1)*s</script><p>　　之后便有了公式</p>
<p>　　<img src="\images\8.png" alt="alt"></p>
<p>　　这里便是一维差分</p>
<p>　　<strong>二维差分的推导</strong></p>
<p>　　这里的推导只是单纯的根据一维差分和二维前缀和的性质来推的</p>
<p>　　二维前缀和请务必提前了解，并有一定的认识；</p>
<p>　　那么开始推导；</p>
<p>　　根据二维前缀和表示的是右上角矩形的和，由于差分只涉及前面相邻的数（由一维可以推出），并且由前面范围的数相加得到这个位置的数；</p>
<p>　　那么类比二维前缀和和一维差分，可以简单推测出二维差分的公式</p>
<p>　　$c[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$</p>
<p> 　　是不是觉得非常眼熟？</p>
<p>　　我们再代入检验，即将左上角的矩阵差分求和，正好得到了这个数·</p>
<p>　　这还并不能代表什么，重要的是区间的修改；</p>
<p>　　同样，我们将要修改的矩阵的右上角设为$(x1,y1)$,右下角设为$(x2,y2)$</p>
<p>　　<img src="\images\9.png" alt="alt"></p>
<p>　　我们发现有影响的只有我所标注的点，除了$(x2,y2)$,这个应该很好看出；</p>
<p>　　那么，我们就得到公式</p>
<p>　　$c[x1][y1]+=s,c[x1][y2+1]-=s,c[x2+1][y1]-=s,c[x2+1][y2+1]+=s$</p>
<p>　　推荐自己再推一遍。</p>
<p>　　之后求数只需累加即可。</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线</title>
    <url>/2019/10/25/scan-line/</url>
    <content><![CDATA[<p>请在学习之前有一定的线段树基础</p><p>在一些题中，它总会给你一些矩形，之后让你求总覆盖面积。</p><p>它的难点在于，有重叠面积，如果只是罗列情况，那么只会一事无成。</p><p>所以说，这里就引进了扫描线做法；</p><p>其实它的原理很简单，只是底*高而已，只是分段求解；</p><p>而问题大概的图就是这样</p><p><img src="/images/10.png" alt="alt"></p><p>根据我刚刚说的分段求解和底*高，那么我们就可以推测出扫描线是什么了</p><a id="more"></a>







<p>它是由矩形的上边和下边构成，并记录其左右端点和其所在的纵坐标；</p>
<p><img src="/images/11.png" alt="img"></p>
<p>图中标红的即为扫描线，那么我们用它做什么？</p>
<p>根据 S=a<em>h，那么我们可以将扫描线按<em>*纵坐标排序</em></em>，这样分步求解。</p>
<p>这是扫描线的储存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//左右端点坐标 </span></span><br><span class="line">    <span class="keyword">int</span> h;<span class="comment">//还是按 扫描线写，这个是y轴坐标 </span></span><br><span class="line">    <span class="keyword">int</span> d;<span class="comment">//标记这个线是不是上界或下界 </span></span><br><span class="line">&#125;s[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线</span></span><br></pre></td></tr></table></figure>
<p>那么便可以得到高，即</p>
<p><strong>s[i+1].h-s[i].h</strong></p>
<p>之后考虑存底，只需要用线段树维护即可；</p>
<p>当扫描线为下界时，应当将扫描线所在区域加入线段树，而当为上界时再减去即可；</p>
<p>由于底边过大，不可能全部建树，这里给出了离散化做法，还有动态开点做法之后将会提到</p>
<p>由于找不到最合适的模板题，只能拿这个来充数<a href="https://www.luogu.org/problemnew/show/P2061" target="_blank" rel="noopener"> P2061 [USACO07OPEN]城市的地平线City Horizon</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,h;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;h);</span><br><span class="line">    ls[++cent]=a;<span class="comment">//其实是用来离散化的 </span></span><br><span class="line">    s[cent]=(node)&#123;a,b,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    ls[++cent]=b;</span><br><span class="line">    s[cent]=(node)&#123;a,b,h,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(ls+<span class="number">1</span>,ls+<span class="number">1</span>+cent);<span class="comment">//离散化初始 </span></span><br><span class="line">sort(s+<span class="number">1</span>,s+<span class="number">1</span>+cent);ls[++m]=ls[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls[i]!=ls[i<span class="number">-1</span>])</span><br><span class="line">        ls[++m]=ls[i];<span class="comment">//去重 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这便是简单的离散化，当然，你也可以排序后用unique函数，得到m和ls数组，这个可以网上查询，这里便不再赘述</p>
<p>之后是线段树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[p]) tree[p].sum=ls[r]-ls[l];<span class="comment">//如何避免少减？ </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tree[p].sum=tree[le(p)].sum+tree[re(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_date</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> d,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=tree[p].l,r=tree[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        mark[p]+=d;</span><br><span class="line">        push_up(l,r,p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r<span class="number">-1</span>==l) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=L) up_date(le(p),d,L,R);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) up_date(re(p),d,L,R);</span><br><span class="line">    push_up(l,r,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码是我根据多种方面得出，但是仍由问题，即代码所说的，因为在线段数中 l 是可以等于 r 的，但是线段的长度必须由两个不同的数得出，这是不行的</p>
<p>所以，我们可以先建出一颗空树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l;</span><br><span class="line">    tree[p].r=r;</span><br><span class="line">    tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p)),build(mid,r,re(p));<span class="comment">/*注意，mid在左子树和右子树中都有出现，所以在 </span></span><br><span class="line"><span class="comment">    叶子节点，r=l+1，这个也是对return 的解释*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说，这样便避免了这个问题，不过请读者注意这些点，这些便是易错的小细节</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">build(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> l=search(s[i].x,ls);<span class="comment">//二分寻找离散化位置</span></span><br><span class="line">    <span class="keyword">int</span> r=search(s[i].y,ls);</span><br><span class="line">    up_date(<span class="number">1</span>,s[i].d,l,r);<span class="comment">// 用线段树更新sum，即矩形底边 </span></span><br><span class="line">    rt+=(ll)tree[<span class="number">1</span>].sum*<span class="number">1l</span>l*(s[i+<span class="number">1</span>].h-s[i].h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是主函数的计算，而search有解释，也可以用lower_bound，推荐提前处理出来，否则可能会提高时间复杂度，这不是我们所期望的</p>
<p>这样的做法不易错是真的，这里给出二分search做法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> pur,<span class="keyword">int</span>* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[mid]&lt;pur) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这便是整个过程，这里给出<strong>code</strong></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 40007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,cent,m,mark[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> ls[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line">ll rt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tr</span>&#123;</span></span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//左右端点坐标 </span></span><br><span class="line">    <span class="keyword">int</span> h;<span class="comment">//还是按 扫描线写，这个是y轴坐标 </span></span><br><span class="line">    <span class="keyword">int</span> d;<span class="comment">//标记这个线是不是上界或下界 </span></span><br><span class="line">&#125;s[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[p]) tree[p].sum=ls[r]-ls[l];<span class="comment">//如何避免少减？ </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l==r) tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tree[p].sum=tree[le(p)].sum+tree[re(p)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_date</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> d,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=tree[p].l,r=tree[p].r;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        mark[p]+=d;</span><br><span class="line">        push_up(l,r,p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r<span class="number">-1</span>==l) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=L) up_date(le(p),d,L,R);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R) up_date(re(p),d,L,R);</span><br><span class="line">    push_up(l,r,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].l=l;</span><br><span class="line">    tree[p].r=r;</span><br><span class="line">    tree[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p)),build(mid,r,re(p));<span class="comment">/*注意，mid在左子树和右子树中都有出现，所以在 </span></span><br><span class="line"><span class="comment">    叶子节点，r=l+1，这个也是对return 的解释*/</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> pur,<span class="keyword">int</span>* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[mid]&lt;pur) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,h;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;h);</span><br><span class="line">        ls[++cent]=a;<span class="comment">//其实是用来离散化的 </span></span><br><span class="line">        s[cent]=(node)&#123;a,b,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        ls[++cent]=b;</span><br><span class="line">        s[cent]=(node)&#123;a,b,h,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ls+<span class="number">1</span>,ls+<span class="number">1</span>+cent);<span class="comment">//离散化初始 </span></span><br><span class="line">    sort(s+<span class="number">1</span>,s+<span class="number">1</span>+cent);ls[++m]=ls[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ls[i]!=ls[i<span class="number">-1</span>])</span><br><span class="line">            ls[++m]=ls[i];<span class="comment">//去重 </span></span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l=search(s[i].x,ls);<span class="comment">//二分寻找离散化位置</span></span><br><span class="line">        <span class="keyword">int</span> r=search(s[i].y,ls);</span><br><span class="line">        up_date(<span class="number">1</span>,s[i].d,l,r);<span class="comment">// 用线段树更新sum，即矩形底边 </span></span><br><span class="line">        rt+=(ll)tree[<span class="number">1</span>].sum*<span class="number">1l</span>l*(s[i+<span class="number">1</span>].h-s[i].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;rt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-24-补充："><a href="#7-24-补充：" class="headerlink" title="7.24 补充："></a>7.24 补充：</h2><p><a href="https://www.luogu.org/problemnew/show/P1502" target="_blank" rel="noopener"><strong>LUOGU P1502 窗口的星星</strong></a></p>
<p>　　</p>
<h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>小卡买到了一套新房子，他十分的高兴，在房间里转来转去。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>晚上，小卡从阳台望出去，“哇~~~~好多星星啊”，但他还没给其他房间设一个窗户，天真的小卡总是希望能够在晚上能看到最多最亮的星星，但是窗子的大小是固定的，边也必须和地面平行。这时小卡使用了超能力（透视术）知道了墙后面每个星星的位置和亮度，但是小卡发动超能力后就很疲劳，只好拜托你告诉他最多能够有总和多亮的星星能出现在窗口上。</p>
<h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p><strong>输入格式：</strong></p>
<p>本题有多组数据，第一行为T 表示有T组数据T&lt;=10</p>
<p>对于每组数据</p>
<p>第一行3个整数n，W，H，（n&lt;=10000,1&lt;=W,H&lt;=1000000）表示有n颗星星，窗口宽为W，高为H。</p>
<p>接下来n行，每行三个整数xi，yi，li 表示星星的坐标在（xi，yi），亮度为li。（0&lt;=xi,yi&lt;2^31)</p>
<p><strong>输出格式：</strong></p>
<p>T个整数，表示每组数据中窗口星星亮度总和的最大值。</p>
<p>这道题的一个关键点是，将星星作为一个窗户的左下角（其实是为了不出现负数），将每一个星星都创一个窗户，之后寻找重叠部分</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h3><p><strong><img src="/images/12.png" alt="alt"></strong></p>
<p>看这个图，这是两个相交的情况，矩形左下角是星星，然后如果有重叠部分，那么我们要贴着相交部分的上边和右边建一个窗户，那么就可以盖住这两个星星，</p>
<p><img src="/images/13.png" alt="alt"></p>
<p>类比到所有星星是一样的，我们只要将矩形附上权值即可，用扫描线寻找。</p>
<p><strong>但是这个边框不是不能包含星星吗？所以我们需要处理一些小细节，将矩形右边的横坐标减去1，也就是提前减去，再将扫描线上端-1，这就处理了边界问题；</strong></p>
<p><strong>并且在sort的时候当横坐标相同时，将加上的排在前面。</strong></p>
<p>这个细节请一定要理解，否则wa了也不好调（因为不给数据），代码我会做上标记。</p>
<p>矩形权值直接附在扫描线上即可；</p>
<p>上一道例题中，我用离散化解决了范围大的问题，这里我们介绍动态开点做法；</p>
<p>首先不需要在意太多的离散化细节是一个优点，干干的介绍不是非常简洁，所以我直接附上代码讲解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,w,h,cnt,lim,root;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,l,r,w,d;</span><br><span class="line">&#125;a[maxn&lt;&lt;<span class="number">3</span>];<span class="comment">//扫描线 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> le,ri,w,tag;</span><br><span class="line">&#125;tr[<span class="number">5000007</span>];<span class="comment">//动态开点的不同，le和ri记录的是左端点和右端点的p值 </span></span><br><span class="line"><span class="comment">//tr记住稍微大一点 （别 MLE 了 ），反正不会错 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x==y.x?x.d&gt;y.d:x.x&lt;y.x;</span><br><span class="line">&#125;<span class="comment">//sort的细节*** </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[p].le) tr[p].le=++cnt;<span class="comment">//没点开点 </span></span><br><span class="line">    <span class="keyword">if</span>(!tr[p].ri) tr[p].ri=++cnt;</span><br><span class="line">    tr[tr[p].le].w+=k,tr[tr[p].ri].w+=k;</span><br><span class="line">    tr[tr[p].le].tag+=k,tr[tr[p].ri].tag+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;<span class="comment">//没点开点 </span></span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p].w+=k,tr[p].tag+=k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag) push_down(p,tr[p].tag);tr[p].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) add(nl,nr,l,mid,tr[p].le,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) add(nl,nr,mid+<span class="number">1</span>,r,tr[p].ri,k);</span><br><span class="line">    tr[p].w=max(tr[tr[p].le].w,tr[tr[p].ri].w);</span><br><span class="line">&#125;<span class="comment">//与线段树相同 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">    scan(n);scan(w),scan(h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,v;i&lt;=n;i++)</span><br><span class="line">        scan(x),scan(y),scan(v),lim=max(x+w+<span class="number">1</span>,lim),<span class="comment">//lim是线段树范围 </span></span><br><span class="line">        a[(i&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>]=(node)&#123;x,y,y+h<span class="number">-1</span>,v,<span class="number">1</span>&#125;,<span class="comment">//强行转换格式，-1的细节** </span></span><br><span class="line">        a[i&lt;&lt;<span class="number">1</span>]=(node)&#123;x+w<span class="number">-1</span>,y,y+h<span class="number">-1</span>,v,<span class="number">-1</span>&#125;;<span class="comment">//细节** </span></span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+<span class="number">2</span>*n);<span class="comment">//细节** </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        add(a[i].l,a[i].r,<span class="number">1</span>,lim,root,a[i].w*a[i].d);</span><br><span class="line">        ans=max(ans,tr[root].w);<span class="comment">//直接用整棵树更新就好啦 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(t);</span><br><span class="line">    <span class="keyword">while</span>(t--) work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扫描线2种方法都已经讲完，可以再找一些题练习一下；</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>悬线法</title>
    <url>/2019/10/25/suspended-line/</url>
    <content><![CDATA[<p>例题 P1169 [ZJOI2007]棋盘制作</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8×88 \times 88×8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。</p><p>而我们的主人公<code>小Q</code>，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友<code>小W</code>决定将棋盘扩大以适应他们的新规则。</p><a id="more"></a>


<p><code>小Q</code>找到了一张由N×MN \times MN×M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。<code>小Q</code>想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。</p>
<p>不过<code>小Q</code>还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。</p>
<p>于是<code>小Q</code>找到了即将参加全国信息学竞赛的你，你能帮助他么？</p>
<h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p><strong>输入格式：</strong></p>
<p>包含两个整数NNN和MMM，分别表示矩形纸片的长和宽。接下来的NNN行包含一个N ×MN  \times MN ×M的010101矩阵，表示这张矩形纸片的颜色（000表示白色，111表示黑色）。</p>
<p><strong>输出格式：</strong></p>
<p>包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。</p>
<p>审题可以发现，我们所以寻找的最大矩形其实已经含有正方形，所以不需要单独去寻找，但是当时我只想到如何DP求正方形，所以分开写了；</p>
<p>这里就引进一个概念——<strong>悬线法</strong></p>
<h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a><strong>用途：</strong></h2><p>　　<strong>求满足条件的最大矩形或正方形</strong></p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a><strong>方法：</strong></h2><p>　　通过不断更新矩形左右端点所能到达的距离（1 ： 初始化；2：dp中更新）</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h2><p>　　left [ i ] [ j ] 数组更新包含第（i，j）点的最左能到达距离；</p>
<p>　　right [ i ] [ j ] 数组更新包含第（i，j）点的最右能到达距离；</p>
<p>　　up [ i ] [ j ] 数组更新包含第（i，j）点的向上能到达的距离；</p>
<p>　　PS：为什么没有下？因为down可以在dp中用up代替；</p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h2><p>　　1：初始化 left 和 right 数组</p>
<p>　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=m-1;j&gt;0;j--)&#123;</span><br><span class="line">            if(maps[i][j]!=maps[i][j+1])//判断条件 </span><br><span class="line">                right[i][j]=right[i][j+1];</span><br><span class="line">        &#125;//右端点从右往左更新 </span><br><span class="line">        for(int j=2;j&lt;=m;j++)&#123;</span><br><span class="line">            if(maps[i][j-1]!=maps[i][j])</span><br><span class="line">                left[i][j]=left[i][j-1];</span><br><span class="line">        &#125;//左端点从左往右更新 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　2：DP更新 up 数组和 left，right 数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;maps[i][j]!=maps[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">            left[i][j]=max(left[i][j],left[i<span class="number">-1</span>][j]);<span class="comment">//由上更新 </span></span><br><span class="line">            right[i][j]=min(right[i][j],right[i<span class="number">-1</span>][j]);</span><br><span class="line">            <span class="comment">//左取大，右取小 </span></span><br><span class="line">            up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=right[i][j]-left[i][j]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b=min(a,up[i][j]);</span><br><span class="line">        ans1=max(ans1,b*b);<span class="comment">//正方形做法2 </span></span><br><span class="line">        ans2=max(ans2,a*up[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　思考：该方法的正确性，因为每个点都取到了一次，每次选取最优解，则正解定会取到</p>
<p><strong>完整Code</strong>（附有正方形另类做法）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,maps[maxn][maxn],ans1;</span><br><span class="line"><span class="keyword">int</span> f1[maxn][maxn],ans2,up[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> left[maxn][maxn],right[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cube</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=maps[i][j];</span><br><span class="line">            <span class="keyword">if</span>(x==maps[i<span class="number">-1</span>][j]||x==maps[i][j<span class="number">-1</span>]||x!=maps[i][j])&#123;</span><br><span class="line">                f1[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                f1[i][j]=min(f1[i<span class="number">-1</span>][j],min(f1[i][j<span class="number">-1</span>],f1[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans1=max(f1[i][j],ans1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans1*=ans1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maps[i][j]);</span><br><span class="line">            left[i][j]=j,right[i][j]=j;</span><br><span class="line">            up[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cube();<span class="comment">//正方形的做法1 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[i][j]!=maps[i][j+<span class="number">1</span>])<span class="comment">//判断条件 </span></span><br><span class="line">                right[i][j]=right[i][j+<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="comment">//右端点从右往左更新 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[i][j<span class="number">-1</span>]!=maps[i][j])</span><br><span class="line">                left[i][j]=left[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="comment">//左端点从左往右更新 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;maps[i][j]!=maps[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                left[i][j]=max(left[i][j],left[i<span class="number">-1</span>][j]);<span class="comment">//由上更新 </span></span><br><span class="line">                right[i][j]=min(right[i][j],right[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="comment">//左取大，右取小 </span></span><br><span class="line">                up[i][j]=up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a=right[i][j]-left[i][j]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> b=min(a,up[i][j]);</span><br><span class="line">            ans1=max(ans1,b*b);<span class="comment">//正方形做法2 </span></span><br><span class="line">            ans2=max(ans2,a*up[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结与反思；正确灵活使用，可以快速解决问题；</p>
]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/2019/10/25/Heavy-light-Decomposition/</url>
    <content><![CDATA[<p>。。。。</p><p>有点懒；</p><p>需要先理解几个概念：</p><ol>
<li><p>LCA</p>
</li>
<li><p>线段树（熟练，要不代码能调一天）</p>
</li>
<li><p>图论的基本知识（dfs序的性质）</p>
</li>
</ol><p>这大概就好了；</p><p><strong>定义</strong>：</p><p>　　1.重儿子：一个点所连点树size最大的，这个son被称为这个点的重儿子；</p><p>　　2.轻儿子：一个点所连点除重儿子以外的都是轻儿子；</p><p>　　3.重链：从一个轻儿子或根节点开始沿重儿子走所成的链；</p><a id="more"></a>








<p><strong>步骤</strong>：</p>
<p>　　在代码里，结合代码更清晰。。。（其实是太懒了）</p>
<p>　有重点需要注意的东西在code中有提到，仔细看。。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,root,mod,a[maxn],head[maxn],fa[maxn],son[maxn],cnt,tag[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//a：原始点值，fa：父亲节点，son：重儿子，tag：懒标记 </span></span><br><span class="line"><span class="keyword">int</span> top[maxn],sz[maxn],id[maxn],dep[maxn],w[maxn],cent,tr[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//top：所在重链的头结点，sz：子树大小，id：dfs序，dep：深度 </span></span><br><span class="line"><span class="comment">//w：dfs序所对应的值（建线段树），tr：线段树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------------线段树红色预警 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[p]=tr[le(p)]+tr[re(p)];</span><br><span class="line">    tr[p]%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[p]=w[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p));</span><br><span class="line">    build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[le(p)]+=k*(mid-l+<span class="number">1</span>),tr[re(p)]+=k*(r-mid);</span><br><span class="line">    tr[le(p)]%=mod,tr[re(p)]%=mod;</span><br><span class="line">    tag[le(p)]+=k,tag[re(p)]+=k;</span><br><span class="line">    tag[le(p)]%=mod,tag[re(p)]%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p]+=k*(r-l+<span class="number">1</span>);tag[p]+=k;</span><br><span class="line">        tr[p]%=mod,tag[p]%=mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) r_add(nl,nr,l,mid,le(p),k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) r_add(nl,nr,mid+<span class="number">1</span>,r,re(p),k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">r_query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r) <span class="keyword">return</span> tr[p];</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=r_query(nl,nr,l,mid,le(p)),ans%=mod;</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=r_query(nl,nr,mid+<span class="number">1</span>,r,re(p)),ans%=mod;</span><br><span class="line">    push_up(p);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------线段树结束</span></span><br><span class="line"><span class="comment">//-----------------------------------------------------开始预处理 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;<span class="comment">//sz初始化 </span></span><br><span class="line">    <span class="keyword">int</span> max_part=<span class="number">-1</span>;<span class="comment">//max_part更新寻找重儿子 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x,dep[y]+=dep[x]+<span class="number">1</span>;<span class="comment">//更新子节点，准备开始继续dfs1 </span></span><br><span class="line">        dfs1(y);sz[x]+=sz[y];<span class="comment">//更新自身的sz数组 </span></span><br><span class="line">        <span class="keyword">if</span>(max_part&lt;sz[y]) son[x]=y,max_part=sz[y];<span class="comment">//更新重儿子 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*dfs1功能介绍</span></span><br><span class="line"><span class="comment">1.更新fa数组；</span></span><br><span class="line"><span class="comment">2.更新dep数组；</span></span><br><span class="line"><span class="comment">3.更新sz数组； </span></span><br><span class="line"><span class="comment">4.更新son数组； </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[x]=++cnt,w[cnt]=a[x],top[x]=t;<span class="comment">//更新dfs序，dfs序所对的值，重链头节点 </span></span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*dfs2功能介绍</span></span><br><span class="line"><span class="comment">1.更新id数组；</span></span><br><span class="line"><span class="comment">2.更新w数组；</span></span><br><span class="line"><span class="comment">3.更新top数组</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------预处理结束 </span></span><br><span class="line"><span class="comment">//------------------------------------------------开始主要操作 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实没有说的这么简单，这里重点是理解重链之间的跳跃方式，线段树的优化 </span></span><br><span class="line"><span class="comment">//一个性质：重链上的dfs序是连续的，dfs1在dfs2前的原因就在此 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">road_query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);<span class="comment">//从最下面往上跳 </span></span><br><span class="line">        ans+=r_query(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//更新重链 </span></span><br><span class="line">        ans%=mod;</span><br><span class="line">        x=fa[top[x]];<span class="comment">//跳到重链头的fa </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    ans+=r_query(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//已经在同一条重链上，直接加 </span></span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>)%mod;</span><br><span class="line">&#125;<span class="comment">//一个性质：在同一颗子树上的dfs序是连续的 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">road_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        r_add(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    r_add(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//类比 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//相同的性质 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------树链剖分 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m),scan(root),scan(mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        scan(u),scan(v),add(u,v),add(v,u);</span><br><span class="line">    dfs1(root),dfs2(root,root),build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> type,x,y,z;</span><br><span class="line">        scan(type);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>) scan(x),scan(y),scan(z),</span><br><span class="line">            road_add(x,y,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>) scan(x),scan(y),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,road_query(x,y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>) scan(x),scan(z),</span><br><span class="line">            tree_add(x,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">4</span>) scan(x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tree_query(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，可以开始调代码了</p>
<h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>　　树链剖分，作为一个优秀的暴力结构，以O（n logn logn）的时间复杂度完成路径查询，在子树查询做到了nlogn级别，所以不得不说其优秀；</p>
<p>　　但是，它的作用远不及此：</p>
<h3 id="1-LCA查询："><a href="#1-LCA查询：" class="headerlink" title="　　1.LCA查询："></a>　　1.LCA查询：</h3><p>　　　　与倍增相同，树链剖分可以用logn的时间复杂度完成LCA查询（跳跃性好像更优），而他的初始化是两遍dfs O（n），理论上更优。</p>
<p>　　　　可以猜测，LCA依旧运用重链跳法，然后比较即可，这里给出示范代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">&#125;<span class="comment">//只要看懂树链剖分的基本操作，这个很简单</span></span><br></pre></td></tr></table></figure>
<p>　　　　可以看到，其实代码很短。。。</p>
<h3 id="2-换根操作："><a href="#2-换根操作：" class="headerlink" title="　　2.换根操作："></a>　　2.换根操作：</h3><p>　　　　设现在的根是root，我们可以发现，换根对于路径上的操作并没有影响，但是子树操作就会影响了，所以我们分类讨论</p>
<p>　　　　　　设u为我们要查的子树的根节点</p>
<p>　　　　　　（1）如果root=u，那么子树即为整棵树；</p>
<p>　　　　　　（2）设 lca 为root和u的LCA，这里可以用上面所讲的树链剖分做，如果lca！=u，那么root并不是u的子节点，所以对于查询并不影响，常规操作即可</p>
<p>　　　　　　（3）如果lca=u，那么u节点的子树就是整颗树减去u-root这个路径上与u相挨的节点v的子树即可，这里给出logn求点v的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//前提条件：要求的节点相挨的节点u，必须是root的LCA </span><br><span class="line">int find(int x,int y)&#123;</span><br><span class="line">    while(top[x]!=top[y])&#123;</span><br><span class="line">        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);//从最下往上跳 </span><br><span class="line">        if(fa[top[x]]==y) return top[x];//如果y是x所在重链top的父亲节点，那么就可以返回了 </span><br><span class="line">        x=fa[top[x]];//跳 </span><br><span class="line">    &#125;</span><br><span class="line">    if(dep[x]&lt;dep[y]) swap(x,y);//让y最浅 </span><br><span class="line">    return son[y];// 因为在一条重链上，那么重儿子一定是路径上与要求节点相挨的 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　　　整个操作的代码层次感我写的还是比较清楚了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">            r_add(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,-k);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>)-r_query(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐评测网站<a href="https://loj.ac/problem/139" target="_blank" rel="noopener">LOJ </a>。。。（因为洛谷没有换根操作）</p>
<h3 id="AC代码附上"><a href="#AC代码附上" class="headerlink" title="AC代码附上"></a>AC代码附上</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ol putchar(<span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],cent,dep[maxn],son[maxn],fa[maxn],vis[maxn];</span><br><span class="line"><span class="keyword">int</span> top[maxn],a[maxn],id[maxn],w[maxn],sz[maxn],cnt,ij,root;</span><br><span class="line">ll tr[maxn&lt;&lt;<span class="number">3</span>],tag[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>) f=s==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>,s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+s-<span class="string">'0'</span>,s=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[p]=tr[le(p)]+tr[re(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[le(p)]+=<span class="number">1l</span>l*(mid-l+<span class="number">1</span>)*k,</span><br><span class="line">    tr[re(p)]+=<span class="number">1l</span>l*(r-mid)*k,</span><br><span class="line">    tag[le(p)]+=k,tag[re(p)]+=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[p]=w[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,le(p));</span><br><span class="line">    build(mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_add</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tr[p]+=<span class="number">1l</span>l*(r-l+<span class="number">1</span>)*k;</span><br><span class="line">        tag[p]+=<span class="number">1l</span>l*k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) r_add(nl,nr,l,mid,le(p),k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) r_add(nl,nr,mid+<span class="number">1</span>,r,re(p),k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">r_query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r) <span class="keyword">return</span> tr[p];</span><br><span class="line">    push_down(l,r,p,tag[p]),tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=r_query(nl,nr,l,mid,le(p));</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=r_query(nl,nr,mid+<span class="number">1</span>,r,re(p));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;<span class="keyword">int</span> max_part=<span class="number">-1</span>;vis[x]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">        dfs1(y);sz[x]+=sz[y];</span><br><span class="line">        <span class="keyword">if</span>(max_part&lt;sz[y]) son[x]=y,max_part=sz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    id[x]=++cnt;w[cnt]=a[x];top[x]=t;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==son[x]||fa[x]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">&#125;<span class="comment">//只要看懂树链剖分的基本操作，这个很简单 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前提条件：要求的节点相挨的节点u，必须是root的LCA </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);<span class="comment">//从最下往上跳 </span></span><br><span class="line">        <span class="keyword">if</span>(fa[top[x]]==y) <span class="keyword">return</span> top[x];<span class="comment">//如果y是x所在重链top的父亲节点，那么就可以返回了 </span></span><br><span class="line">        x=fa[top[x]];<span class="comment">//跳 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);<span class="comment">//让y最浅 </span></span><br><span class="line">    <span class="keyword">return</span> son[y];<span class="comment">// 因为在一条重链上，那么重儿子一定是路径上与要求节点相挨的 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) r_add(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,k);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            r_add(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">            r_add(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>,-k);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">tree_query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==x) <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 1 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=Lca(x,root);</span><br><span class="line">        <span class="keyword">if</span>(lca!=x) <span class="keyword">return</span> r_query(id[x],id[x]+sz[x]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);<span class="comment">//CASE 2 </span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dson=find(x,root);</span><br><span class="line">            <span class="keyword">return</span> r_query(<span class="number">1</span>,n,<span class="number">1</span>,n,<span class="number">1</span>)-r_query(id[dson],id[dson]+sz[dson]<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="comment">//CASE 3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">road_add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        r_add(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    r_add(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">road_query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        ans+=r_query(id[top[x]],id[x],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    ans+=r_query(id[x],id[y],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("co.out","w",stdout);</span></span><br><span class="line">    scan(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,v;i&lt;=n;i++) scan(v),add(i,v),add(v,i);</span><br><span class="line">    dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>),build(<span class="number">1</span>,n,<span class="number">1</span>);root=<span class="number">1</span>;</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> type,x,y,z;</span><br><span class="line">        scan(type),scan(x);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>) root=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>) scan(y),scan(z),road_add(x,y,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>) scan(z),tree_add(x,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">4</span>) scan(y),<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,road_query(x,y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,tree_query(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队--基于分块的优化</title>
    <url>/2019/10/25/mo-algorithm/</url>
    <content><![CDATA[<h1 id="莫队思想浅谈"><a href="#莫队思想浅谈" class="headerlink" title="莫队思想浅谈"></a>莫队思想浅谈</h1><p>莫队，基于分块思想。</p><p>所以说，在学习莫队时可以先了解一下分块的优化原理，这对于莫队的理解会有帮助；</p><p>我们将分层次讲解，难度不断增加，并附有例题。。。（由于博主太烂懒，所以莫队的模板概念知识只会在这里叙述）</p><h2 id="1-莫队："><a href="#1-莫队：" class="headerlink" title="1.莫队："></a><strong>1.莫队：</strong></h2><p>　　基础的莫队是用来解决区间离线查询问题，利用分块原理和排序，将查询时的重叠部分集中以来优化的算法，大多的算法的复杂度为$O(nsqrt(n))$，实际更优；</p><a id="more"></a>



<p>　　莫队代码一般很短，且有套路可言，所以应熟练掌握；</p>
<p>　　表述完毕，开始讲解：</p>
<p>　　<a href="https://www.luogu.org/problem/P1972" target="_blank" rel="noopener">P1972 [SDOI2009]HH的项链</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行：一个整数N，表示项链的长度。</p>
<p>第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。</p>
<p>第三行：一个整数M，表示HH 询问的个数。</p>
<p>接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>M 行，每行一个整数，依次表示询问对应的答案。</p>
<p>　　莫队的一道例题，但是这道题很恶心，数据专门卡了莫队，不过不用担心，我们可以吸口氧，再吸口臭氧，然后再有一些优化就可以A掉（如果实在过不了，后面附上了树状数组代码），然后让我们来讲解；</p>
<p>设第一个查询的区间为[ l1,r1 ] , 第二个查询的区间为[ l2,r2 ]；</p>
<p>既然已经说莫队时暴力结构，那么就能猜到它的统计方式是暴力统计；</p>
<p>引入两个指针 l ，r，首先让 l 移动，让l = l1，移动时进行增加或减去操作，像这道题，是颜色个数的减少或增加，那么暴力统计就可以不说了吧；</p>
<p>在移动到第二个区间时，用同样的操作移动；</p>
<p>但是这个不就是纯暴力了吗，不知道你是否有这样的疑问；</p>
<p>但是当我们将区间分块，再将区间按l，r所在块进行排序，那么每次移动的时间复杂度就变成了sqrt（n）（因为我们分成了sqrt（n）个块）；</p>
<p>这样就应该明白其原理，如果真的还是不懂了话，那么可以看看代码；</p>
<p><strong>Code（带有O2优化，O3优化和排序优化）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="comment">//luogu的O2，NOIP没有 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)<span class="comment">//O3优化，联赛时没有 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ri register int<span class="comment">//指针优化 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,be[maxn],a[maxn],unit,col[maxn*<span class="number">10</span>],ans,l=<span class="number">1</span>,r,prin[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r,id;&#125;q[maxn];<span class="comment">//query的结构体，便于排序 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]^be[b.l]?be[a.l]&lt;be[b.l]:(be[a.l]&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r;</span><br><span class="line">&#125;<span class="comment">//排序小优化 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;col[x]+=d;<span class="keyword">if</span>(d&gt;<span class="number">0</span>)ans+=(col[x]==<span class="number">1</span>);<span class="keyword">if</span>(d&lt;<span class="number">0</span>)ans-=(col[x]==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="comment">//d==1为增加，d==-1为减少 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);unit=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(a[i]),be[i]=i/unit+<span class="number">1</span>;<span class="comment">//分块 </span></span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        scan(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);<span class="comment">//排序 </span></span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(a[l],<span class="number">-1</span>),l++;<span class="comment">//减去l上这个数 </span></span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(a[l<span class="number">-1</span>],<span class="number">1</span>),l--;<span class="comment">//加上l-1上这个数 </span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(a[r+<span class="number">1</span>],<span class="number">1</span>),r++; </span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(a[r],<span class="number">-1</span>),r--;</span><br><span class="line">        prin[q[i].id]=ans;<span class="comment">//记录答案 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(Ri i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        print(prin[i]),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码至少过了这道题，但是仍然很悬，所以尽可能地优化常数</p>
<p>附上树状数组代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[maxn&lt;&lt;<span class="number">2</span>],a[maxn],cent,col[maxn*<span class="number">10</span>],pre[maxn*<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span><span class="keyword">int</span> l,r,id,ans;&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;<span class="keyword">return</span> a.r==b.r?a.l&lt;b.l:a.r&lt;b.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(query a,query b)</span></span>&#123;<span class="keyword">return</span> a.id&lt;b.id;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x)) tree[x]+=d;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> ans=<span class="number">0</span>;<span class="keyword">while</span>(x) ans+=tree[x],x-=lowbit(x);<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(a[i]);</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        scan(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cent&lt;q[i].r)&#123;</span><br><span class="line">            add(++cent,<span class="number">1</span>);</span><br><span class="line">            col[a[cent]]++;</span><br><span class="line">            <span class="keyword">if</span>(col[a[cent]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                add(pre[a[cent]],<span class="number">-1</span>);</span><br><span class="line">                pre[a[cent]]=cent;</span><br><span class="line">                col[a[cent]]--;</span><br><span class="line">            &#125;<span class="keyword">else</span> pre[a[cent]]=cent;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].ans=ask(q[i].r)-ask(q[i].l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        print(q[i].ans),<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样应该可以去<a href="https://www.luogu.org/problem/SP3267" target="_blank" rel="noopener">水题</a>了，紫题，不用谢我；</p>
<h2 id="2-带修莫队："><a href="#2-带修莫队：" class="headerlink" title="2.带修莫队："></a><strong>2.带修莫队：</strong></h2><p>例题：<a href="https://www.luogu.org/problem/P1903" target="_blank" rel="noopener">P1903 [国家集训队]数颜色 / 维护队列</a></p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令：</p>
<p>1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p>
<p>2、 R P Col 把第P支画笔替换为颜色Col。</p>
<p>为了满足墨墨的要求，你知道你需要干什么了吗？</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。</p>
<p>第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。</p>
<p>第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。</p>
<p>　　带修莫队其实没什么，只要查询是离线就别虚，只要加入一个时间指针t即可。</p>
<p>　　但是如果只是单纯的分块了话，可能时间会超，我们看一下分块块数unit，</p>
<p>　　当同l块时，移动需要n<em>unit，当l块之间r携带移动时需要(n^2)/unit，当时间 t 移动时仍然有 l 和 r 块的移动，所以需要 (n^2</em>t)/(unit^2)</p>
<p>　　时间复杂度时三个移动取最大值（因为省略常数），发现如果unit取sqrt（n）时，最坏时间复杂度为n^2，这不是我们所期望的，</p>
<p>　　将t看似为n那么整理第三个为(n^3)/(unit^2)，那么让两两相等，三种情况取最优，发现当unit=n^(2/3)时，时间复杂度最优，为O(n^(5/3))；</p>
<p>　　那么就可以看代码了。。。</p>
<p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ri register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,col[maxn*<span class="number">100</span>],s[maxn],unit,be[maxn],T,l=<span class="number">1</span>,r;</span><br><span class="line"><span class="keyword">int</span> cent,t,ans[maxn],Ans,now[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,Time,id;</span><br><span class="line">&#125;q[maxn];<span class="comment">//查询数组 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">change</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> exfo,New,Old;</span><br><span class="line">&#125;c[maxn];<span class="comment">//change数组 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(be[a.l]!=be[b.l]) <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(be[a.r]!=be[b.r]) <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">    <span class="keyword">return</span> a.Time&lt;b.Time;</span><br><span class="line">&#125;<span class="comment">//不同的排序方式 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;col[x]+=d;<span class="keyword">if</span>(d&gt;<span class="number">0</span>)Ans+=(col[x]==<span class="number">1</span>);<span class="keyword">if</span>(d&lt;<span class="number">0</span>)Ans-=(col[x]==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spe</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;<span class="keyword">if</span>(l&lt;=x&amp;&amp;x&lt;=r) syst(d,<span class="number">1</span>),syst(s[x],<span class="number">-1</span>);s[x]=d;&#125;<span class="comment">//t指针移动方式 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m);unit=<span class="built_in">pow</span>(n,<span class="number">0.666666</span>);<span class="comment">//2/3=0.6666666，6越多越精确 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(s[i]),now[i]=s[i],be[i]=i/unit+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c %d%d"</span>,&amp;type,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="string">'Q'</span>) q[++cent]=(query)&#123;x,y,t,cent&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">'R'</span>) c[++t]=(change)&#123;x,y,now[x]&#125;,now[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+cent,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)&#123;    </span><br><span class="line">        <span class="keyword">while</span>(T&lt;q[i].Time) spe(c[T+<span class="number">1</span>].exfo,c[T+<span class="number">1</span>].New),T++;</span><br><span class="line">        <span class="keyword">while</span>(T&gt;q[i].Time) spe(c[T].exfo,c[T].Old),T--;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(s[l],<span class="number">-1</span>),l++;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(s[l<span class="number">-1</span>],<span class="number">1</span>),l--;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(s[r+<span class="number">1</span>],<span class="number">1</span>),r++;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(s[r],<span class="number">-1</span>),r--;</span><br><span class="line">        ans[q[i].id]=Ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cent;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-树上莫队："><a href="#3-树上莫队：" class="headerlink" title="3.树上莫队："></a><strong>3.树上莫队：</strong></h2><p>要说树上操作，那么莫队可以操作的有两种类型，第一种是子树统计，第二种是路径统计，那么让我们详细来看；</p>
<p>警告：前方有dfs序和euler序出现；</p>
<h3 id="1-子树统计"><a href="#1-子树统计" class="headerlink" title="1.子树统计"></a><strong>1.子树统计</strong></h3><p>　　这个如果只是一颗子树单纯的统计非常简单，只要一次dfs求出dfs序和子树size即可，你会发现子树上的dfs序时连续的，直接查询一段区间即可；</p>
<p>　　<img src="/images/15.png" alt="alt"></p>
<p>　　有点丑，不要介意，它的dfs序是1 2 3 7 9 4 6 5 8</p>
<p>　　　　2的子树序列即为 2 3 7 9；</p>
<p>　　这个应该不需要再解释了吧。。。</p>
<p>　　但是在两颗子树上统计再加上换根操作是不是很毒瘤，我们在后面会讲到；</p>
<h3 id="2-路径统计"><a href="#2-路径统计" class="headerlink" title="2.路径统计"></a>2.路径统计</h3><p>　　莫队只能维护序列，所以我们将子树转化为dfs序，将其从树中拿出，维护其序列，那么路径上怎么办呢</p>
<p>　　　　我们再拿出这个图（我知道很丑！）</p>
<p>　　　　<img src="/images/16.png" alt="alt"></p>
<p>　　　　不知道euler序？没关系，我解释就行了，euler序将一个数记录两遍，进的时候记录一遍，出的时候记录一遍；</p>
<p>　　　　我们将序列列出来就很清晰了 ： 1 2 3 7 7 9 9 3 4 4 2 6 5 5 8 8 6 1;</p>
<p>　　　　 那么每个数字都出现了两遍，我们设节点 i 在euler序中第一次出现的位置为first [ i ] ，第二次出现的位置为last [ i ] 。</p>
<p>　　　　观察路径2-&gt;9，你会发现路径上first [ 2 ] -&gt; fisrt [ 9 ]：2 3 7 7 9，其中路径上的点都只出现了一次，出现两次的都不在路径上，证明也很简单，这里就不再赘述。</p>
<p>　　　　当然last [ 2 ] -&gt; last [ 9 ]是一样的，只是顺序不一样。</p>
<p>　　　　但是这个只是一种情况——当两个点中有一个点是另一个点子树的一部分，或者问题转换一下一个点是另一个点的LCA，如刚刚的2是9的LCA。</p>
<p>　　　　但是当不在同一颗子树上会发生什么？</p>
<p>　　　　例如3 -&gt; 6：3 7 7 9 9 3 4 4 2 6 5 5 8 8 6，这是3和6出现两次时序列，我们已经发现没有1这个点，我们选取last [ 3 ] -&gt; first [ 6 ]  : 3 4 4 2 6，其中路径上的点3 2 6都出现</p>
<p>　　　　但是1却没有出现，我们可以发现1时LCA（3，6），所以euler序中在这种情况下是没有LCA的，那么我们在统计答案时将其加上，然后再减去。</p>
<p>　　　　两种情况都已经讨论完毕，我们只要在存q数组时做个lca的标记即可。</p>
<p>　　　　这里给出一道　　<strong>例题</strong>　　</p>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个n个节点的树，每个节点表示一个整数，问u到v的路径上有多少个不同的整数。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有两个整数n和m（n＝40000，m＝100000）。</p>
<p>第二行有n个整数。第i个整数表示第i个节点表示的整数。</p>
<p>在接下来的n-1行中，每行包含两个整数u v，描述一条边（u，v）。</p>
<p>在接下来的m行中，每一行包含两个整数u v，询问u到v的路径上有多少个不同的整数。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个询问，输出结果。</p>
<p> 　　　　</p>
<p>　　　　这是模板测试，只需要分类讨论，直接套莫队；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 40007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ls[maxn],euler[maxn&lt;&lt;<span class="number">1</span>],ans[N],cent,cnt,dep[maxn&lt;&lt;<span class="number">1</span>],num[maxn&lt;&lt;<span class="number">1</span>],l=<span class="number">1</span>,r,now;</span><br><span class="line"><span class="keyword">int</span> first[maxn&lt;&lt;<span class="number">1</span>],last[maxn&lt;&lt;<span class="number">1</span>],b[maxn],fa[maxn&lt;&lt;<span class="number">1</span>][<span class="number">30</span>],be[maxn&lt;&lt;<span class="number">1</span>],vis[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn&lt;&lt;<span class="number">1</span>],unit,col[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,id,lca;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    euler[++cnt]=x;first[x]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][<span class="number">0</span>]==y) <span class="keyword">continue</span>;</span><br><span class="line">        dep[y]+=dep[x]+<span class="number">1</span>;fa[y][<span class="number">0</span>]=x;</span><br><span class="line">        dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">    euler[++cnt]=x;last[x]=cnt;</span><br><span class="line">&#125;<span class="comment">//在完成LCA初始化的同时完成euler序的记录 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">1</span>,fa[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">-1</span>;dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[k][i<span class="number">-1</span>]&lt;<span class="number">0</span>) fa[k][i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> fa[k][i]=fa[fa[k][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,d=dep[x]-dep[y];d;d&gt;&gt;=<span class="number">1</span>,i++)</span><br><span class="line">        <span class="keyword">if</span>(d&amp;<span class="number">1</span>) x=fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">25</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">            y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是倍增求LCA，当然也可以2遍dfs+树剖 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]^be[b.l]?be[a.l]&lt;be[b.l]:(be[a.l]&amp;<span class="number">1</span>?a.r&lt;b.r:a.r&gt;b.r); </span><br><span class="line">&#125;<span class="comment">//排序小优化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">syst</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] ? now -= (!--num[ls[x]]):now += !num[ls[x]]++;</span><br><span class="line">    <span class="comment">//CASE 1 ：前者减去，而！是为了判断是否应该减取（true=1，false=0） </span></span><br><span class="line">    <span class="comment">//CASE 2 ：后者加上，！同上面所说 </span></span><br><span class="line">    vis[x] ^= <span class="number">1</span>;<span class="comment">//异或操作可以方便的转换出现次数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);unit=<span class="built_in">sqrt</span>(<span class="number">2</span>*n);<span class="comment">//记住euler序是2*n </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ls[i]),b[i]=ls[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> tot=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ls[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+tot,ls[i])-b;</span><br><span class="line">    <span class="comment">//由于数值太大，我们进行离散化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b),add(a,b);</span><br><span class="line">    init();<span class="comment">//初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) be[i]=i/unit+<span class="number">1</span>;<span class="comment">//分块 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,L,R;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;L,&amp;R);</span><br><span class="line">        <span class="keyword">int</span> lca=getlca(L,R);q[i].id=i;</span><br><span class="line">        <span class="keyword">if</span>(first[L]&gt;first[R]) swap(L,R);<span class="comment">//小的在前面哦 </span></span><br><span class="line">        <span class="keyword">if</span>(lca==L)&#123;<span class="comment">//CASE 1 ： </span></span><br><span class="line">            q[i].l=first[L];</span><br><span class="line">            q[i].r=first[R];</span><br><span class="line">            q[i].lca=<span class="number">0</span>;<span class="comment">//不需要考虑LCA </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//CASE 2 ： </span></span><br><span class="line">            q[i].l=last[L];</span><br><span class="line">            q[i].r=first[R];</span><br><span class="line">            q[i].lca=lca;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> lca=q[i].lca;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) syst(euler[l]),l++;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) syst(euler[l<span class="number">-1</span>]),l--;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) syst(euler[r+<span class="number">1</span>]),r++;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) syst(euler[r]),r--;</span><br><span class="line">        <span class="keyword">if</span>(lca) syst(lca);<span class="comment">//判断是否需要考虑LCA </span></span><br><span class="line">        ans[q[i].id]=now;</span><br><span class="line">        <span class="keyword">if</span>(lca) syst(lca);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您已经AC了这几道题，恭喜您已经大概掌握莫队的框架。（这几道题不是小意思嘛，博主太菜了）</p>
<p>由于博主太菜，还没有学回滚莫队，所以这里先不再说（逃ε=ε=ε=┏(゜ロ゜;)┛）</p>
<p>不过这里再留下一道模板题，<a href="https://www.luogu.org/problem/P4074" target="_blank" rel="noopener">糖果公园</a>——带修树上莫队，两种算法相结合，不要虚，虽然是黑题</p>
<p>这里不再附上代码，请原谅。。。</p>
<p><strong>拓展提升</strong></p>
<h2 id="4-双指针莫队"><a href="#4-双指针莫队" class="headerlink" title="4.双指针莫队"></a><strong>4.双指针莫队</strong></h2><p>　　其实这才是莫队的本质，虽然带修莫队是三指针，但是别忘了其时间复杂度还是很难让人接受的（尤其是常数巨大的博主），所以我们还是用双指针的比较多。</p>
<p>　　我们以上看到的莫队是一个区间的查询，一个指针维护l，一个指针维护r，然后再用分块排序；</p>
<p>　　但是当我们遇见了两个区间怎么办？比如说这道题<a href="https://www.luogu.org/problem/P5268" target="_blank" rel="noopener">P5268 [SNOI2017]一个简单的询问</a>，请读者不要被其吓住，这其实只有一个普通莫队的难度，只是需要从原来的思维跳出来</p>
<p>　　真正理解莫队双指针的作用。</p>
<p> <img src="/images/17.png" alt="alt"></p>
<p>　　设该函数为f( l1 , r1 , l2 , r2)，那么可以拆成f（ 1  , l1-1 , 1 , l2-1 ) + f ( 1 , r1, 1 , r2 ) - f (1 , l1-1 , 1 , r2) - f ( 1 , l2 - 1 , 1 , r2 )；</p>
<p>　　这里用到了容斥原理，将区间容斥，那么我们就可以引用莫队，维护两个变量，双指针移动，分块排序（博主太唠叨了）</p>
<p>　　这里附上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],be[maxn],unit,ans[maxn],ol,all;</span><br><span class="line"><span class="keyword">int</span> t[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d,id;</span><br><span class="line">&#125;q[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l]==be[b.l]?a.r&lt;b.r:be[a.l]&lt;be[b.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    ol+=t[a[x]][type^<span class="number">1</span>];</span><br><span class="line">    t[a[x]][type]++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    ol-=t[a[x]][type^<span class="number">1</span>];</span><br><span class="line">    t[a[x]][type]--;</span><br><span class="line">&#125;<span class="comment">//简单的操作 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);unit=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]),be[i]=(i<span class="number">-1</span>)/unit+<span class="number">1</span>;</span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l1,r1,l2,r2;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(l1),scan(r1),scan(l2),scan(r2);</span><br><span class="line">        q[++all].l=r1,q[all].r=r2,q[all].d=<span class="number">1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l2<span class="number">-1</span>,q[all].r=r1,q[all].d=<span class="number">-1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l1<span class="number">-1</span>,q[all].r=r2,q[all].d=<span class="number">-1</span>,q[all].id=i;</span><br><span class="line">        q[++all].l=l1<span class="number">-1</span>,q[all].r=l2<span class="number">-1</span>,q[all].d=<span class="number">1</span>,q[all].id=i;</span><br><span class="line">    &#125;<span class="comment">//拆成四个询问 ，id一样 </span></span><br><span class="line">    sort(q+<span class="number">1</span>,q+<span class="number">1</span>+all,cmp);<span class="comment">//排序是一样的 </span></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) add(++l,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) del(l--,<span class="number">0</span>);<span class="comment">//两个指针要分开标记用1和0即可（可以异或） </span></span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) add(++r,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) del(r--,<span class="number">1</span>);</span><br><span class="line">        ans[q[i].id]+=ol*q[i].d;<span class="comment">// 4个询问最后会累加在一起 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Guass初步</title>
    <url>/2019/10/25/Guass/</url>
    <content><![CDATA[<p>Gauss算法，称为高斯消元算法，用来解决n元一次方程，在解决线性方程问题起着重要作用。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h2><p>　　运用高斯消元的方法，我们可以在O(n3)的时间求出n元线性方程，但是由于时间复杂度的原因，请注意题目数据范围的提示。</p><p>　　<strong>高斯消元三大定理（在小学就学过了吧）：</strong></p><p>　　　　1.两个方程互换位置，解不变；</p><p>　　　　2.一个方程进行加减乘除，解不变；</p><a id="more"></a>




<p>　　　　3.一个方程乘上数k加上另一个方程，解不变；</p>
<p>　　这便是我们解决的基础；</p>
<h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a><strong>过程：</strong></h2><p>　　这里给出<a href="https://www.luogu.org/problem/P3389" target="_blank" rel="noopener">luogu例题链接</a>，这样方便寻找；</p>
<p>　　我们这里不用luogu的样例示范（因为不是整数好麻烦），这里给出方程</p>
<p>　　2 x + 3 y - z = 21;</p>
<p>　　x + 2 y + 2 z = 7;</p>
<p>　  3 x + y + 5 z = 8;　</p>
<p>　　我们将系数提出，然后就可以得到一个3 * 3的矩阵，之后将每个方程等号右边放到矩阵的最右边，就得到了：</p>
<p>　　<img src="/images/18.png" alt="alt"></p>
<p>　　这里每个方程的结果与系数我用黑线隔开了，想必也更清楚；</p>
<p>　　有了定理，我们理一下目标：</p>
<p>　　我们如果将每一个方程只留下一个未知数的系数，那么最后就可以求解了，如：</p>
<p>　　<img src="/images/19.png" alt="alt"></p>
<p>　　当然系数不一定只会是1，但是只要除一下就好，根据这个定义，我们将第 i 个未知数的前系数非零而且其他系数都为零，这个系数在矩阵的位置为 i ，i；</p>
<p>　　这样的矩阵称为“简化阶梯矩阵”；</p>
<p>　　我们只要将每个矩阵化成简化阶梯矩阵即可；</p>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a><strong>步骤：</strong></h2><p>　　1.枚举第 i 个未知数（外循坏）；</p>
<p>　　2.决定在哪一行求解这个未知数：</p>
<p>　　　　这里采用先对每一行 j 第 i 个系数找到最大值，有最大值的这一行定义为第ms行（名字随便起的，没有其他意思），然后将第ms行交换至第 i 行</p>
<p>　　3.判断第i行第i个数的值是否为0，这里由于数学期望和精度问题，我们将这个判断改为这个数的值是否小于我们定义的那个精度，如果小于（那就相当于为0了），</p>
<p>　　　　那么无解（因为这个项的系数是所有中最大的，所以其他的也都为0，一定无解）；</p>
<p>　　4.然后进行消元，就是将其他方程这个项的系数归0，这里有精度问题，但是从期望来讲，是不成问题的；</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a><strong>Code：</strong></h2><p>　　（我才不会说其实我有模拟操作但是太麻烦不想写了。。。）</p>
<p>　　不过我很良心，所以我有输出模拟，运行一下我的代码就行了；</p>
<p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> db cmp=<span class="number">1e-8</span>;</span><br><span class="line">db a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟啦 biu~</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"work %d \n"</span>,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ms=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt;<span class="built_in">fabs</span>(a[ms][i]))</span><br><span class="line">                ms=j;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[ms][i])&lt;cmp)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            swap(a[i][j],a[ms][j]);</span><br><span class="line">        biu(<span class="number">2</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">            db rate=a[j][i]/a[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)</span><br><span class="line">                a[j][k]-=a[i][k]*rate;</span><br><span class="line">        &#125;</span><br><span class="line">        biu(<span class="number">4</span>);<span class="comment">//良心模拟。。。 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,a[i][n+<span class="number">1</span>]/a[i][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong>例题</strong></h2><p>　　<a href="https://www.luogu.org/problem/P4035" target="_blank" rel="noopener">P4035 [JSOI2008]球形空间产生器</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个球形空间产生器能够在 nnn 维空间中产生一个坚硬的球体。现在，你被困在了这个 nnn 维球体中，你只知道球面上 n+1n+1n+1 个点的坐标，你需要以最快的速度确定这个 nnn 维球体的球心坐标，以便于摧毁这个球形空间产生器。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数 nnn (1&lt;=N=10)(1&lt;=N=10)(1&lt;=N=10)。接下来的 n+1n+1n+1 行，每行有 nnn 个实数，表示球面上一点的 nnn 维坐标。每一个实数精确到小数点后 666 位，且其绝对值都不超过 200002000020000。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>有且只有一行，依次给出球心的 nnn 维坐标（ nnn 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 333 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。</p>
<p>　　这个只要构造出矩阵即可；</p>
<p>　　可惜我不会在博客上用数学公式。。。</p>
<p>　　所以就随便写写了；</p>
<p>　　设xi为第i维的坐标；</p>
<p>　　sum(j=1,n) { (a[ i , j ] - x [ j ]) }=r^2;</p>
<p>　　这样的方程共有11个，我们要将r消掉，所以将相邻的两个方程相减，得到11个方程，然后将多项式拆开，合并，移项得到；</p>
<p>　　sum(j=1,n){ 2<em>(a[ i , j ] - a[ i + 1 , j ) </em> x [ j ] } = sum(j=1,n){ a[ i , j ] - a[ i + 1 , j ] };</p>
<p>　　这样就可以将左边的作为方程左边，右边作为结果，列出矩阵，这里还不需要检验，直接上代码。。。</p>
<p>　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">db a[<span class="number">17</span>][<span class="number">17</span>],c[<span class="number">17</span>][<span class="number">17</span>];</span><br><span class="line"><span class="keyword">const</span> db cmp=<span class="number">1e-8</span>;</span><br><span class="line"><span class="function">db <span class="title">calc</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            c[i<span class="number">-1</span>][j]=<span class="number">2</span>*(a[i<span class="number">-1</span>][j]-a[i][j]);</span><br><span class="line">            c[i<span class="number">-1</span>][n+<span class="number">1</span>]+=calc(a[i<span class="number">-1</span>][j])-calc(a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ms=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(c[j][i])&gt;<span class="built_in">fabs</span>(c[ms][i])) ms=j;</span><br><span class="line">        <span class="keyword">if</span>(ms!=i) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">            swap(c[i][j],c[ms][j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            db rate=c[j][i]/c[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=n+<span class="number">1</span>;k++)</span><br><span class="line">                c[j][k]-=c[i][k]*rate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%.3f "</span>,c[i][n+<span class="number">1</span>]/c[i][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有一些拓展内容，到时候再补充。。。</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>manacher</title>
    <url>/2019/10/25/manacher/</url>
    <content><![CDATA[<p>manacher算法的由来不再赘述，自行百度QWQ。。。</p><p>进入正题，manacher算法是一个高效的计算回文串的算法，回文串如果不知道可以给出一个例子：“ noon ”，这样应该就很清晰了；</p><p>其实这个算法虽然名字长，但是实际代码很短，而且理解起来并不难。。。（连我这种蒟蒻都懂了）</p><p>这里给出<a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">模板题</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.</p><a id="more"></a>




<p>字符串长度为n</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一行小写英文字符a,b,c…y,z组成的字符串S</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数表示答案</p>
<p>　　其中n的范围为11000000，很显然，只能是$O(n)$的复杂度，但是为何复杂度这么优秀，这里在讲完算法之后会简述。</p>
<p><strong>定理：</strong></p>
<ul>
<li>　　一个回文串只有一个对称中心，这个中心上可能有字母或者没有（如果没有字母，我们可以再加上一个，再后面会解释），我们暂且定义其为mid；</li>
<li>　　mid两端的区间对称，两边全等（回文串的定义）；</li>
<li>　　如果一个大的回文串一端的区间中有回文串，我们先定义它的中心为 i ，那么大回文串的另一端一定会有相同的回文串；</li>
<li>　　根据上一条，如果我们要更新在右端区间的回文串，那么在左边的回文串半径就可以更新右边的，但是有大回文串的区间限制，所以应当两者取min；</li>
<li>　　结束上面定理的继承之后，直接暴力枚举检查是否两端更新。</li>
</ul>
<p><strong>解释：</strong></p>
<p>　　上面的原理毕竟太过干，只是纯理论，所以制图说明；</p>
<p>　　<img src="/images/14.png" alt="alt"></p>
<p>　　比如说这个区间是一个大回文串，我们我们用r保留其有边界，那么l就可以根据中点坐标公式变形得到mid*2 - r，所以我们只保留右边界 r 即可。</p>
<p>　　那么可以看见，如果我们以 i 为这段区间中一个回文串的中心，那么，与它对称的回文串中心就可以求出（根据中点公式，得2*mid - i ，与上面相同）；</p>
<p>　　那么我们就可以根据定理来继承左边回文串的半径，但是如果左边这个回文串有超过区间的部分怎么办？</p>
<p>　　这里就用到我们所说的取min了，将左边回文串半径和r - i相比取min，这里就得到了 i 的一个半径，但这个半径一定小于或等于真实半径，所以还需暴力枚举；</p>
<p>　　这里就可见manachar算法的核心操作了，就是枚举回文串中心，然后继承半径以来减少枚举的次数；</p>
<p>　　我们用p[ i ]表示以点 i 为中心的回文串的半径，r记录回文串到达的最右边的坐标，mid随之更新，记录这个回文串的中心；</p>
<p><strong>Code</strong></p>
<p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 22000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> dat[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn],r,cnt=<span class="number">1</span>,mid,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s=getchar();</span><br><span class="line">    dat[<span class="number">0</span>]=<span class="string">'~'</span>;<span class="comment">//为了不超出边界的小操作 </span></span><br><span class="line">    dat[<span class="number">1</span>]=<span class="string">'|'</span>;<span class="comment">//这个间隔解决了对称中心没有字母的情况 </span></span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'a'</span>&amp;&amp;s&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">        dat[++cnt]=s;</span><br><span class="line">        dat[++cnt]=<span class="string">'|'</span>;</span><br><span class="line">        s=getchar();</span><br><span class="line">    &#125;<span class="comment">//其实与读入优化没差啦 </span></span><br><span class="line">&#125;<span class="comment">//自定义读入 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;i) p[i]=min(p[<span class="number">2</span>*mid-i],r-i);<span class="comment">//由对称的回文串继承，用r-i限制 </span></span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">1</span>;<span class="comment">//CASE ：无法继承 </span></span><br><span class="line">        <span class="keyword">while</span>(dat[i-p[i]]==dat[i+p[i]]) p[i]++;<span class="comment">//暴力更新 </span></span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;r) r=p[i]+i,mid=i;<span class="comment">// r边界必须是最右 </span></span><br><span class="line">        ans=max(ans,p[i]);<span class="comment">//更新答案 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans<span class="number">-1</span>);<span class="comment">//这个减一可以自己模拟一下，数学推了话好麻烦的说 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是manachar算法的简述了，当然这里解释一下为什么复杂度为O（n）：</p>
<p>　　我感觉这和KMP复杂度有些类似，因为这里因为继承的缘故，所以每个点更新次数较少，然后均摊到每个循环，那么复杂度就变成了$O(n)$了；</p>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2019/10/25/AC-automata/</url>
    <content><![CDATA[<p>先存代码</p><h2 id="AC自动机（简单版）"><a href="#AC自动机（简单版）" class="headerlink" title="AC自动机（简单版）"></a>AC自动机（简单版）</h2><p>　　</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> tr[maxn][<span class="number">28</span>],val[maxn],cnt,fail[maxn];</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;</span><br><span class="line">&#125;<span class="comment">//建树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);<span class="comment">//26个字母跑 </span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]);<span class="comment">//调取指针 </span></span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];<span class="comment">//建立“虚边”——指向失配指针的i边</span></span><br><span class="line">            <span class="comment">//这里已经改变了trie图 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ol=<span class="number">0</span>,u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)&#123;</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=u;j&amp;&amp;val[j]!=<span class="number">-1</span>;j=fail[j])</span><br><span class="line">            ol+=val[j],val[j]=<span class="number">-1</span>;<span class="comment">//fail跳（这样其实很慢） </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("co.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod),build(mod);</span><br><span class="line">    AC();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);ans=query(tx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="AC自动机（加强版）"><a href="#AC自动机（加强版）" class="headerlink" title="AC自动机（加强版）"></a>AC自动机（加强版）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T,n,ans;</span><br><span class="line"><span class="keyword">char</span> mod[maxn][<span class="number">100</span>],tx[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC&#123;</span><br><span class="line">    <span class="keyword">int</span> tr[maxn][<span class="number">27</span>],fail[maxn],tot;</span><br><span class="line">    <span class="keyword">int</span> cnt,val[maxn],num[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span>(tr));</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(fail,<span class="number">0</span>,<span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line">        cnt=ans=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tr[now][s[i]-<span class="string">'a'</span>]) tr[now][s[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">            now=tr[now][s[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[now]=id;<span class="comment">//记录id，这个不怕覆盖 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">                <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),<span class="built_in">cerr</span>&lt;&lt;fail[tr[u][i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)&#123;</span><br><span class="line">            u=tr[u][t[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=u;j;j=fail[j])</span><br><span class="line">                <span class="keyword">if</span>(val[j]) num[val[j]]++,ans=max(ans,num[val[j]]);</span><br><span class="line">        &#125;<span class="comment">//还是跳，不过记录的不一样而已 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(ans==num[i]) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,mod[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        AC::Init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod[i]),AC::insert(mod[i],i);</span><br><span class="line">        AC::build();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);</span><br><span class="line">        AC::query(tx);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机（二次加强版）"><a href="#AC自动机（二次加强版）" class="headerlink" title="AC自动机（二次加强版）"></a>AC自动机（二次加强版）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn];</span><br><span class="line"><span class="keyword">int</span> fail[maxn],tr[maxn][<span class="number">27</span>],val[maxn],num[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn],cnt,in[maxn],to[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;id[idx]=now;<span class="comment">//记录 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),in[fail[tr[u][i]]]++;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>],num[u]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v=fail[u];q.pop();</span><br><span class="line">        num[v]+=num[u];--in[v];</span><br><span class="line">        <span class="keyword">if</span>(!(in[v])) q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这里是跟题解学的topu,效率也挺高 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mod),insert(mod,i);</span><br><span class="line">    build();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,tx);query(tx);</span><br><span class="line">    topu(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num[id[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> mod[maxn],tx[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> fail[maxn],tr[maxn][<span class="number">28</span>],val[maxn],num[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn],cnt,in[maxn],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][a[i]-<span class="string">'a'</span>]) tr[now][a[i]-<span class="string">'a'</span>]=++cnt;</span><br><span class="line">        now=tr[now][a[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    val[now]++;id[idx]=now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i]) fail[tr[u][i]]=tr[fail[u]][i],q.push(tr[u][i]),in[fail[tr[u][i]]]++;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;t[i];i++)</span><br><span class="line">        u=tr[u][t[i]-<span class="string">'a'</span>],num[u]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(!in[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v=fail[u];q.pop();</span><br><span class="line">        num[v]+=num[u];--in[v];</span><br><span class="line">        <span class="keyword">if</span>(!(in[v])) q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1=<span class="built_in">strlen</span>(a),len2=<span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len1;i&lt;len1+len2;i++)</span><br><span class="line">        a[i]=b[i-len1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c),work(mod,c),</span><br><span class="line">        tot=<span class="built_in">strlen</span>(mod),insert(c,i),mod[tot++]=<span class="string">'&#123;'</span>;</span><br><span class="line">    build();</span><br><span class="line">    query(mod);topu();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num[id[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>math collect</title>
    <url>/2019/10/25/math-collect/</url>
    <content><![CDATA[<h2 id="EXGCD"><a href="#EXGCD" class="headerlink" title="EXGCD"></a>EXGCD</h2><p>　　我们在遇见不定方程的时候，总会一筹莫展，但是EXGCD为我们提供了方法，如同</p><p>　　$ a x + b y = c $   </p><p>　　那么我们先从这个这个式子出发：</p><p>　　$ax+by=gcd(a,b)$ 　　 $(1)$</p><p>　　我们不妨设出另一个式子</p><p>　　$ b x_{0}+(a \% b)y_{0}=gcd(b,a \% b)$ 　　 $(2)$</p><a id="more"></a>





<p>　　Because $gcd(a,b)= gcd ( b , a \% b ) $ ,thus:</p>
<p>　　(a x+b y=bx_{0}+a \% b y_{0})</p>
<p>　　(a x+b y=bx_{0} +(x-a/b \times y_{0}))</p>
<p>　　(a x+b y=ay_{0} +b(x-a/b \times y_{0}))</p>
<p>　　根据乘法等式，相对应系数的未知数相等，那么就可以得到：</p>
<p>　　$x=y_{0}　　y=x-a/b*y_{0}$　　</p>
<p> 　　那么在求gcd的过程中，我们可以在其中不断求解，但是递归到底时返回的x，y值是多少？</p>
<p>　　我们令在b=0时，带入（1）式，那么得到</p>
<p>　　$ax = a$,我们令x=1,y=0即可。</p>
<p>　　然后思考如何求解一开始的那个式子：</p>
<p>　　若有$ax+by=c$，则设$ax_{0}+by_{0}=c$,</p>
<p>　　两式相减：$a(x-x_{0})+b(y-y_{0})=0$</p>
<p>　　移项，除以gcd(a,b):$\frac{a}{gcd(a,b)}(x-x_{0})= - \frac{b}{gcd(a,b)}(y-y_{0})$</p>
<p>　　因为$gcd(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1$</p>
<p>　　所以$\frac{b}{gcd(a,b)}$可以整除$(x-x_{0})$</p>
<p>　　即 $\frac{b}{gcd(a,b)} \times t=(x-x_{0}), t \in Z$</p>
<p>　　对于任意x，都可以表示为</p>
<p>　　$x=x_{0}+\frac{b}{gcd(a,b)}$</p>
<p>　　那么根据exgcd求出的特解且$t \in Z$，我们可以这样求出最小解：</p>
<p>　　$x_{min}=x \%(\frac{b}{gcd(a,b)})$</p>
<p>　　在代码中的写法可以是</p>
<p>　　</p>
<p>　mod=b/gcd(a,b),ans=(x%mod+mod)%mod</p>
<p>　　那么这样我们就解决了$ax+by=gcd(a,b)$最小解问题。</p>
<p>　　如果是$ax+bx=c$，只需要两边乘上$\frac{c}{gcd(a,b)}$即可；</p>
<p> 　　这里附上 <a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">例题</a> </p>
<p>　　并给出模板Code：</p>
<p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,L,t1,t2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="comment">//更新特解 </span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> t=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=t-(a/b)*y;<span class="comment">//公式迭代 </span></span><br><span class="line">    <span class="keyword">return</span>  d;<span class="comment">//return gcd  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;t1,&amp;t2,&amp;n,&amp;m,&amp;L);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;n) swap(m,n),swap(t1,t2);<span class="comment">//由于exgcd函数默认a，b为正整数，所以要换一下 </span></span><br><span class="line">    <span class="keyword">int</span> gcd=exgcd(m-n,L,x,y);</span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;x*((t1-t2)/gcd)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">if</span>((t1-t2)%gcd!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>); <span class="comment">//根据推论，应当满足等式两端成立 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(<span class="number">1l</span>l*x*((t1-t2)/gcd)%(L/gcd)+L/gcd)%(L/gcd));<span class="comment">//正负处理 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><p>　　这里给出定理的内容，我大概描述一下：</p>
<p>　　对于$a,b$两个整数,且$gcd(a,b)=d$，那么对于任意的$x,y ,ax+by$是d的倍数。</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>euler</title>
    <url>/2019/10/25/euler/</url>
    <content><![CDATA[<h2 id="euler函数"><a href="#euler函数" class="headerlink" title="euler函数"></a>euler函数</h2><p>euler函数是表示从1~n中与n互质的个数，互质的定义简单提一下，$gcd(a,b)=1$。</p><p>那么如何求一个数的euler函数？</p><p>我们可以将每个数与n求gcd一下，如果gcd为1，则贡献加1，时间复杂度为 $O(n logn)$，极其优秀（雾）</p><p>那么来思考更加优秀的算法（为什么一定要求euler函数($\varphi(n)$函数)呢QAQ）</p><a id="more"></a>



<h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><p>在算法基本定理中，$N=p1^{c1}<em>p2^{c2}</em>p3^{c3}…$，其中pi为质因数，那么：</p>
<script type="math/tex; mode=display">
\varphi(N)=N*\frac{p1-1}{p1}*\frac{p2-1}{p2}...=\frac{pn-1}{pn}=N*\prod_{p|n} \frac{p-1}{p}</script><p>简单证明：</p>
<p>设p是N的质因子，那么显然p的倍数与N不互质，这些数分别是$p<em>1,p</em>2…p*N/p$，</p>
<p>显然有N/p个，那么我们可以减去这N/p个。设q是N的质因子，那么同理，q的倍数的个数有N/q个，那么在这N/p和N/q个当中有同时是p和q的倍数的，而我们多减了一次，我们容斥一下可以得到：</p>
<script type="math/tex; mode=display">
\varphi(N)=N-N/p-N/q+N/pq=N*(q-1)/q*(p-1)/p</script><p>那么推广到全部即可；</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们可以枚举其质因数，不用素数筛，当中我们可以直接用自然数筛，将N中所有的该数倍数筛掉，那么之后的合数必然是之前质因数的组合乘积，但是我们已经筛掉，所以不可能筛到合数，并且我们只用筛到$\sqrt{n}$即可，这个证明较简单，不再赘述。</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,lim,ans;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	lim=sqrt(n),ans=n;</span><br><span class="line">	for(int i=2;i&lt;=lim;i++)</span><br><span class="line">		if(!(n%i))&#123;</span><br><span class="line">			ans=ans/i*(i-1);</span><br><span class="line">			while(!(n%i)) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	if(n&gt;1) ans=ans/n*(n-1);//质因数大于sqrt(n) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote>
<p>1.如果n&gt;1，1~n中与n互质的数的和为$n*\varphi(n)/2$</p>
</blockquote>
<p>简单证明：</p>
<p>根据更相减损术可得，$gcd(a,b)=gcd(a,a-b)$，那么与n互质的数成对出现，则平均数为n/2，那么易得到结论；</p>
<p>2.如果a,b互质,$\varphi(ab)=\varphi(a)\varphi(b)$</p>
<p>简单证明：</p>
<p>根据euler函数的计算公式可得：</p>
<script type="math/tex; mode=display">
\varphi(ab)=ab*\prod_{p|ab}(p-1)/p=a*\prod_{p|a}(p-1)/p *b*\prod_{p|b}(p-1)/p=\varphi(a)*\varphi{b}</script><p>==定义：满足性质2的为积性函数==</p>
<p>3.如果$f(n)$为积性函数，$n=\prod_{i=1}^{m}p_{i}^{c_{i}}$，那么$f(n)=\prod_{i=1}^{m}f(pi^{c_{i}})$</p>
<p>简单证明：</p>
<p>类比积性函数的定义和定义式可以得到</p>
<p>4.设p为质数,p|n且$p^{2}|n$,那么$\varphi(n)=varphi(n/p)*p$</p>
<p>简单证明:</p>
<p>这个就很好证了,显然p和n/p的质因数相同,那么定义式中只有N是不同的,那么拆开再合并定义式就可以得到结论;</p>
<p>5.设p为质数,p|n但$p^{2}\not\mid n$,那么$\varphi(n)=\varphi(n/p)*(p-1)$</p>
<p>简单证明:</p>
<p>显然,p与n/p互质,那么根据积性函数$\varphi(n)=\varphi(n/p)*\varphi(p)$,当中$\varphi(p)=p-1$(因为p是质数),那么结论显然;</p>
<p>==以上性质4,5可以用来线性求euler函数,在后面会提到==</p>
<p>6.$\sum_{d|n}\varphi(d)=n$</p>
<p>证明忽略(雾</p>
<h3 id="euler函数的线性筛法"><a href="#euler函数的线性筛法" class="headerlink" title="euler函数的线性筛法"></a>euler函数的线性筛法</h3><p>如果要求1~n的euler函数,那么如何求解?</p>
<p>暴力解法,对每一个数进行求解,那么可以得到一个$O(n\sqrt{n})$的算法;</p>
<p>如何更优?</p>
<p>运用性质4,5即可,在素数筛的过程中进行性质4,5的判断,然后统计;</p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100008</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,prim[maxn],vis[maxn],euler[maxn],m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			vis[i]=i;prim[++m]=i;</span><br><span class="line">			euler[i]=i<span class="number">-1</span>;<span class="comment">//这个很好理解 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(prim[j]&gt;vis[i]||prim[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">			vis[prim[j]*i]=prim[j];</span><br><span class="line">			<span class="comment">//素数筛 </span></span><br><span class="line">			euler[prim[j]*i]=euler[prim[j]]*(i%prim[j]?(prim[j]<span class="number">-1</span>):(prim[j]));</span><br><span class="line">			<span class="comment">//性质4,5的判断 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><h5 id="简述"><a href="#简述" class="headerlink" title="简述:"></a>简述:</h5><script type="math/tex; mode=display">
gcd(a,b)=1,a^{\varphi(b)}\equiv1(\mod b)</script><p>证明略(不会(雾</p>
<h4 id="拓展欧拉定理"><a href="#拓展欧拉定理" class="headerlink" title="拓展欧拉定理"></a>拓展欧拉定理</h4><h5 id="简述-1"><a href="#简述-1" class="headerlink" title="简述;"></a>简述;</h5><p>$gcd(a,n)=1,则a^{b}\equiv a^{b\% \varphi(n)}(mod n)$    </p>
<p>简单证明:</p>
<p>设$b=p*\varphi(n)+r$,那么$r= b(mod \varphi(n))$,由欧拉定理可得:</p>
<script type="math/tex; mode=display">
a^{b}=a^{p*\varphi(n)+r}=(a^{\varphi(n)})^p*a^{r} \equiv 1^{p}*a^{r} \equiv a^{r} \equiv a^{b \%\ \varphi(n)}</script>]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>主席树初步</title>
    <url>/2019/10/25/Chairman-tree/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>　　1.线段树。。。</p><p>　　（好像没了</p><p>　　2.（可知可不知，可能会有帮助）动态开点线段树</p><h2 id="主席树-可持久化线段树"><a href="#主席树-可持久化线段树" class="headerlink" title="主席树(可持久化线段树)"></a>主席树(可持久化线段树)</h2><p>　　一看可持久化,我们总会想到一些恐怖的算法.但是其实理解并不难,而这里我只是将主席树的思想讲清楚(尽量),题还是自己刷(虽然我就没刷几道</p><p>　　先看一道 <a href="https://www.luogu.org/problem/P3834" target="_blank" rel="noopener">模板题</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如题，给定N个整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。</p><a id="more"></a>





<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个正整数N、M，分别表示序列的长度和查询的个数。</p>
<p>第二行包含N个整数，表示这个序列各项的数字。</p>
<p>接下来M行每行包含三个整数l,r,k l, r, kl,r,k , 表示查询区间[l,r][l, r][l,r]内的第k小值。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出包含k行，每行1个整数，依次表示每一次查询的结果</p>
<p>　　我们发现这道题很难处理,因为我们没有学过什么数据结构可以维护区间第k大;</p>
<p>　　那么如何处理这个数组是一个关键;</p>
<p>　　回顾一下,我们在求前缀和时,如何求一个区间的和?用一个前缀和去减另一个前缀和.</p>
<p>　　类比一下,我们是否可以用一个区间减去另一个区间得到第k大?</p>
<p>　　是可以的.这里引入平衡树中一个操作,<strong>平衡树左子树维护比这个节点值小的子树,右子树维护比这个节点值大的子树</strong>;</p>
<p>　　平衡树是如何操作的呢?</p>
<p>　　<strong>保存每个节点的子树大小,比较排名k与左子树的大小,排名k小于左子树大小,那么我们要找的点一定在左子树上,那么走左子树;</strong></p>
<p>　　<strong>如果排名比左子树大,那么将排名减去左子树大小和自身,走右子树</strong></p>
<p>　　<strong><img src="\images\6.png" alt="alt"></strong></p>
<p>　　注意,这个一定要看懂!</p>
<p>　　这个概念如果理解了话,那么就简单了.考虑线段树也是一颗二叉树,与平衡树一个性质,并且线段树本质维护的就是区间,那么我们考虑维护一个值域线段树.</p>
<p>　　那么就可以初略的定义,主席树是维护一颗值域线段树,将每一个位置作为一个时间点,继承前一个点,并添加自己的值.</p>
<p>　　如果要求区间 l 到 r 第k大,那么就可以用 r 时间点的线段树减去 l - 1 时间点的线段树,然后得到这个区间中某个值域中有多少个数,然后用上面所说类似于平衡树的做法,</p>
<p>　　(图我是真的画不出来了QAQ)</p>
<p>　　为了补偿,在代码中会有详细解释</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="　　Code"></a>　　Code</h3><p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 400007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,a[maxn],b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    node tr[maxn*<span class="number">20</span>];<span class="keyword">int</span> t[maxn&gt;&gt;<span class="number">1</span>]; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        rt=++tot;<span class="comment">//建一个点保存新的信息 </span></span><br><span class="line">        tr[rt]=tr[pre],tr[rt].sum++;</span><br><span class="line">        <span class="comment">//继承前面节点,并且添加自身 </span></span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="comment">//这里需要注意,l和r是表示值域 </span></span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=x) add(tr[rt].l,tr[pre].l,l,mid,x);</span><br><span class="line">        <span class="keyword">else</span> add(tr[rt].r,tr[pre].r,mid+<span class="number">1</span>,r,x);</span><br><span class="line">        <span class="comment">//这里就可以看出主席树的优越性,每一次建logn个点 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从此可以看出来,每次加的只有一条从根到叶子的新边(其他边是继承前面的 </span></span><br><span class="line">    <span class="comment">//因此空间复杂度nlogn,注意一下数组 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;<span class="comment">//返回位置 </span></span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x=tr[tr[v].l].sum-tr[tr[u].l].sum;</span><br><span class="line">        <span class="comment">//用时间靠后的减去时间靠前的,</span></span><br><span class="line">        <span class="comment">//得到区间信息 </span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;=x) <span class="keyword">return</span> query(tr[u].l,tr[v].l,l,mid,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(tr[u].r,tr[v].r,mid+<span class="number">1</span>,r,k-x);</span><br><span class="line">        <span class="comment">//类似于平衡树操作 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scan(a[i]),b[i]=a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">int</span> ol=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+ol,a[i])-b;</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        t.add(t.t[i],t.t[i<span class="number">-1</span>],<span class="number">1</span>,ol,a[i]);</span><br><span class="line">        <span class="comment">//注意建立新的节点时,要继承前一个时间段的 </span></span><br><span class="line">    &#125;<span class="comment">//不用建树,直接上 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r,k;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(l,r,k);</span><br><span class="line">        <span class="keyword">int</span> pos=t.query(t.t[l<span class="number">-1</span>],t.t[r],<span class="number">1</span>,ol,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结　　"></a>总结　　</h2><p>　　这样大概就讲完了思想,这里介绍一道 <a href="https://www.luogu.org/problem/P2633" target="_blank" rel="noopener">水题</a> ,不过对于加深主席树的思想有重大帮助(将主席树看成一颗前缀线段树)</p>
<p>　　我会附上我的代码(因为码风大家都不太相同,如果与我的码风相似了话,看起来就会很享受)</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="　　Code"></a>　　Code</h3><p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fa[maxn],head[maxn],son[maxn],sz[maxn],ol;</span><br><span class="line"><span class="keyword">int</span> T[maxn],tot,a[maxn],top[maxn],dep[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> lastans,cent;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ML</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tops,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Tops &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">    scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    ML tr[maxn*<span class="number">20</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;rt,<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        rt=++tot;</span><br><span class="line">        tr[rt]=tr[pre],tr[rt].sum++;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid) add(tr[rt].l,tr[pre].l,l,mid,x);</span><br><span class="line">        <span class="keyword">else</span> add(tr[rt].r,tr[pre].r,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> lca,<span class="keyword">int</span> flca,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x=tr[tr[u].l].sum+tr[tr[v].l].sum-tr[tr[lca].l].sum-tr[tr[flca].l].sum;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=x) <span class="keyword">return</span> query(tr[u].l,tr[v].l,tr[lca].l,tr[flca].l,l,mid,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(tr[u].r,tr[v].r,tr[lca].r,tr[flca].r,mid+<span class="number">1</span>,r,k-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;t.add(T[x],T[fa[x]],<span class="number">1</span>,ol,a[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">        dfs1(y);sz[x]+=sz[y];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]]&lt;sz[y]) son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[x]=tp;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[x],tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]),b[i]=a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    ol=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+ol,a[i])-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        scan(u,v),add(u,v);</span><br><span class="line">    dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,k;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(u,v,k);u^=lastans;</span><br><span class="line">        <span class="keyword">int</span> lca=get_lca(u,v);</span><br><span class="line">        <span class="keyword">int</span> pos=t.query(T[u],T[v],T[lca],T[fa[lca]],<span class="number">1</span>,ol,k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[pos]);lastans=b[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你看完了这篇博客并想骂博主讲的太简单,说明你已经超越博主了QAQ</p>
<p><strong>end</strong> </p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>dsu on tree</title>
    <url>/2019/10/25/dsu-on-tree/</url>
    <content><![CDATA[<p>这篇博客只是简单叙述思想(因为ML太弱了),具体例题请转其他博客.</p><hr><p>dsu on tree,许多OI将其归于启发式合并,当然如果你能理解更好,这只是一个理解方式罢了.</p><h2 id="思想简述"><a href="#思想简述" class="headerlink" title="思想简述"></a>思想简述</h2><p>　　顾名思义,这个算法是处理树上问题,将子树分开求解,如果暴力了话是枚举每个子树,然后dfs;</p><p>　　这里将每次dfs完的清空操作重新定义,并且规定dfs顺序,以来优化成log解法.</p><a id="more"></a>




<p>　　这里我们引入一个 <a href="https://www.luogu.org/problem/CF600E" target="_blank" rel="noopener">例题</a></p>
<blockquote>
<p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。</p>
</blockquote>
<p>　　仔细读题我们可以先想到暴力解法,分别从一个点进行dfs,肯定会爆;</p>
<p>　　那么我们思考一下,一颗子树上的点dfs结果是否可以被该子树根节点利用?</p>
<p>　　当然可以,但是我们只能保留一个点的结果,所以我们就面临一个选择,留哪一个?</p>
<p>　　我们想到树剖,那么我们保留重儿子就可以较好的保留信息,时间复杂度也会大幅降低.</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>　　1.dfs1找到重儿子和轻儿子;</p>
<p>　　2.dfs2递归处理每一个点,先扫描轻儿子,再扫描重儿子.</p>
<p>　　3.设计calc函数,用来处理轻重儿子,可以将add和del分开写,也可以合在一起;</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,head[maxn],a[maxn],sz[maxn],son[maxn],cent;</span><br><span class="line"><span class="keyword">int</span> fa[maxn],vis[maxn];</span><br><span class="line">ll col,max_part,num[maxn],ans[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dfs1(y);sz[x]+=sz[y];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]]&lt;sz[y]) son[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    num[a[x]]+=p;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;<span class="number">0</span>&amp;&amp;num[a[x]]==max_part) col+=a[x];</span><br><span class="line">    <span class="keyword">if</span>(p&gt;<span class="number">0</span>&amp;&amp;num[a[x]]&gt;max_part) col=a[x],max_part=num[a[x]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        calc(y,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) dfs2(son[x],<span class="number">1</span>),vis[son[x]]=<span class="number">1</span>;</span><br><span class="line">    calc(x,<span class="number">1</span>);ans[x]=col;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) vis[son[x]]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!id) calc(x,<span class="number">-1</span>),max_part=col=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">        scan(u),scan(v),add(u,v);</span><br><span class="line">    dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) print(ans[i]),<span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论入门</title>
    <url>/2019/10/25/Game-Theory/</url>
    <content><![CDATA[<p>说实话,我真的对这个游戏看得是一脸懵逼,因为(我太弱了)我没有明白一些变量的意思,所以一直很懵,现在才明白,这让我明白博弈论(还可以骗钱)博大精深;</p><p>以下是我自己思考的过程,也许不严谨,但是最终明白了.</p><p>这里只是粗略地介绍Nim游戏,一个入门博客,以来更好地进入SG函数(因为我才刚学</p><h2 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h2><p>　　背景故事我就不说了,直接介绍游戏规则.</p><a id="more"></a>



<p>　　有n堆物品,每堆有$a_{i}$个物品,两个玩家每次可以任选一堆挑出任意整数个物品(可以整堆取完),但不能不取,取走最后一个物品的为胜者.</p>
<p>　　这个游戏历史久远,曾用来赌钱,但是被一位数学家用二进制求解,得到了先手必胜和先手必败理论,于是这个游戏也就GG了;</p>
<h2 id="游戏套路"><a href="#游戏套路" class="headerlink" title="游戏套路"></a>游戏套路</h2><p>　　假如有3堆物品,它们的个数分别是6,4,2,那么两个玩家都选择最优策略,那么先手胜还是后手胜? <a href="https://www.luogu.org/problem/P2197" target="_blank" rel="noopener">(例题(竟然还蓝了))</a></p>
<p>　　答案是后手胜.(这个可以自己推一下)</p>
<p>　　这里引入一个概念:有向图游戏;</p>
<h3 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="　　有向图游戏"></a>　　有向图游戏</h3><p>　　　　我们定义一个游戏的初始状态为起点,向所能到达的所有状态连边,通过不断向下延展,得到必胜点(就是到这个点是胜利的情况)和必败点(这其实是我自己的理解)</p>
<p>　　考虑将${6,4,2}$这个集合作为起点,然后向所有状态连边;但是显然状态太多,我们无法完全枚举;</p>
<p>　　考虑终点,必然是${0,0,0}$,此时集合的异或和显然是0.</p>
<p>　　那么我们定义每一堆剩余的个数为$A_{i}$,我们通过推论可以得到:初始状态集合异或和为0时必败,反之必胜.</p>
<p>　　为什么会得到这个结论?</p>
<h2 id="游戏思考"><a href="#游戏思考" class="headerlink" title="游戏思考"></a>游戏思考</h2><p>　　考虑将开始时集合中的数换成二进制,即${110,100,010}$,最后状态也换成二进制,我就不再写出来了.</p>
<p>　　我们倒着推,最终解异或和为0,那么必然是从异或和非0的状态转移过来的.</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="　　证明"></a>　　证明</h3><p>　　　　如果$A_{1} Xor A_{2} Xor A_{3} …Xor A_{i}… Xor  A_{n}=0$,那么其中$A_{i}$是从$A_{i}^{‘}$转移过来的,假设$A_{1} Xor A_{2} Xor A_{3} …Xor A_{i}^{‘}… Xor  A_{n}=0$,</p>
<p>　　　　根据异或运算得到,$A_{i}=A_{i}^{‘}$,根据游戏规则,每个玩家必然至少要取1个物品,与规则矛盾,假设不成立,结论成立.</p>
<p>　　所以考虑采取这样一个策略,如果我们开始时异或和不为0,那么我们策略是轮到对手时,让他得到$A_{1} Xor A_{2} Xor A_{3} …Xor A_{i}… Xor  A_{n}=0$.</p>
<p>　　那么必败节点必定到对方手中,我们需要证明一下我们一定能实现这个策略</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="　　证明"></a>　　证明</h3><p>　　　　假设此时集合异或和为x,此时最大数为$A_{i}$,那么我们可以让$A_{i}$变成$A_{i} Xor x$,这样异或和就又为0了.</p>
<p>　　　　显然,$A_{i} &gt; A_{i} Xor x$,所以我们可以让$A_{i}$变成$A{i}Xor即可,那么一定可以实现这个策略.</p>
<p>　　但是如果我们开始时异或和为0,对方也可以反过来利用这个策略,让我们陷入必败场面.</p>
<p>　　结论再次强调一遍:初始状态集合异或和为0时必败,反之必胜.</p>
<p>　　(以上证明单纯自己类似口述,没有按照严格的证明格式,请多谅解)</p>
<h2 id="游戏反思"><a href="#游戏反思" class="headerlink" title="游戏反思"></a>游戏反思</h2><p>　　我们学习的是思维方式,而不单单是结论,所以我们反思一下我们做了什么</p>
<p>　　1.首先分析了模型,概括出每种情况的集合,构造了一个有向图游戏;</p>
<p>　　2.我们思考了每个点的转移方式.并分析了必败点的特点,发现一些特别的转移情况.</p>
<p>　　3.我们更加深入的思考了转移情景,并证明了策略的正确性.</p>
<p>　　4.算法实现(这里没有摆出);</p>
<p>　　根据这个思路,也许会对以后有帮助,SG函数和Mex运算将会在之后讲到(博主还在努力的学T_T)</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流初步</title>
    <url>/2019/10/25/Dinic-EK/</url>
    <content><![CDATA[<p>其实网络流很久之前已经学过,但是因为一些原因搁置了很久,于是想再系统地复习一下.</p><p>由于博主能力有限,所以关于网络流知识也是了解个大概,这里只是简单介绍,并且说一下博主的感性理解</p><hr><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="EK増广路算法"><a href="#EK増广路算法" class="headerlink" title="　　EK増广路算法"></a>　　EK増广路算法</h2><p>　　　　很容易理解的一个算法,也就是我们不断地bfs找出一条増广路然后更新剩余容量,直到更新完毕,类似于SPFA做法.时间复杂度$O(nm^{2})$;</p><a id="more"></a>



<p>　　　　这里不再附上代码,因为后面的费用流就要用EK+SPFA,而只是求最大流,推荐Dinic.</p>
<h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="　　Dinic算法"></a>　　Dinic算法</h2><p>　　　　与EK不同的是,Dinic算法增加了一些优化,这里引进了深度这个概念,通过在同一深度图中増广,一个点可以向多个点进行多流増广,并有减枝;</p>
<p>　　　　于是Dinic就可以达到$O(n^{2}m)$的优秀时间复杂度,可以代替匈牙利算法跑二分图匹配,时间复杂度$O(n\sqrt{n})$;</p>
<p>　　　　PS:关于二分图匹配时间复杂度可以这么想,由于一个点多流推进,同时増广多个点,而且深度小,所以时间复杂度就十分优秀;</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="　　　　Code:"></a>　　　　Code:</h3><p>　　　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10008</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],s,t,cent=<span class="number">1</span>,d[maxn],maxflow;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u,<span class="number">0</span>&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">    q.push(s),d[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].w&amp;&amp;!d[y])&#123;</span><br><span class="line">                q.push(y);d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(y==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rest=flow,k,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].w&amp;&amp;d[y=edge[i].to]==d[x]+<span class="number">1</span>)&#123;</span><br><span class="line">            k=Dinic(y,min(rest,edge[i].w));</span><br><span class="line">            edge[i].w-=k;</span><br><span class="line">            edge[i^<span class="number">1</span>].w+=k;</span><br><span class="line">            rest-=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,w;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        add(a,b,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())</span><br><span class="line">        <span class="keyword">while</span>(flow=Dinic(s,inf)) maxflow+=flow;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,maxflow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h1><p>　　费用流应该是我们见得最多的,而费用流跑二分图最大带权匹配极其优秀,费用流采用EK算法,不过每一次要跑一次SPFA,时间复杂度上升,如果要卡图了话,可能会崩;</p>
<p>　　但是由于图一般比较小,而且Dijkstra处理负权值问题有些复杂(要牵扯到势的辅助),所以还是普遍用SPFA求费用流;</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="　　Code"></a>　　Code</h2><p>　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2139062143</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,incf[N],head[N],cent=<span class="number">1</span>,dis[N];</span><br><span class="line"><span class="keyword">int</span> vis[N],maxflow,mincost,pre[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w,cost;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w,c&#125;;head[u]=cent;</span><br><span class="line">    edge[++cent]=(node)&#123;head[v],u,<span class="number">0</span>,-c&#125;;head[v]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre)); </span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    q.push(s);dis[s]=<span class="number">0</span>;vis[s]=<span class="number">1</span>;</span><br><span class="line">    incf[s]=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x],y;i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!edge[i].w) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[y=edge[i].to]&gt;dis[x]+edge[i].cost)&#123;</span><br><span class="line">                dis[y]=dis[x]+edge[i].cost;</span><br><span class="line">                incf[y]=min(incf[x],edge[i].w);</span><br><span class="line">                pre[y]=i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y]) q.push(y),vis[y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[t]==<span class="number">2139062143</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=t;</span><br><span class="line">    <span class="keyword">while</span>(x!=s)&#123;</span><br><span class="line">        <span class="keyword">int</span> i=pre[x];</span><br><span class="line">        edge[i].w-=incf[t];</span><br><span class="line">        edge[i^<span class="number">1</span>].w+=incf[t];</span><br><span class="line">        x=edge[i^<span class="number">1</span>].to;</span><br><span class="line">    &#125;</span><br><span class="line">    maxflow+=incf[t];</span><br><span class="line">    mincost+=dis[t]*incf[t];</span><br><span class="line"><span class="comment">//    cerr&lt;&lt;mincost&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c,d;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        add(a,b,c,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(spfa()) update();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,maxflow,mincost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>猫树</title>
    <url>/2019/10/25/cat-tree/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 　　猫树,由猫锟发明,以简单的构造以及优秀的离线复杂度而出名,可以优秀地处理区间和问题;</p><p> 　　前置知识:无;</p><h2 id="简单思想"><a href="#简单思想" class="headerlink" title="简单思想"></a>简单思想</h2><p> 　　运用分治的思想,分别处理中点两边的信息,之后分类讨论,合并区间得出结果;</p><p> 　　保存数据时运用完全二叉树的思想,逐层保存信息,有一定的层次性;</p><p> 　　<a href="https://www.luogu.org/problem/SP1043" target="_blank" rel="noopener">例题</a></p><p> 　　简单意思即求区间最大和;</p><a id="more"></a>





<p> 　　考虑上面所说的,处理中点两端的信息,即将区间的两个端点置于一个中点中间,而这个中点两边的信息我们已经处理过,所以可以分类讨论;</p>
<p>　　<img src="/images/2.png" alt="alt"></p>
<p>　　这个是一个简单的图形解释(图画歪了)　　</p>
<p> 　　蓝色的查询区间左端点和右端点,红色的是当前区间中点,然后我们将其断开;</p>
<p>　　<img src="/images/4.png" alt="alt"></p>
<p> 　　我们发现查询端点还不在中点两端,那么继续断开;</p>
<p>　　<img src="/images/5.png" alt="alt"></p>
<p>　　此时我们查询端点就在区间两端了;</p>
<p>　　那么考虑怎么查询,<strong>我们可以提前处理出这个区间左半边和右半边的最大区间和,并一起处理出左半边的最大后缀和和右半边的最大前缀和,</strong></p>
<p>　　由于我们的目标区间一定是在左区间或右区间或跨区间,那么如何求出答案就很显然了;</p>
<p> 　　根据上面的预处理,我们可以将一个大区间分层,每层分别处理上一层一半的区间,可以分为$logn$层;</p>
<p>　　关于具体操作,这里简述,即从中点向左扫描,向右扫描,<strong>求出这个区间左半边和右半边的最大区间和,并一起处理出左半边的最大后缀和和右半边的最大前缀和,</strong></p>
<p>　　</p>
<p>　　<strong>关于具体查询</strong></p>
<p> 　　如果我们能快速找到这一层,那么就可以$O(1)$更新出结果;</p>
<p>　　很容易发现,左端点(单个点,因为最后我们将区间划分到一个点)和右端点在树中的位置的LCA就是我们想找的那一层;</p>
<p>　　我们很简单可以向上暴力寻找,时间复杂度$O(logn)$;</p>
<p>　　考虑优化,我们可以用倍增或树剖求LCA,这样,我们就可以将时间复杂度优化到$O(loglogn)$的时间复杂度;</p>
<p>　　但是有些不同的是,还记得我在前面说它是一颗完全二叉树,那么每个节点都是上一个节点二进制左移得到的,那么考虑到这一点,我们可以继续优化;</p>
<p>　　例如,$(10011)_2$和$(10101)_2$,这两个节点的LCA是$(10)_2$,很容易发现它就是两点的公共前缀,那么,我们将其异或,就可以将其前缀去掉;</p>
<p>　　那么剩下的$(110)_2$$log2$得到二进制位数,然后原来节点也将其$log2$,得到二进制位数,那么,LCA所在层即为两者相减;</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>　　上面已经简述了思想,那么代码中我也会有注释,应该很快就能明白,码量较小;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le(x) x&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(x) x&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cut[<span class="number">25</span>][maxn&lt;&lt;<span class="number">2</span>],cat[<span class="number">25</span>][maxn&lt;&lt;<span class="number">2</span>],dep[maxn&lt;&lt;<span class="number">2</span>],a[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pos[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">//cut是记录左区间和右区间最大区间和,cat是记录最大前缀和最大后缀 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> pos[l]=p,<span class="keyword">void</span>();<span class="comment">//记录二进制位置 </span></span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="keyword">int</span> pre,con;<span class="comment">//pre,con是辅助变量 </span></span><br><span class="line">    cut[d][mid]=cat[d][mid]=pre=con=a[mid];con=max(con,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid<span class="number">-1</span>;i&gt;=l;i--)&#123;</span><br><span class="line">        pre+=a[i],con+=a[i];cat[d][i]=max(cat[d][i+<span class="number">1</span>],pre);</span><br><span class="line">        cut[d][i]=max(cut[d][i+<span class="number">1</span>],con),con=max(con,<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="comment">//记录最大后缀, 和左区间的最大区间和 </span></span><br><span class="line">    cut[d][mid+<span class="number">1</span>]=cat[d][mid+<span class="number">1</span>]=pre=con=a[mid+<span class="number">1</span>];con=max(con,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">2</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        pre+=a[i],con+=a[i];cat[d][i]=max(cat[d][i<span class="number">-1</span>],pre);</span><br><span class="line">        cut[d][i]=max(cut[d][i<span class="number">-1</span>],con),con=max(con,<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="comment">//记录最大前缀,和右区间的最大区间和 </span></span><br><span class="line">    Init(le(p),l,mid,d+<span class="number">1</span>),Init(re(p),mid+<span class="number">1</span>,r,d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="keyword">int</span> d=dep[pos[l]]-dep[pos[l]^pos[r]];<span class="comment">//找到深度,即LCA二进制位数 </span></span><br><span class="line">    <span class="keyword">return</span> max(max(cut[d][l],cut[d][r]),cat[d][l]+cat[d][r]);</span><br><span class="line">&#125;<span class="comment">//分类讨论,比较出结果 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n);<span class="keyword">int</span> len=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;n) len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) scan(a[i]);</span><br><span class="line">    Init(<span class="number">1</span>,<span class="number">1</span>,len,<span class="number">1</span>);<span class="comment">//注意,猫树必须是完全二叉树,所以区间长度必须是2的倍数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,l=len&lt;&lt;<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        dep[i]=dep[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;<span class="comment">//预处理深度,即二进制位数 </span></span><br><span class="line">    scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(l),scan(r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(l,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用与拓展"><a href="#应用与拓展" class="headerlink" title="应用与拓展"></a>应用与拓展</h2><p>　　猫树限制性比较大,因为它只是支持区间查询,并且查询的东西也有所限制,所以一定要谨慎选择,遇见修改直接改用线段树;</p>
<p>　　有些题线段树优化DP时,可以选择用猫树加快速度,当然也可以根据猫树构造进行一定拓展,这样对分治也有更好地理解.</p>
<h3 id="推荐例题"><a href="#推荐例题" class="headerlink" title="推荐例题"></a>推荐例题</h3><p>　　<a href="https://www.luogu.org/problem/SP2916" target="_blank" rel="noopener">GSS5</a>,同系列的,可以练一练</p>
<p>　　</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵树</title>
    <url>/2019/10/25/Matrix-Tree/</url>
    <content><![CDATA[<h2 id="必备知识："><a href="#必备知识：" class="headerlink" title="必备知识："></a>必备知识：</h2><p>　　高斯消元，图论基本知识（好像就这。。。（雾）） </p><p>这里是无向图部分，请不要走错场。。。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>　　我们将邻接矩阵定义为矩阵$A(u,v)$，我想邻接矩阵就不用再多说了；</p><p>　　我们将每个点的度数矩阵定义为矩阵$D(u,v)$，这里再加上数学表示；</p><p>　　$D(u,u)=u$这个点的度数，$D(u,v)=0（u!=v)$；</p><a id="more"></a>




<p>　　我们将矩阵Laplace（或Kirchhoff）定义为$L(u,v)=D(u,v)-A(u,v)$</p>
<p>　　我们将生成树的个数定义为 $t$；</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>　　这里将讲述行列式，如果dalao已经学过，请直接跳过这个环节；</p>
<p>　　这里引入的是$N*N$方阵行列式（因为邻接矩阵是方形），例如</p>
<p>　　<img src="/images/1.png" alt="alt"></p>
<p>　　行列式的公式是<script type="math/tex">D=|A|=\sum(-1)^v a_{1,l_1}a_{2,l_2}a_{3,l_3}...a_{n,l_n}</script>.</p>
<p>　　PS：其中v是 $l_1 , l_2 , l_3 … l_n$的逆序对个数；</p>
<p>　　行列式有几个性质：</p>
<ul>
<li>行行交换，结果相反；</li>
<li>行行叠加，结果不变；</li>
<li>矩阵行伸长，结果等比例增加；</li>
</ul>
<p>　　PS：</p>
<p>　　性质1的简单证明：</p>
<p>　　　　由行列式的公式可知，行行交换，必然会出现逆序对的变化，变化为1，那么此时结果符号一定会改变；</p>
<p>　　性质2的补充：</p>
<p>　　　　可以让其他行乘上k叠加到这一行，结果不变；</p>
<p>　　根据这些，我们就可以发现，高斯消元可以很好的利用这些性质，那么高斯消元后矩阵对角线的乘积即为结果；</p>
<p>　　我从其他位置挖来了一个矩阵L的优化证明，说实话，我有点蒙</p>
<p>　　<img src="/images/3.png" alt="alt"></p>
<p>　　我们根据这个性质可以少算一行一列，这应该也算优化吧（心虚~</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>　　这样思路就十分清晰了，这里的矩阵L行列式值即为生成树个数，那么我们就有了步骤：</p>
<ol>
<li>首先构造矩阵L，根据公式$L=D - A$，我们可以很方便地求出矩阵L，当然，在读入边时就可以直接操作，如边 $u$  -&gt; $v$，我们不妨让$f [ u ] [ v ]=f [ v ] [ u ] - -,f [ u ] [ u ]++,f [ v ] [ v ]++$.</li>
<li>然后将矩阵高斯消元，并求出对角线的乘积。</li>
<li>有时因为必须是整数，我们可以采用类似于辗转相除法的减去方法，下面将详细介绍。</li>
</ol>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>　　模板题：<a href="https://www.luogu.org/problem/P4111" target="_blank" rel="noopener">小Z的房间</a></p>
<p>　　思路清晰，只要将一个点和上下左右建边，构造矩阵L，用高斯消元求解；</p>
<p>　　不过高斯消元一般求其小数形式，这里是不行的，因为是方案数（不可能是小数啊QWQ）；</p>
<p>　　这里就应用了类似于辗转相除的方法，回顾辗转相除，将两个数取$mod$，然后交换位置，直到一个为0为止；</p>
<p>　　高斯消元同样是将另一个数消为0，那么我们将函数改一下，如下（看注释）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;n=cent<span class="number">-1</span>;<span class="comment">//定理 1 的应用 ,cent为总点数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(f[j][i])&#123;<span class="comment">//类辗转相除法 ，直到一个为0 </span></span><br><span class="line">                <span class="keyword">int</span> t=f[i][i]/f[j][i];</span><br><span class="line">                <span class="comment">//注意是int类型（向下取整），没减完，但是减后f[i][i]&lt;f[j][i] </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                    f[i][k]=(f[i][k]-f[j][k]*t%mod+mod)%mod;</span><br><span class="line">                swap(f[i],f[j]);<span class="comment">//交换位置辗转减 </span></span><br><span class="line">                <span class="comment">//交换位置是因为上面所说的 f[i][i]&lt;f[j][i] </span></span><br><span class="line">                ans=-ans;<span class="comment">//交换位置要取反 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans*f[i][i]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　应该解释的还算清楚，类似辗转相除的复杂度大约多了一个$log n$，总复杂度$O(n^{3}log n)$我将整个代码放在这里，算一个模板吧：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">100</span>][<span class="number">100</span>],cent;</span><br><span class="line">ll f[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    f[u][u]++,f[u][v]--;</span><br><span class="line">&#125;<span class="comment">//由于矩阵对称，所以加减一次就好。。。 </span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;n=cent<span class="number">-1</span>;<span class="comment">//定理 1 的应用 ,cent为总点数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(f[j][i])&#123;<span class="comment">//类辗转相除法 ，直到一个为0 </span></span><br><span class="line">                <span class="keyword">int</span> t=f[i][i]/f[j][i];</span><br><span class="line">                <span class="comment">//注意是int类型（向下取整），没减完，但是减后f[i][i]&lt;f[j][i] </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                    f[i][k]=(f[i][k]-f[j][k]*t%mod+mod)%mod;</span><br><span class="line">                swap(f[i],f[j]);<span class="comment">//交换位置辗转减 </span></span><br><span class="line">                <span class="comment">//交换位置是因为上面所说的 f[i][i]&lt;f[j][i] </span></span><br><span class="line">                ans=-ans;<span class="comment">//交换位置要取反 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans*f[i][i]+mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> s=getchar();</span><br><span class="line">            <span class="keyword">while</span>(s!=<span class="string">'.'</span>&amp;&amp;s!=<span class="string">'*'</span>)</span><br><span class="line">                s=getchar();<span class="comment">//防止输入出错 </span></span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">'.'</span>) a[i][j]=++cent;<span class="comment">//命名 </span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> now,rou;</span><br><span class="line">            <span class="keyword">if</span>(!(now=a[i][j])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(rou=a[i<span class="number">-1</span>][j]) add(now,rou);</span><br><span class="line">            <span class="keyword">if</span>(rou=a[i][j<span class="number">-1</span>]) add(now,rou);</span><br><span class="line">            <span class="keyword">if</span>(rou=a[i+<span class="number">1</span>][j]) add(now,rou);</span><br><span class="line">            <span class="keyword">if</span>(rou=a[i][j+<span class="number">1</span>]) add(now,rou);<span class="comment">//构建L矩阵 </span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(Gauss()+mod)%mod);<span class="comment">//不能是负数。。。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><p>　　懂了模板当然是不够的，我们应该见识一些技巧：</p>
<h3 id="SDOI2014-重建"><a href="#SDOI2014-重建" class="headerlink" title="[SDOI2014]重建"></a><a href="https://www.luogu.org/problem/P3317" target="_blank" rel="noopener">[SDOI2014]重建</a></h3><p>　　题目不再粘贴，我们直接叙述；</p>
<p>　　这里同样是生成树个数，不过不同的是，这里具有边权值，不过这里并不碍事，我们将叙述有点权值将如何应对。</p>
<p>　　根据高中概率的基本知识，两个没有交集的事件$A,B$，概率分别为$P(A),P(B)$，那么$P(AB)=P(A)*P(B)$，这个应该都懂。</p>
<p>　　那么每条边联通的概率为$P(u,v)$，那么不连通的概率是$1-P(u,v)$，这个应该很显然。</p>
<p>　　那么一个生成树的概率$P(G)= P(u,v)*(1 - P（x，y))$，其中u，v的边属于生成树$G$，而$x,y$这条边不属于。</p>
<p>　　那么，$\sum P(G)$即为总概率，我们将式子改造。</p>
<p>​    <script type="math/tex">\sum_{G} \prod_{(u,v)\in G,(x,y)\notin G} P(u,v)*(1-P(x，y))</script></p>
<p>​    <script type="math/tex">=\sum_G \prod_{(u,v)\in G,(x,y)\notin G} P（u，v）*(1-\frac{P(G)}{P（u，v)})</script></p>
<p>​    <script type="math/tex">=\sum_G (1 - P(G))\prod_{(u,v)\in G,(x,y)\notin G} \frac{P(u,v)}{1-P(u,v)}</script></p>
<p>　　解释一下，由于属于树$G$的边和不属于树$G$的边互为补集，所以就可以利用这个性质，我直接表达这个式子</p>
<p>　　$sum=\sum(1-P(G)) \prod_{(u,v)\in G,(x,y)\notin G} \frac{P(u,v)}{1-P(u,v)}$</p>
<p>　　这样就很显然了，将<script type="math/tex">\frac{P[u][v]}{1-P[u][v]}</script>作为边权值，不过如何处理边权，这里给出步骤：</p>
<p>　　1.我们将矩阵读入，重新定义边权；</p>
<p>　　2.将边权当作度数加在对角线上，然后当作邻接矩阵中边的个数减去即可；</p>
<p>　　3.高斯消元；</p>
<p>　　介绍完毕，$Code$：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">db f[maxn][maxn],ans=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">const</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n--;db ol=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sp=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(f[j][i])&gt;<span class="built_in">fabs</span>(f[sp][i])) sp=j;</span><br><span class="line">        <span class="keyword">if</span>(i!=sp) swap(f[i],f[sp]),ans=-ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            db t=f[j][i]/f[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                f[j][k]-=f[i][k]*t;</span><br><span class="line">        &#125;</span><br><span class="line">        ol*=f[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ol;</span><br><span class="line">&#125;<span class="comment">//这里是小数，所以操作就没有那么鬼畜了。。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sum = sigma P(G) Π(P[u][v]/(1-P[u][v]));</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;f[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            db t=max((<span class="number">1.0</span>-f[i][j]),eps);<span class="comment">//小心 0 哦 </span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;j) ans*=t;<span class="comment">//累加，得出 1-P(G) </span></span><br><span class="line">            f[i][j]/=t;<span class="comment">//步骤1 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                f[i][i]+=f[i][j]; </span><br><span class="line">                f[i][j]=-f[i][j];</span><br><span class="line">            &#125;<span class="comment">//步骤2 ,构图 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf"</span>,<span class="built_in">fabs</span>(Gauss()*ans));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SHOI2016-黑暗前的幻想乡"><a href="#SHOI2016-黑暗前的幻想乡" class="headerlink" title="[SHOI2016]黑暗前的幻想乡"></a><a href="https://www.luogu.org/problem/P4336" target="_blank" rel="noopener">[SHOI2016]黑暗前的幻想乡</a></h3><p>　　这里用到了容斥原理，二进制枚举等技巧，容斥我就不再叙述，自己不会可以<a href="https://baike.baidu.com/item/容斥原理/10146840?fr=aladdin" target="_blank" rel="noopener">yy一下</a>（逃~</p>
<p>　　直接上代码了（有良心注释）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; &gt;a[maxn];</span><br><span class="line">ll f[maxn][maxn],ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=n<span class="number">-1</span>;ll ol=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(f[j][i])&#123;</span><br><span class="line">                <span class="keyword">int</span> t=f[i][i]/f[j][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=m;k++)</span><br><span class="line">                    f[i][k]=(f[i][k]-f[j][k]*t%mod+mod)%mod;</span><br><span class="line">                swap(f[i],f[j]);ol=-ol;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ol=ol*f[i][i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ol+mod)%mod;</span><br><span class="line">&#125;<span class="comment">//唉，方案数。。。 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    f[u][u]++,f[v][v]++;</span><br><span class="line">    f[u][v]--,f[v][u]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,t,u,v;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            a[i].push_back(make_pair(u,v));<span class="comment">//存图 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lim=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));<span class="comment">//暴力建图 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n<span class="number">-1</span>;k++)&#123;<span class="comment">//二进制枚举 </span></span><br><span class="line">            <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;k)&amp;i)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a[k+<span class="number">1</span>].size();j++)</span><br><span class="line">                    add(a[k+<span class="number">1</span>][j].first,a[k+<span class="number">1</span>][j].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((n-cnt)&amp;<span class="number">1</span>) ans=(ans+Gauss())%mod;</span><br><span class="line">        <span class="comment">//容斥原理。。。其实就是奇数和偶数分别加减 。。。 </span></span><br><span class="line">        <span class="keyword">else</span> ans=(ans-Gauss()+mod)%mod;<span class="comment">//防止负数。。。 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　其实还有一些内容，但是由于赶着复习，就没再说了。</p>
<p>　　我们做的这几道题，无非是建图，统计答案，高斯消元时设下关卡，导致题目难度的跃升。</p>
<p>　　但既然已经知道要考哪里，就往哪个地方想，就像专题训练一样，然后找出特点，从而在综合题中找到这个算法的影子；</p>
<p>　　这个算法特点主要就是生成树的计数，所以应该很好看出来，记住特点和处理方法，培养数学思维才是做题目的；</p>
]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>差分约束-SPFA系统</title>
    <url>/2019/02/28/SPFA-Other/</url>
    <content><![CDATA[<p>据说差分约束有很多种，但是我学过的只有SPFA求差分；</p><p>我们知道，例如 $A-B&lt;=C$ ，那么这就是一个差分约束。</p><p>比如说，著名的三角形差分约束，这个大家都是知道的，什么两边之差小于第三边啦，等等等等。</p><p>所以说，我们学他干嘛（我们得出结论：学他没用，谢谢大家观看）</p><p>咳咳——说正事，我们来看一道例题：【luoguP1993】小K的农场：</p><a id="more"></a>




<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小K在MC里面建立很多很多的农场，总共n个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共m个），以下列三种形式描述：</p>
<ul>
<li>农场a比农场b至少多种植了c个单位的作物，</li>
<li>农场a比农场b至多多种植了c个单位的作物，</li>
<li>农场a与农场b种植的作物数一样多。</li>
</ul>
<p>但是，由于小K的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。</p>
<p>输入格式：</p>
<p>第一行包括两个整数 n 和 m，分别表示农场数目和小 K 记忆中的信息数目。</p>
<p>接下来 m 行：</p>
<p>如果每行的第一个数是 1，接下来有 3 个整数 a,b,c，表示农场 a 比农场 b 至少多种植了 c 个单位的作物。</p>
<p>如果每行的第一个数是 2，接下来有 3 个整数 a,b,c，表示农场 a 比农场 b 至多多种植了 c 个单位的作物。如果每行的第一个数是 3，接下来有 2 个整数 a,b，表示农场 a 种植的的数量和 b 一样多。</p>
<p>输出格式：</p>
<p>如果存在某种情况与小 K 的记忆吻合，输出“Yes”，否则输出“No”。</p>
<p>我们看一看题干，能够发现一些条件： <script type="math/tex">1.A-B>=C,2.A-B<=C,3.A=B.</script> </p>
<p>我们一个一个分析先分析第2个（为什么？等会就明白了）</p>
<p>题中让我们求得是否能够让条件成立，那么就用到我们的SPFA了，怎么用？</p>
<p>还记得SPFA那个更新条件吗</p>
<p>$dis[y]&gt;dis[x]+edge[i].w$ ;</p>
<p>所以说，让我们反想一下，既然我们求得答案，那么我们肯定想</p>
<p><script type="math/tex">dis[y]<=dis[x]+edge[i].w</script> ;</p>
<p>因为这样最后我们就可以求得答案了；</p>
<p>那么如果我们将它推论到差分系统呢，我们想让它成立，那么就要让他限制于一个条件，那么很容易就能懂C应该是 $edge[i].w$ ;</p>
<p>那么我们推一下, $A&lt;=B+C -&gt; A-B&lt;=C$ 。这样我们建一个由B指向A的边，边权为C，那么我们再来看第一个条件就很容易懂了。</p>
<p>这个就直接说了, $B-A&lt;=-C$ ，之后就和前面的一样了；</p>
<p>那么来看最后一个条件： $A=B$ 。这个应该是初中（应该不是的小学吧QWQ）数学的知识， $A&gt;=B $&amp;&amp; $A&lt;=B$ ，就可以实现这个条件的差分替换了;</p>
<p>那么再用上SPFA的judge负环的骚操作就可以了。</p>
<p>这样应该就能写出来这道题了——吗?</p>
<p>你会发现你从1点开始跑会有70分，（其实是水的），为什么呢？</p>
<p>这是因为图可能并不联通，那么你这样跑就会凉凉，那么我们可以建一个超级原点，这样就可以联通了，提交发现60分</p>
<p>！！！怎么还少了QAQ！！！</p>
<p>所以说上面的过程是水的呀，我们会T掉，因为BFS会一直在圈里跑，而圈子又太大，那么SPFA的诟病就出来了（关于SPFA，它死了）</p>
<p>SPFA还没有凉透，因为我们会出现负环，而题中就让我们判断负环，我们没法用其他算法啊！</p>
<p>那么就有了应运而生的 $SPFA-DFS$ 判负环版本，来看一下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;<span class="comment">//标记在搜索过程中 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(dis[y]&gt;dis[x]+edge[i].w)&#123;</span><br><span class="line">            dis[y]=dis[x]+edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(vis[y]) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">/*循环环出现，也就是负权值不停更新</span></span><br><span class="line"><span class="comment">             ，那么我们用这个机制就可以return了*/</span></span><br><span class="line">            <span class="keyword">if</span>(SPFA(y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]=<span class="number">0</span>;<span class="comment">//清除标记 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//条件成立 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不会TLE了；</p>
<p>现在来看完整代码（其中有BFS的TLE代码）：</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],cent,vis[maxn],dis[maxn],num[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bool SPFA(int x)&#123;</span></span><br><span class="line"><span class="comment">//    vis[x]=1,num[x]++,dis[x]=0;</span></span><br><span class="line"><span class="comment">//    q.push(x);</span></span><br><span class="line"><span class="comment">//    while(!q.empty())&#123;</span></span><br><span class="line"><span class="comment">//        int x=q.front();vis[x]=0;q.pop();</span></span><br><span class="line"><span class="comment">//        for(int i=head[x];i;i=edge[i].next)&#123;</span></span><br><span class="line"><span class="comment">//            int y=edge[i].to;</span></span><br><span class="line"><span class="comment">//            if(dis[y]&gt;dis[x]+edge[i].w)&#123;</span></span><br><span class="line"><span class="comment">//                dis[y]=dis[x]+edge[i].w;</span></span><br><span class="line"><span class="comment">//                if(!vis[y])&#123;</span></span><br><span class="line"><span class="comment">//                    q.push(y);</span></span><br><span class="line"><span class="comment">//                    num[y]++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                if(num[y]&gt;=n)&#123;</span></span><br><span class="line"><span class="comment">//                    return true; </span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return false;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;<span class="comment">//标记在搜索过程中 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(dis[y]&gt;dis[x]+edge[i].w)&#123;</span><br><span class="line">            dis[y]=dis[x]+edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(vis[y]) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">/*循环环出现，也就是负权值不停更新</span></span><br><span class="line"><span class="comment">             ，那么我们用这个机制就可以return了*/</span></span><br><span class="line">            <span class="keyword">if</span>(SPFA(y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x]=<span class="number">0</span>;<span class="comment">//清除标记 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//条件成立 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("cin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("cout.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,s,a,b,c;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">            add(a,b,-c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">            add(b,a,c);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="number">3</span>)&#123;</span><br><span class="line">            add(a,b,<span class="number">0</span>);</span><br><span class="line">            add(b,a,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(<span class="number">0</span>,i,<span class="number">0</span>);<span class="comment">//超级源点 </span></span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//搜索初始化 </span></span><br><span class="line">    <span class="keyword">if</span>(SPFA(<span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">"No"</span>);    </span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题就结束了，再送一道福利题[USACO05DEC]</p>
<p>好了，就这样了。</p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增Tarjan求LCA</title>
    <url>/2019/02/22/LCA/</url>
    <content><![CDATA[<p>LCA，最近公共祖先，这是树上最常用的算法之一，因为它可以求距离，也可以求路径等等</p><p>LCA有两种写法，一种是倍增思想，另一种是Tarjan求法，我们可以通过一道题来看一看，</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p>欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有N个等待点，有N-1条道路连接着它们，每一条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一个点到另一个点要花费一个游戏币。</p>
<p>参加游戏的人三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对话机（用于和同组的成员联系）。当集合号吹响后，每组成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在N个等待点中确定一个集结点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。</p>
<p>小可可和他的朋友邀请你一起参加这个游戏，由你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？</p>
</blockquote><a id="more"></a>


<p>我们先看一下题目，是三个点到一个点的距离之和最小，图大家可以手模一下，我们设题中给的三个点为x,y,z,每两个点的lca是a,b,c. 距离前缀和数组设为dep[i];那么开始推导：肯定有lca是相同的，这个可以手动证明一下，这里就不再证明了，所以暂设 <em>a==c=true</em> ,那么， </p>
<script type="math/tex; mode=display">
dep[x]+dep[y]-2*dep[a]+dep[z]-dep[b]+dep[a]-dep[b]</script><script type="math/tex; mode=display">
=dep[x]+dep[y]+dep[z]-2*dep[a]-dep[b]</script><p>，然后大家应该就能懂了QAQ，之后还有通用公式 $dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]$ ,只要再找到$a,b,c$中谁与其它两个不同即可；</p>
<p>然后附上Code</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[<span class="number">500007</span>],cent,dep[<span class="number">500007</span>],fa[<span class="number">500007</span>][<span class="number">30</span>],len[<span class="number">500007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[<span class="number">1000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> dy)</span></span>&#123;</span><br><span class="line">    dep[x]=dy;<span class="comment">//求深度 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y][<span class="number">0</span>]=x;</span><br><span class="line">        len[y]=len[x]+edge[i].w;<span class="comment">//其实与深度一样 </span></span><br><span class="line">        dfs(y,dy+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fa[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;<span class="number">1</span>&lt;&lt;i&lt;n;i++)&#123;<span class="comment">//倍增 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//更新每一个点 </span></span><br><span class="line">            <span class="keyword">if</span>(fa[j][i<span class="number">-1</span>]&lt;<span class="number">0</span>) fa[j][i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> fa[j][i]=fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,d=dep[x]-dep[y];d;d&gt;&gt;=<span class="number">1</span>,i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d&amp;<span class="number">1</span>) x=fa[x][i];<span class="comment">//转移至同一高度 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">log</span>(n)+<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//寻找LCA </span></span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;<span class="comment">//自己画图体会一下 </span></span><br><span class="line">            x=fa[x][i];</span><br><span class="line">            y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=lca(a,b),y=lca(b,c),z=lca(a,c),<span class="built_in">exit</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="built_in">exit</span>=z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y==z) <span class="built_in">exit</span>=x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==z) <span class="built_in">exit</span>=y;<span class="comment">//寻找不同的LCA </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,<span class="built_in">exit</span>,dep[a]+dep[b]+dep[c]-dep[x]-dep[y]-dep[z]);<span class="comment">//通用公式计算 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a,b,<span class="number">1</span>),add(b,a,<span class="number">1</span>);<span class="comment">//存图 </span></span><br><span class="line">    &#125;</span><br><span class="line">    Init();<span class="comment">//初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        work(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于为什么Tarjan没过而倍增过了，是因为我们统计倍增$O(nlongn+mlongn)$，比较稳定而作为$O(n+m)$算法的Tarjan却栽了是因为并查集维护时，时间复杂度最坏达到了近$O(n^2+m)$，但是$O(1)$查询的Tarjan在一些数据确实比倍增算法快，但是，在一些非常诡异的数据中，还是用倍增比较妥当，来看代码</p>
<h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[<span class="number">500007</span>],cent,cnt,h[<span class="number">500007</span>],dep[<span class="number">500007</span>],vis[<span class="number">500007</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">500007</span>],f[<span class="number">2000007</span>],see[<span class="number">500007</span>][<span class="number">3</span>],num[<span class="number">500007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[<span class="number">1000007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,id;</span><br><span class="line">&#125;e[<span class="number">3000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> name)</span></span>&#123;</span><br><span class="line">    e[++cnt]=(node1)&#123;h[u],v,name&#125;;h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=get(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[v]=dep[u]+edge[i].w;<span class="comment">//与倍增一样 </span></span><br><span class="line">        Tarjan(v);</span><br><span class="line">        fa[v]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=h[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]&amp;&amp;!f[e[i].id])&#123;</span><br><span class="line">            <span class="keyword">int</span> zz=get(v),x=e[i].id;</span><br><span class="line">            f[x]=zz;<span class="comment">//储存答案 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//与倍增不同的是，它每次都去处理有关点数据，运用访问时间的差别，以来实现Tarjan </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*m;i+=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=see[i][<span class="number">0</span>],y=see[i][<span class="number">1</span>],z=see[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a=f[i],b=f[i+<span class="number">1</span>],c=f[i+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,c,dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b==c) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==c) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,b,dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        scan(a),scan(b);</span><br><span class="line">        add(a,b,<span class="number">1</span>),add(b,a,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*m;i+=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        scan(a),scan(b),scan(c);<span class="comment">//Tarjan储存询问，在工作时一起解决 </span></span><br><span class="line">        see[i][<span class="number">0</span>]=a,see[i][<span class="number">1</span>]=b,see[i][<span class="number">2</span>]=c;</span><br><span class="line">        add1(a,b,i),add1(b,a,i),add1(a,c,i+<span class="number">1</span>);</span><br><span class="line">        add1(c,a,i+<span class="number">1</span>),add1(c,b,i+<span class="number">2</span>),add1(b,c,i+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Tarjan(<span class="number">1</span>);</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TO-BE-CONTINUE"><a href="#TO-BE-CONTINUE" class="headerlink" title="TO BE CONTINUE"></a>TO BE CONTINUE</h5>]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>简谈图论重要性&&图论总结</title>
    <url>/2019/02/21/graph-collect/</url>
    <content><![CDATA[<p>从外地学习回来，我对图论才有认识（以前就没接触过，非常尴尬），说实话，学好图论的重要性，就像学数学时在进行解析几何时，图极有可能是打开答案的最后秘钥，也就是数形结合，而懂的人永远明白，用图解决绝对比用解析简单（一般情况）。而图论对于oi选手说，就是一大杀器，有可能利己，也可能抱憾终身。所以说图论的重要性就很显然了。</p><a id="more"></a>
<p>大家在进入图论的时候，应该先掌握链式前向星建图，当然也可以叫邻接表，先附上我喜欢的模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn],cent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w&#125;; head[u]=cent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　</p>
<p>　　_——所谓模板，也就是自己喜欢的颜色涂上而已。_</p>
<p>　　当然还有一些其他知识，比如说vector建图，这种建图的方式优点是难度小，而且还可以排序，这个在NOIP2018的D2T1上有极大优势。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">scan(a),scan(b);</span><br><span class="line">vec[a].push_back(b);</span><br><span class="line">vec[b].push_back(a);</span><br></pre></td></tr></table></figure>
<p>　　然后只要简单地定义排序一下，即可用食。</p>
<p>　　还有树形dp，这在树形图中将是一大助力，这里是dp求直径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[s];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vi[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dp(y,s);</span><br><span class="line">        an=max(anx,root[x]+root[y]+edge[i].w);</span><br><span class="line">        root[s]=max(root[s],root[y]+edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在入门之后，请仔细思考与总结</p>
<p>　　总结方法：</p>
<p>　　1. 反向建边 <a href="https://www.luogu.org/problemnew/show/P3119" target="_blank" rel="noopener">例题</a></p>
<p>　　2. 路径记数，加法原理，并加上限制条件 <a href="https://www.luogu.org/problemnew/show/P1144" target="_blank" rel="noopener">例题</a></p>
<p>　　3. 巧妙运用二分图的检验 <a href="https://www.luogu.org/problemnew/show/P1525" target="_blank" rel="noopener">例题</a></p>
<p>　　4. 学习二分图的技巧，学会在只有两种条件有关系时，转化成二分图 <a href="https://www.luogu.org/problemnew/show/P2055" target="_blank" rel="noopener">例题</a></p>
<p>　　5. 深刻理解floyd的逐个点处理 <a href="https://www.luogu.org/problemnew/show/P1119" target="_blank" rel="noopener">例题</a></p>
<p>　　6. 二分答案对于路径长度和其他条件的单调性处理 如4中例题</p>
<p>　　7. 分清SPFA（没死透）和Dij两者各自的优势，注意负环</p>
<p>　　8. 在最小生成树中，注意prim和kruskal各自的优势 <a href="https://www.luogu.org/problemnew/show/P1265" target="_blank" rel="noopener">例题1</a> <a href="https://www.luogu.org/problemnew/show/P1991" target="_blank" rel="noopener">例题2</a></p>
<p>　　9. 差分约束 SPFA的独特优势（牢记系统约束） <a href="https://www.luogu.org/problemnew/show/P1993" target="_blank" rel="noopener">例题</a></p>
<p>　　10. 在连通性中巧用度（即入度和出度） <a href="https://www.luogu.org/problemnew/show/P2341" target="_blank" rel="noopener">例题</a></p>
<p>　　11. 善于建超级原点</p>
<p>　　（欢迎评价添加）</p>
<p>　　<strong>缩点</strong></p>
<p>　　在联通性中，缩点是必要的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[maxn],a[maxn],cent,stackk[maxn],cnt,tot[maxn],col[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn],low[maxn],t,vis[maxn],top,root[maxn],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&gt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,from;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,u&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++t;vis[x]=<span class="number">1</span>;</span><br><span class="line">    stackk[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            Tarjan(y);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[y]) low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])&#123;</span><br><span class="line">        cnt++;<span class="keyword">int</span> z;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            z=stackk[top--];</span><br><span class="line">            col[z]=cnt;</span><br><span class="line">            vis[z]=<span class="number">0</span>;</span><br><span class="line">            tot[cnt]+=a[z];</span><br><span class="line">        &#125;<span class="keyword">while</span>(z!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    root[x]=tot[x];<span class="keyword">int</span> ol=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dp(y,x);</span><br><span class="line">        ans=max(ans,root[y]+root[x]);</span><br><span class="line">        ol=max(ol,root[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    root[x]+=ol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=edge[i].from,y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(col[x]!=col[y])&#123;</span><br><span class="line">            add(col[x],col[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root[i]) <span class="keyword">continue</span>;</span><br><span class="line">        dp(i,<span class="number">0</span>);</span><br><span class="line">        ans=max(root[i],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　之后还有许多基础性的知识在以后会看到。</p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan初步-点双连通分量</title>
    <url>/2019/02/21/Tarjan-Point/</url>
    <content><![CDATA[<p>上一次我们讲到了边双，这次我们来看点双。</p><p>说实话来说，点双比边双稍微复杂一些；</p><p>学完边双，我们先看一道题</p><p><img src="/images/1606547-20190220215809712-1764741801.png" alt="alt"></p><p><img src="/images/1606547-20190220215831857-626374096.png" alt="alt"></p><p>第一问都不用说了吧，多余的道路，明显的割边。</p><p>是不是首先想到用边双，但是我们来看一个图：</p><p><img src="/images/1606547-20190220220012034-762051649.png" alt="alt">**</p><p>有点丑，但是凑活看吧。</p><p>它是一个边双，但是！！！！它竟然没有冲突的边！！！</p><p>此时我们就要用点双了（是不是想打死我，竟然没讲，先坑人）</p><a id="more"></a>










<p>先看概念</p>
<p><img src="/images/1606547-20190220220420146-819243403.png" alt="alt"></p>
<p>都说概念是非常重要的，但是概念似乎有点笼统，可以附图解说</p>
<p><img src="/images/1606547-20190221065558808-1746942257.png" alt="alt"></p>
<p>点双的一大特点是它可以重复用点，而那个点就是割点，而我们的缩点操作也是用割点连接各个点双的。</p>
<p>那么我们来看算法，我们在Tarjan时，用栈去维护点双，之后用vector去储存。</p>
<p>我们直接来看上面的题，就会明白这不是点双吗？</p>
<p>然后寻找规律，我们会发现，每一个点双中，只要边个数大于点个数，那么这里的边都是冲突的，那么我们的Code就跃然纸上了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cent=<span class="number">1</span>,t,head[maxn],low[maxn],dfn[maxn],ans1,ans2;</span><br><span class="line"><span class="keyword">int</span> stackk[maxn],cnt,top,root,cut[maxn],col[maxn],vis[maxn];</span><br><span class="line"><span class="keyword">int</span> ol;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;dcc[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[M*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++t;</span><br><span class="line">    stackk[++top]=x;<span class="comment">//入栈 </span></span><br><span class="line">    <span class="keyword">if</span>(x==root&amp;&amp;head[x]==<span class="number">0</span>)&#123;<span class="comment">//不联通时的孤立点 </span></span><br><span class="line">        dcc[++cnt].push_back(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            Tarjan(y,i);</span><br><span class="line">            low[x]=min(low[x],low[y]);<span class="comment">//与其他的一样 </span></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(low[y]&gt;dfn[x]) ans1++;<span class="comment">//记录割边个数 </span></span><br><span class="line">                <span class="keyword">int</span> z;cnt++;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    z=stackk[top--];<span class="comment">//从栈中取出 </span></span><br><span class="line">                    dcc[cnt].push_back(z);<span class="comment">//存入 </span></span><br><span class="line">                &#125;<span class="keyword">while</span>(z!=y);<span class="comment">//停止条件，这个可以想一想为什么 </span></span><br><span class="line">                dcc[cnt].push_back(x);<span class="comment">//把割点也存进去 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>)!=fa) low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans1=ans2=top=cnt=t=ol=<span class="number">0</span>;cent=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(stackk,<span class="number">0</span>,<span class="keyword">sizeof</span> stackk);</span><br><span class="line">    <span class="built_in">memset</span>(dcc,<span class="number">0</span>,<span class="keyword">sizeof</span> dcc);</span><br><span class="line">    <span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="keyword">sizeof</span> col);</span><br><span class="line">    <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span> edge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("way.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("way.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            add(a+<span class="number">1</span>,b+<span class="number">1</span>),add(b+<span class="number">1</span>,a+<span class="number">1</span>);<span class="comment">//由于点从零开始，那么我们+1即可 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i]) root=i,Tarjan(i,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++,ol=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;dcc[i].size();j++)&#123;</span><br><span class="line">                vis[dcc[i][j]]=<span class="number">1</span>;<span class="comment">//记录点双上的点 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;dcc[i].size();k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=head[dcc[i][k]];j;j=edge[j].next)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[edge[j].to]) ol++;<span class="comment">//ol统计边数 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ol/<span class="number">2</span>&gt;dcc[i].size()) ans2+=ol/<span class="number">2</span>;<span class="comment">//由于是双向边，ol会统计量词 </span></span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans1,ans2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们就应该懂了一些基本的概念，和简单的操作，那么，留一个彩蛋，我们该如何去缩点连接呢？</p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan初步-边双联通分量</title>
    <url>/2019/02/21/Tarjan-edge/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本来应该先说强连通分量，但是有一定的分配，所以这个在下一篇博客将会见到。</p><p>这个本想连点连通分量一起讲，但是量有点大，所以我就分两步讲。</p><h2 id="边双"><a href="#边双" class="headerlink" title="边双"></a>边双</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>核心概念:没有割边;</p>
<p>割边只会把图分成两部分对图中的点没有影响;</p>
</blockquote><p>再来看看图解</p><p><img src="/images/1606547-20190220212042286-525246392.png" alt="alt"></p><p><img src="/images/1606547-20190220212112414-120909079.png" alt="alt"></p><p>很容易就能发现，只要将割边断掉，然后剩下的连通块就是我们的边双，那么我们的代码就可以yy出来了，先跑一遍Tarjan求割点，然后在去跑dfs，将每一个边双染色，那么就可以了,而染色操作，以便于我们后面好缩点。</p><a id="more"></a>






<p>我们来看模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            Tarjan(y,i);</span><br><span class="line">            low[x]=min(low[y],low[x]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x]) </span><br><span class="line">                edge[i].flag=edge[(i^<span class="number">1</span>)].flag=<span class="number">1</span>;<span class="comment">//寻找割边 ，并标记 </span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>)!=fa)&#123;</span><br><span class="line">            low[x]=min(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    col[x]=tot;<span class="comment">//染色 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!col[y]&amp;&amp;!edge[i].flag)<span class="comment">//不能是走过的点和割边 </span></span><br><span class="line">            dfs(y);<span class="comment">//遍历 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面插入主函数中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) Tarjan(i,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!col[i]) ++tot,dfs(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家仔细琢磨一下，应该就能懂他的思想了。</p>
<h4 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a>例题1：</h4><p><img src="/images/1606547-20190220213435268-1046380287.png" alt="alt"></p>
<p>这道题很显然是将这个图变为边双。在同一个边双连通分量中，任意两点都有至少两条独立路可达，所以同一个边双连通分量里的所有点可以看做同一个点。 这时就要用到我们的染色缩点，缩点请仔细思考怎么做。</p>
<p>缩点后，新图是一棵树，树的边就是原无向图的桥。 现在问题转化为：在树中至少添加多少条边能使图变为双连通图。</p>
<p> 此时我们就能想出之前我们学过的入度和出度；</p>
<p>那么，只要将度为一的点连边即可，那么此时我们的公式就是添加边数=（树中度为1的节点数+1）/2；</p>
<p>具体做法就是：</p>
<p>首先把两个最近公共祖先最远的两个叶节点之间连接一条边，这样可以把这两个点到祖先的路径上所有点收缩到一起，因为一个形成的环一定是双连通的。 然后再找两个最近公共祖先最远的两个叶节点，这样一对一对找完，恰好是 $(leaf+1)/2$ 次，把所有点收缩到了一起。</p>
<p>这样就解决了，来看</p>
<p><strong>Code</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn 5007</span><br><span class="line">#define M 20007</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,t,head[maxn],cent=1,low[maxn],dfn[maxn],vis[maxn];</span><br><span class="line">int tot,col[maxn],out[maxn],ans,in[maxn],ol;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int next,to,flag,from;</span><br><span class="line">&#125;edge[M&lt;&lt;1];</span><br><span class="line"></span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,0,u&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Tarjan(int x,int fa)&#123;</span><br><span class="line">    low[x]=dfn[x]=++t;</span><br><span class="line">    for(int i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        int y=edge[i].to;</span><br><span class="line">        if(!dfn[y])&#123;</span><br><span class="line">            Tarjan(y,i);</span><br><span class="line">            low[x]=min(low[y],low[x]);</span><br><span class="line">            if(low[y]&gt;dfn[x]) </span><br><span class="line">                edge[i].flag=edge[(i^1)].flag=1;//寻找割边 ，并标记 </span><br><span class="line">        &#125;else if((i^1)!=fa)&#123;</span><br><span class="line">            low[x]=min(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    col[x]=tot;//染色 </span><br><span class="line">    for(int i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        int y=edge[i].to;</span><br><span class="line">        if(!col[y]&amp;&amp;!edge[i].flag)//不能是走过的点和割边 </span><br><span class="line">            dfs(y);//遍历 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void make_dfs(int x,int fa)&#123;</span><br><span class="line">    for(int i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        int y=edge[i].to;</span><br><span class="line">        if(y==fa) continue;</span><br><span class="line">        out[y]++,in[x]++;//计算入度出度 </span><br><span class="line">        make_dfs(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen(&quot;rpaths.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">//    freopen(&quot;rpaths.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1,a,b;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        if(a==b) continue;</span><br><span class="line">        add(a,b),add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!dfn[i]) Tarjan(i,-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!col[i]) ++tot,dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(head,0,sizeof(head));cent=1;//预处理 </span><br><span class="line">    for(int i=2;i&lt;=2*m+1;i++)&#123;</span><br><span class="line">        if(edge[i].flag)&#123;</span><br><span class="line">            add(col[edge[i].from],col[edge[i].to]);</span><br><span class="line">        &#125;//重点！！！染色缩点建树 </span><br><span class="line">    &#125;</span><br><span class="line">    make_dfs(1,-1);//寻找度 </span><br><span class="line">    for(int i=1;i&lt;=tot;++i)&#123;</span><br><span class="line">        if((out[i]==1&amp;&amp;in[i]==0)||(in[i]==1&amp;&amp;!out[i]))&#123;</span><br><span class="line">            ans++;//统计度为一的点 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,(ans+1)/2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p><img src="/images/1606547-20190220214454402-661155595.png" alt="alt"></p>
<p>我们只要缩点，然后求距离就可以了，LCA求距离都懂的吧？（好像又没讲，下次下次）；</p>
<p>我的错，没说LCA，在讲完LCA后再来看这道吧，但看完后就懂代码了：</p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cent=<span class="number">1</span>,head[maxn],low[maxn],dfn[maxn],col[maxn],t,fa[maxn][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> tot,dep[maxn],q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,from,flag;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,u,<span class="number">0</span>&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> dy)</span></span>&#123;</span><br><span class="line">    dep[x]=dy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][<span class="number">0</span>]==y) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y][<span class="number">0</span>]=x;</span><br><span class="line">        make_dfs(y,dy+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fa[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    make_dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[j][i<span class="number">-1</span>]&lt;<span class="number">0</span>) fa[j][i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> fa[j][i]=fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,d=dep[x]-dep[y];d;d&gt;&gt;=<span class="number">1</span>,i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d&amp;<span class="number">1</span>) x=fa[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">25</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">            y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            Tarjan(y,i);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x]) </span><br><span class="line">                edge[i].flag=edge[(i^<span class="number">1</span>)].flag=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>)!=f)&#123;</span><br><span class="line">            low[x]=min(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    col[x]=tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!col[y]&amp;&amp;!edge[i].flag)</span><br><span class="line">            dfs(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"test.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"test.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a,b),add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) Tarjan(i,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!col[i]) ++tot,dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));cent=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].flag)&#123;</span><br><span class="line">            add(col[edge[i].from],col[edge[i].to]);</span><br><span class="line">        &#125;<span class="comment">//缩点套路，一定要会 </span></span><br><span class="line">    &#125;</span><br><span class="line">    Init();<span class="comment">//LCA初始化 </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dep[col[a]]+dep[col[b]]<span class="number">-2</span>*dep[lca(col[a],col[b])]);<span class="comment">//求距离 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就差不多结束了，自己可以在找些题，要深刻理解缩点的重要性;</p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan初步-割点和割边</title>
    <url>/2019/02/20/Tarjan-cut/</url>
    <content><![CDATA[<p>所谓割点（顶）割边，我们引进一个概念</p><blockquote>
<p>割点：删掉它之后(删掉所有跟它相连的边)，图必然会分裂成两个或两个以上的子图。<br>割边(桥)：删掉一条边后，图必然会分裂成两个或两个以上的子图，又称桥。</p>
</blockquote><p>这样大家就应该能简单理解（怎么可能）割点割边了。</p><p>所以我们再来看一个图</p><p><img src="/images/1606547-20190220195943670-530347978.png" alt="alt"></p><p>这样大家就能明白了吧（明白是明白了，但是要他干嘛（自动忽略））到后面会明白的。</p><a id="more"></a>





<p>然后怎么求，这是一个问题，直接想法是搜索，枚举每一个点，然后再去检验是否联通，这样的复杂度应该是O(n2),很显然很不优秀，万一数据是1e5以上不就凉凉了吗。所以我们就可以引进我们的正题了，low-dfn求割点割边。</p>
<p>怎么求？</p>
<p>那么什么是dfn和low呢，简单解释一下，我们的dfn是一个时间戳，也就是访问的时间，而这个就是Tarjan算法的基础（好像忘介绍Tarjan了）而我们的low就是返祖边，也就是通向以前的点的边，所以说，看图。</p>
<p><img src="/images/1606547-20190220200553851-1931555270.png" alt="alt"></p>
<p>还有一个重要概念也就是，母树继承其子树最小的返祖边，而我们可以观察一下我们的dfn值和low值，再去寻找割点会发现一个重要的事实</p>
<p><strong>每一个割点的dfn一定小于等于其子树的low值，而且如果是root，他的子树大于1他即为割点</strong></p>
<p>这样我们的Code就跃然纸上了</p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++t;<span class="comment">//记录时间戳，当然low值一开始也要与dfn值相同 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;<span class="comment">//链式前向星 </span></span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//如果没有访问过 </span></span><br><span class="line">            Tarjan(y);<span class="comment">//搜索查询 </span></span><br><span class="line">            low[x]=min(low[x],low[y]);<span class="comment">//母树继承子树的最小low值 </span></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;<span class="comment">//发现的规律 </span></span><br><span class="line">                flag++;<span class="comment">//这个是因为我们的root也有可能是割点，但是它的条件有点苛刻 </span></span><br><span class="line">                <span class="keyword">if</span>(flag&gt;<span class="number">1</span>||x!=root) cut[x]=<span class="number">1</span>;<span class="comment">//如果子树分支大于1，那么无论他是什么都是割点了 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> low[x]=min(low[x],dfn[y]);<span class="comment">//返祖边，其连接的点继承最小返祖边连接点的dfn值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注应该也是很明白了。</p>
<p>然后我们来看割边，上面已经将概念说的很明白了，删边后，图不联通，然后我们根据一个图来理解割边。</p>
<p><img src="/images/1606547-20190220203114220-1429768074.png" alt="alt"></p>
<p>有点丑，左边是dfn，右边是low，红边就是割边，观察一下割边两边两个点的dfn和low值情况，我们会惊喜地发现</p>
<p><strong>母点的dfn值小于（严格小于）子点low值，那么这条边就是割边</strong></p>
<p><strong>
</strong>好的，我们的代码就出来了</p>
<p>这里引进一道例题</p>
<p><img src="/images/1606547-20190220204305802-44108416.png" alt="alt"></p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,head[<span class="number">100007</span>],cent=<span class="number">1</span>,low[<span class="number">100007</span>],dfn[<span class="number">100007</span>],t,cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[<span class="number">700007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prin</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">&#125;ans[<span class="number">100007</span>];<span class="comment">//记录答案 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(prin a,prin b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.u!=b.u) <span class="keyword">return</span> a.u&lt;b.u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;<span class="comment">//重载运算符 ，sort要用 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;<span class="comment">//fa定义的是我们走的上一条边 </span></span><br><span class="line">    low[x]=dfn[x]=++t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            Tarjan(y,i);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x]) &#123;</span><br><span class="line">                ans[++cnt]=x&lt;y?(prin)&#123;x,y&#125;:(prin)&#123;y,x&#125;;<span class="comment">//如果结果成立，那么就可以记录这条边的两个点 </span></span><br><span class="line">            &#125; <span class="comment">//这里用到了格式转换，prin的定义在上面 </span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i^<span class="number">1</span>)!=fa)&#123;<span class="comment">//由于双向建边，需要cent=1，然后用^来验边，或者将fa定义成上一个点 </span></span><br><span class="line">            low[x]=min(low[x],dfn[y]);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"danger.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"danger.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;<span class="comment">//去除自环 </span></span><br><span class="line">        add(a,b),add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) Tarjan(i,<span class="number">0</span>);<span class="comment">//不连通时Tarjan，一般都是这样写 </span></span><br><span class="line">    &#125; </span><br><span class="line">    sort(ans+<span class="number">1</span>,ans+cnt+<span class="number">1</span>);<span class="comment">//题目要求 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans[i].u,ans[i].v);<span class="comment">//输出答案 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这应该就很显然了。</p>
<p>模板讲完了，但还是希望自己的Code要有自己的风格，可以借鉴，但不能照搬。</p>
<p><strong>例题</strong></p>
<p>我们先来看一下割点</p>
<p><img src="/images/1606547-20190220205223960-1428633160.png" alt="alt"></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——嗅探器</p>
<p>这个显然是要找割点的，那么怎么找呢?</p>
<p>我们的最大问题是有两个点，在去掉割点后，如何检验他们是否在同一个联通块中?</p>
<p>我们首先的思路是暴力枚举割点，然后检验联通，大概能得10%的分，那么我们来想正解</p>
<p>我们可以以a为根，那么就解决了两个点的问题，但是检验呢？</p>
<p>我们可以将Tarjan定义为bool类型即可，然后在Tarjan的过程中，回溯检验值，详情看代码；</p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,head[<span class="number">100007</span>],cent,root,fin,low[<span class="number">100007</span>],dfn[<span class="number">100007</span>];</span><br><span class="line"><span class="keyword">int</span> t,cut[<span class="number">100007</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;edge[<span class="number">3000007</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++t;</span><br><span class="line">    <span class="keyword">bool</span> f1=(x==fin);<span class="comment">// fin是b点，f1是标记 ，检验有没有b点 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            <span class="keyword">bool</span> z=Tarjan(y);f1|=z;<span class="comment">//回溯标记 </span></span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x]&amp;&amp;x!=root&amp;&amp;x!=fin&amp;&amp;z)&#123;<span class="comment">//这里割点一定不是root </span></span><br><span class="line">                cut[x]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low[x]=min(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1;<span class="comment">//回溯标记 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("dfnIn.in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("dfnin.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b)&amp;&amp;(a!=<span class="number">0</span>&amp;&amp;b!=<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;</span><br><span class="line">        add(a,b),add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;root,&amp;fin);</span><br><span class="line">    Tarjan(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]&amp;&amp;low[fin]&gt;=dfn[i])&#123;<span class="comment">//检验 </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);<span class="comment">//输出 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就让我们对Tarjan的灵活运用有更深理解。</p>
<p>然后来看割边例题</p>
<p>……</p>
<p>其实上面的板子题就是我们的例题（逃~）</p>
<p>好了，Tarjan的割点和割边就结束了。</p>
<p>可以自行找些例题，寻找灵感。</p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Shortest-road</title>
    <url>/2019/02/15/Shortest-road/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    这个本来应该在从外地学习回来之后就因该写的,但是只写了一半,不过看看自己以前写的,果然还是理解太浅了;</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>也许有很多人觉得最短路就是那几个算法，不过也确实，但是我们的难点主要在建图上。</p><p>但是既然是基础，那么就应该好好掌握做法，多敲几遍就好了。</p><p>最短路主要的几个算法有 $\text{Dijkstra,floyd,Bellman-ford}$ 和$\text{SPFA}$，而SPFA是Bellman-ford的队列优化，所以一般用SPFA算法。</p><a id="more"></a>



<h3 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h3><p>我们先来看floyd，这是一个 $O(n^3)$ 算法，在大部分的题中是会超时的，但是我们在一些题中会发现一些巧妙地运用，之后我们会见到</p>
<h4 id="模板题："><a href="#模板题：" class="headerlink" title="模板题："></a>模板题：</h4><p><a href="https://www.luogu.org/problemnew/show/P2419" target="_blank" rel="noopener">牛大赛Cow Contest</a></p>
<blockquote>
<p>FJ的N(1 &lt;= N &lt;= 100)头奶牛们最近参加了场程序设计竞赛:)。在赛场上，奶牛们按1..N依次编号。每头奶牛的编程能力不尽相同，并且没有哪两头奶牛的水平不相上下，也就是说，奶牛们的编程能力有明确的排名。 整个比赛被分成了若干轮，每一轮是两头指定编号的奶牛的对决。如果编号为A的奶牛的编程能力强于编号为B的奶牛(1 &lt;= A &lt;= N; 1 &lt;= B &lt;= N; A != B) ，那么她们的对决中，编号为A的奶牛总是能胜出。 FJ想知道奶牛们编程能力的具体排名，于是他找来了奶牛们所有 M(1 &lt;= M &lt;= 4,500)轮比赛的结果，希望你能根据这些信息，推断出尽可能多的奶牛的编程能力排名。比赛结果保证不会自相矛盾。</p>
</blockquote>
<p>这道题就是一个简单地转换，我们只要看可以判断出的前面的牛+后面的牛=n-1即可,而可以前面的牛和后面的牛可以通过建图,跑最短路,看是否能够到达即可，所以说我们直接来看板子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,e[<span class="number">107</span>][<span class="number">107</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        e[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=j&amp;&amp;e[i][k]&amp;&amp;e[k][j])</span><br><span class="line">                    e[i][j]=<span class="number">1</span>;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(e[i][j]||e[j][i]) r++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r==n<span class="number">-1</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分治Floyed-update"><a href="#分治Floyed-update" class="headerlink" title="分治Floyed(update)"></a>分治Floyed(update)</h4><p>​    $\text{Floyed}$ 的本质是动规,而且能够看出,最外层的枚举,即经过点的枚举,可以分开枚举,我们用这种技巧可以得到不经过某个点两点之前最短路,我之前的一次模拟赛就考到了这道题;</p>
<p>​    与其类似的是 <a href="https://nanti.jisuanke.com/t/A1108" target="_blank" rel="noopener">2016计蒜之道复赛A[百度地图的实时路况]</a>;</p>
<p>​    于是我将这道题加入,深刻理解一下Floyed的插点枚举;</p>
<blockquote>
<p>给你一个 $n$ 个点的图,定义 $d(x,y,z)$ 是不经过点 $y$ , $x$ 到 $z$ 最短路径的长度,求</p>
<script type="math/tex; mode=display">
\sum_{x\in G}{\sum_{y\in G}}{\sum_{z\in G}}{d(x,y,z)}(x\not= y,z\not =y)</script></blockquote>
<p>​    考虑Floyed的插点枚举,那么我们分治使枚举分开,并且有效地利用已经枚举的信息.</p>
<p>​    流程即:枚举经过的点,而分治可以让我们分开枚举,当分治到一个点时,这个点时没有枚举的,统计答案;</p>
<p>​    模拟: 在分治区间 $[L,R]$ 时,此时在此区间中的点我们还没有枚举过,首先记录初始 $dis$ ,以便我们之后使用,之后将 $[L,mid]$ 的点枚举,去分治 $[mid+1,R]$ 中的点,之后递归回来时,消除枚举区间 $[L,mid]$ 对 $dis$ 的影响,即恢复至之前记录的值,再枚举区间 $[mid+1,R]$ ;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 307</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,dis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_print&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(type_of_print x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==l) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j==l) <span class="keyword">continue</span>;</span><br><span class="line">				ans+=<span class="number">1l</span>l*dis[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,other[maxn][maxn];</span><br><span class="line">	<span class="built_in">memcpy</span>(other,dis,<span class="keyword">sizeof</span> other);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=mid;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[i][k]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(dis[k][j]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(~dis[i][j]) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">				<span class="keyword">else</span> dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=solve(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">memcpy</span>(dis,other,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=mid+<span class="number">1</span>;k&lt;=r;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[i][k]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(dis[k][j]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(~dis[i][j]) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">				<span class="keyword">else</span> dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=solve(l,mid);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"sum.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"sum.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	scan(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			scan(dis[i][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve(<span class="number">1</span>,n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">0 1 -1 -1 </span></span><br><span class="line"><span class="comment">-1 0 1 -1 </span></span><br><span class="line"><span class="comment">-1 -1 0 1 </span></span><br><span class="line"><span class="comment">1 -1 -1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>(注:这是我考试时的代码,题面略有不同,如不连通时最短路为-1,请注意);</p>
<h4 id="bitset优化Floyed-update"><a href="#bitset优化Floyed-update" class="headerlink" title="bitset优化Floyed(update)"></a>bitset优化Floyed(update)</h4><p>​    bitset是一个存0/1串的类似数组的东西,但是其类似于二进制运算,速度快;</p>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><blockquote>
<p>度量一个有向图联通情况的一个指标是连通数，指图中可达顶点对个的个数。</p>
<p>给一个 $n(n&lt;=2000)$ 个节点的连通图,求连通数;</p>
</blockquote>
<p>​    直接跑Floyed是绝对会超时的,但是bitset可以在其中优化转移,这一步:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dis[i][j]|=dis[i][k]|dis[k][j]</span><br></pre></td></tr></table></figure>
<p>​    可以转化成这一步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dis[i]|=dis[k](dis[i][k]==<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>​    这应该就很显然了;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt;a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">	type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">	<span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> top,<span class="keyword">typename</span>... tops&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(top &amp;x,tops&amp;... X)</span></span>&#123;</span><br><span class="line">	scan(x),scan(X...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scan(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">char</span> s=getchar();</span><br><span class="line">			<span class="keyword">while</span>(s!=<span class="string">'1'</span>&amp;&amp;s!=<span class="string">'0'</span>) s=getchar();</span><br><span class="line">			a[i][j]=s-<span class="string">'0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j][i]) a[j]|=a[i];<span class="comment">//只有这一步有差别</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=a[i].count();<span class="comment">//统计时count可以加快速度</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>由于原来的Dijkstra太慢，就算加上链式前向星，也不能优化多少;</p>
<p>所以我们直接来看堆优化的Dijstra;</p>
<h5 id="Code-Dijkstra"><a href="#Code-Dijkstra" class="headerlink" title="Code(Dijkstra)"></a>Code(Dijkstra)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> allom 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> s,n,m,cent=<span class="number">1</span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &gt;q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> next,to,w;&#125;edge[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> vis[allom],head[<span class="number">500001</span>],dis[allom];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[cent].next=head[a];</span><br><span class="line">    edge[cent].to=b;</span><br><span class="line">    edge[cent].w=w;</span><br><span class="line">    head[a]=cent;</span><br><span class="line">    cent++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(dis[s],s));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.top().second;q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[k]&gt;edge[i].w+dis[x])&#123;</span><br><span class="line">                dis[k]=edge[i].w+dis[x];</span><br><span class="line">                q.push(make_pair(dis[k],k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> f=<span class="number">1</span>;f&lt;=n;f++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[f]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m),scan(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(a),scan(b),scan(c);</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;    </span><br><span class="line">    Dijkstra(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Code-SPFA"><a href="#Code-SPFA" class="headerlink" title="Code(SPFA)"></a>Code(SPFA)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> allom 100007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,s,cent,head[<span class="number">500005</span>],vis[allom];</span><br><span class="line"><span class="keyword">int</span> dis[allom];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=INF;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(s),vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop(),vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u],k;i;i=edge[i].next)&#123;</span><br><span class="line">            k=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[k]&gt;dis[u]+edge[i].w)&#123;</span><br><span class="line">                dis[k]=dis[u]+edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[k]) q.push(k),vis[k]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i] == INF ? <span class="built_in">printf</span>(<span class="string">"2147483647"</span>) : <span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[i]);</span><br><span class="line">        <span class="keyword">if</span>(i!=n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    当然，这个只是一个模板，其中SPFA在稠密图中会退变为O（mn）算法，此时Dijkstra的优势就出来了。</p>
<p>​    注意:Dijkstra一般不去跑负权值图,如果想要去跑了话,要add许多东西,这不在我们的讨论范围之内;</p>
<p>​    有人说SPFA它死了，但是它还没有凉透，在判断负环中仍有着不可替代的作用，而且在大部分图是稀疏图时，SPFA是跑得飞快,判负环时dfs-Floyed更快。</p>
<p>​    所以根据数据范围自行选择，一般在遇见边大于200000而没有缩点时，可以果断扔SPFA了；</p>
<p>然后我们主要介绍几个最短路的类型：</p>
<h4 id="1-分层图"><a href="#1-分层图" class="headerlink" title="1.分层图"></a>1.分层图</h4><p>分层图主要用于一些较为特殊的题目，比如说</p>
<p><a href="https://www.luogu.org/problemnew/show/P4822" target="_blank" rel="noopener">冻结</a></p>
<blockquote>
<p>给一张 $n$ 个点 $m$ 条边的无向图,每个边有一个权值 $w$ ,有 $k$ 次机会将一个边的边权变成 $w/2$ ,求从 $1$ 到 $n$ 的最短路;</p>
</blockquote>
<p>​    分层图模版题,我们将使用次数看成一个状态,分别建 $k$ 个图,相邻两个图之间连接用权值的一半即可;</p>
<p>​    update:好像可以设每个点的状态,最短路时转移即可;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,head[maxn],dis[maxn],vis[maxn],cent,ans=<span class="number">2147483647</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> next,to,w;&#125;edge[<span class="number">2</span>*maxn];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; &gt; &gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a+b*n;&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cent]=(node)&#123;head[u],v,w&#125;;head[u]=cent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type_of_scan&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(type_of_scan &amp;x)</span></span>&#123;</span><br><span class="line">    type_of_scan f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="keyword">char</span> s=getchar();</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="string">'0'</span>||s&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(s==<span class="string">'-'</span>)f=<span class="number">-1</span>;s=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;s=getchar();&#125;</span><br><span class="line">    x*=f;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*k+n+<span class="number">1</span>;i++) dis[i]=<span class="number">124563335</span>;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(dis[s],s));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.top().second;q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[y]&gt;dis[x]+edge[i].w)&#123;</span><br><span class="line">                dis[y]=dis[x]+edge[i].w;</span><br><span class="line">                q.push(make_pair(dis[y],y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scan(n),scan(m),scan(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,w;i&lt;=m;i++)&#123;</span><br><span class="line">        scan(a),scan(b),scan(w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;j++) add(point(a,j),point(b,j),w),add(point(b,j),point(a,j),w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;j++) add(point(a,j),point(b,j+<span class="number">1</span>),w/<span class="number">2</span>),add(point(b,j),point(a,j+<span class="number">1</span>),w/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) ans=min(ans,dis[point(n,i)]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-同余建图"><a href="#2-同余建图" class="headerlink" title="2.同余建图"></a>2.同余建图</h4><p>​    这道题算是思路清奇,于是就将其展示出来(当时就是这道题导致整个博客咕咕了)</p>
<h5 id="跳楼机"><a href="#跳楼机" class="headerlink" title="跳楼机"></a><a href="https://www.luogu.org/problemnew/show/P3403" target="_blank" rel="noopener">跳楼机</a></h5><blockquote>
<p>有一个 $h$ 层的楼房,一个跳楼机可以选择跳 $x,y,z$ 层或者跳回一楼,求能跳到的楼层数;    </p>
</blockquote>
<p>​    这道题思路并不好想,说是同余,主要是因为统计答案时与跑最短路优化数组大小的方式罢了;</p>
<p>​    先考虑如何统计答案,如果我们知道一个数 $num$ 是由 $y,z$ 构成的,即 $num=a<em>y+b</em>z$ ,那么如果加上 $x$ ,它能到达的楼层数为 $(h-num)/x+1$ 其中 $+1$ 是因为要统计不加 $x$ 时的答案;</p>
<p>​    那么如果我们能找到这些数,再去统计不就好了吗,但是会有重复,而且数字太过庞大,无法完全跑出,那么考虑什么时候回重复计数,即当 $num1=num2+ax$ ,此时 $num1$ 的贡献已经被 $num2$ 统计过,再观察两个数字,发现 $num1 \% x=num2 \% x$ ,那么我们只要找到余数相同中最小值即可,余数共有 $x$ 种; </p>
<p>​    设计转移方程: 设 $f[i]$ 指余数为 $i$ 时最小楼层数,那么转移有两种方式;</p>
<p>​    $f[(i+y)\%x]=min(f[i]+y,f[(i+y)\%x])$</p>
<p>​    $f[(i+z)\%x]=min(f[i]+z,f[(i+y)\%x])$ </p>
<p>​    我们可以用最短路来优化类似于点 $i$ 与点 $(i+y)\%x$ 连边,代价为 $y$ ;</p>
<p>​    讲到这应该就够了,这里附上的代码是我以前写的,有点丑,但是能看懂;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000000000LL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll h,dis[maxn];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>],x,y,z,mn,vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt;q;<span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;q.push(<span class="number">1</span>);dis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front();q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i]!=mn)&#123;</span><br><span class="line">			<span class="keyword">int</span> y=(a[i]+x)%mn;</span><br><span class="line">			<span class="keyword">if</span>(dis[y]&gt;dis[x]+a[i])&#123;</span><br><span class="line">				dis[y]=dis[x]+a[i];</span><br><span class="line">				<span class="keyword">if</span>(!vis[y]) vis[y]=<span class="number">1</span>,q.push(y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;=dis[i]) ans+=(x-dis[i])/mn+<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("srwudi.in","r",stdin);</span></span><br><span class="line"><span class="comment">//	freopen("srwudi.out","w",stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%d%d%d"</span>,&amp;h,&amp;x,&amp;y,&amp;z);</span><br><span class="line">	mn=min(x,min(y,z));</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>||y==<span class="number">1</span>||z==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld"</span>,h);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">1</span>]=x,a[<span class="number">2</span>]=y,a[<span class="number">3</span>]=z;</span><br><span class="line">	SPFA();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,query(h));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-另类的建图方式"><a href="#3-另类的建图方式" class="headerlink" title="3.另类的建图方式"></a>3.另类的建图方式</h4><p>​    线段树,树剖优化建图,倍增优化建图,然后再去跑最短路,但这个我并不是非常想说,先咕咕了;</p>
<h5 id="TO-BE-CONTINUE"><a href="#TO-BE-CONTINUE" class="headerlink" title="TO BE CONTINUE"></a>TO BE CONTINUE</h5>]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
</search>
